<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>day21-File类-字节流-字符流</title>
    <url>/2021/05/23/day21-File%E7%B1%BB-%E5%AD%97%E8%8A%82%E6%B5%81-%E5%AD%97%E7%AC%A6%E6%B5%81/</url>
    <content><![CDATA[<p><strong><em>今日内容：File类、字节流、字符流</em></strong></p>
<span id="more"></span>

<h1 id="第一章、File类"><a href="#第一章、File类" class="headerlink" title="第一章、File类"></a>第一章、File类</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p><code>java.io.File</code> 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p>
<h2 id="1-2-构造方法"><a href="#1-2-构造方法" class="headerlink" title="1.2 构造方法"></a>1.2 构造方法</h2><ul>
<li><code>public File(String pathname) </code> ：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的 File实例。  </li>
<li><code>public File(String parent, String child) </code> ：从<strong>父路径名字符串和子路径名字符串</strong>创建新的 File实例。</li>
<li><code>public File(File parent, String child)</code> ：从<strong>父抽象路径名和子路径名字符串</strong>创建新的 File实例。  </li>
</ul>
<ul>
<li>构造举例，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件路径名</span></span><br><span class="line">String pathname = <span class="string">&quot;D:\\aaa.txt&quot;</span>;</span><br><span class="line">File file1 = <span class="keyword">new</span> File(pathname); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件路径名</span></span><br><span class="line">String pathname2 = <span class="string">&quot;D:\\aaa\\bbb.txt&quot;</span>;</span><br><span class="line">File file2 = <span class="keyword">new</span> File(pathname2); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父路径和子路径字符串</span></span><br><span class="line"> String parent = <span class="string">&quot;d:\\aaa&quot;</span>;</span><br><span class="line"> String child = <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line"> File file3 = <span class="keyword">new</span> File(parent, child);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父级File对象和子路径字符串</span></span><br><span class="line">File parentDir = <span class="keyword">new</span> File(<span class="string">&quot;d:\\aaa&quot;</span>);</span><br><span class="line">String child = <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line">File file4 = <span class="keyword">new</span> File(parentDir, child);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<ol>
<li>一个File对象代表硬盘中实际存在的一个文件或者目录。</li>
<li>无论该路径下是否存在文件或者目录，都不影响File对象的创建。</li>
</ol>
</blockquote>
<h2 id="1-3-常用方法"><a href="#1-3-常用方法" class="headerlink" title="1.3 常用方法"></a>1.3 常用方法</h2><h3 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h3><ul>
<li><p><code>public String getAbsolutePath() </code> ：返回此File的绝对路径名字符串。</p>
</li>
<li><p><code>public String getPath()</code> ：将此File转换为路径名字符串。 </p>
</li>
<li><p><code>public String getName()</code>  ：返回由此File表示的文件或目录的名称。  </p>
</li>
<li><p><code>public long length()</code>  ：返回由此File表示的文件的长度。 </p>
</li>
</ul>
<blockquote>
<p>API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。</p>
</blockquote>
<h3 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h3><ul>
<li><p><strong>绝对路径</strong>：从盘符开始的路径，这是一个完整的路径。</p>
</li>
<li><p><strong>相对路径</strong>：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。</p>
</li>
</ul>
<h3 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h3><ul>
<li><code>public boolean exists()</code> ：此File表示的文件或目录是否实际存在。</li>
<li><code>public boolean isDirectory()</code> ：此File表示的是否为目录。</li>
<li><code>public boolean isFile()</code> ：此File表示的是否为文件。</li>
</ul>
<h3 id="创建删除功能的方法"><a href="#创建删除功能的方法" class="headerlink" title="创建删除功能的方法"></a>创建删除功能的方法</h3><ul>
<li><code>public boolean createNewFile()</code> ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 </li>
<li><code>public boolean delete()</code> ：删除由此File表示的文件或目录。  </li>
<li><code>public boolean mkdir()</code> ：创建由此File表示的目录。</li>
<li><code>public boolean mkdirs()</code> ：创建由此File表示的目录，包括任何必需但不存在的父目录。</li>
</ul>
<blockquote>
<p>API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。</p>
</blockquote>
<h2 id="1-4-目录的遍历"><a href="#1-4-目录的遍历" class="headerlink" title="1.4 目录的遍历"></a>1.4 目录的遍历</h2><ul>
<li><code>public String[] list()</code> ：返回一个String数组，表示该File目录中的所有文件或子目录。</li>
</ul>
<ul>
<li><code>public File[] listFiles()</code> ：返回一个File数组，表示该File目录中的所有的文件或子目录的File对象。  </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileFor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File dir = <span class="keyword">new</span> File(<span class="string">&quot;d:\\java_code&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">//获取当前目录下的文件以及文件夹的名称。</span></span><br><span class="line">		String[] names = dir.list();</span><br><span class="line">		<span class="keyword">for</span>(String name : names)&#123;</span><br><span class="line">			System.out.println(name);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<p>调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。</p>
</blockquote>
<h2 id="1-5-顶级父类们"><a href="#1-5-顶级父类们" class="headerlink" title="1.5 顶级父类们"></a>1.5 顶级父类们</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center"><strong>输入流</strong></th>
<th align="center">输出流</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>字节流</strong></td>
<td align="center">字节输入流<br><strong>InputStream</strong></td>
<td align="center">字节输出流<br><strong>OutputStream</strong></td>
</tr>
<tr>
<td align="center"><strong>字符流</strong></td>
<td align="center">字符输入流<br><strong>Reader</strong></td>
<td align="center">字符输出流<br><strong>Writer</strong></td>
</tr>
</tbody></table>
<h1 id="第二章-字节流"><a href="#第二章-字节流" class="headerlink" title="第二章 字节流"></a>第二章 字节流</h1><h2 id="2-1-一切皆为字节"><a href="#2-1-一切皆为字节" class="headerlink" title="2.1 一切皆为字节"></a>2.1 一切皆为字节</h2><p>一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。</p>
<h2 id="2-2-字节输出流【OutputStream】"><a href="#2-2-字节输出流【OutputStream】" class="headerlink" title="2.2 字节输出流【OutputStream】"></a>2.2 字节输出流【OutputStream】</h2><p><code>java.io.OutputStream </code>抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<ul>
<li><code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。  </li>
<li><code>public void flush() </code> ：刷新此输出流并强制任何缓冲的输出字节被写出。  </li>
<li><code>public void write(byte[] b)</code>：将 b.length字节从指定的字节数组写入此输出流。  </li>
<li><code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  </li>
<li><code>public abstract void write(int b)</code> ：将指定的字节输出流。</li>
</ul>
<blockquote>
<p>小贴士：</p>
<p>close方法，当完成流的操作时，必须调用此方法，释放系统资源。</p>
</blockquote>
<h2 id="2-3-FileOutputStream类"><a href="#2-3-FileOutputStream类" class="headerlink" title="2.3 FileOutputStream类"></a>2.3 FileOutputStream类</h2><p><code>OutputStream</code>有很多子类，我们从最简单的一个子类开始。</p>
<p><code>java.io.FileOutputStream </code>类是文件输出流，用于将数据写出到文件。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public FileOutputStream(File file)</code>：创建文件输出流以写入由指定的 File对象表示的文件。 </li>
<li><code>public FileOutputStream(String name)</code>： 创建文件输出流以指定的名称写入文件。  </li>
</ul>
<p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。</p>
<ul>
<li>构造举例，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileOutputStreamConstructor</span> <span class="title">throws</span> <span class="title">IOException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   	 	<span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写出字节数据"><a href="#写出字节数据" class="headerlink" title="写出字节数据"></a>写出字节数据</h3><ol>
<li><strong>写出字节</strong>：<code>write(int b)</code> 方法，每次可以写出一个字节数据，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 写出数据</span></span><br><span class="line">      	fos.write(<span class="number">97</span>); <span class="comment">// 写出第1个字节</span></span><br><span class="line">      	fos.write(<span class="number">98</span>); <span class="comment">// 写出第2个字节</span></span><br><span class="line">      	fos.write(<span class="number">99</span>); <span class="comment">// 写出第3个字节</span></span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">abc</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<ol>
<li>虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。</li>
<li>流操作完毕后，必须释放系统资源，调用close方法，千万记得。</li>
</ol>
</blockquote>
<ol start="2">
<li><strong>写出字节数组</strong>：<code>write(byte[] b)</code>，每次可以写出数组中的数据，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      	<span class="keyword">byte</span>[] b = <span class="string">&quot;我是程序员&quot;</span>.getBytes();</span><br><span class="line">      	<span class="comment">// 写出字节数组数据</span></span><br><span class="line">      	fos.write(b);</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">我是程序员</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>写出指定长度字节数组</strong>：<code>write(byte[] b, int off, int len)</code> ,每次写出从off索引开始，len个字节，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      	<span class="keyword">byte</span>[] b = <span class="string">&quot;abcde&quot;</span>.getBytes();</span><br><span class="line">		<span class="comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span></span><br><span class="line">        fos.write(b,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">cd</span><br></pre></td></tr></table></figure>

<h3 id="数据追加续写"><a href="#数据追加续写" class="headerlink" title="数据追加续写"></a>数据追加续写</h3><p>经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？</p>
<ul>
<li><code>public FileOutputStream(File file, boolean append)</code>： 创建文件输出流以写入由指定的 File对象表示的文件。  </li>
<li><code>public FileOutputStream(String name, boolean append)</code>： 创建文件输出流以指定的名称写入文件。  </li>
</ul>
<p>这两个构造方法，参数中都需要传入一个boolean类型的值，<code>true</code> 表示追加数据，<code>false</code> 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>，<span class="keyword">true</span>);     </span><br><span class="line">      	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      	<span class="keyword">byte</span>[] b = <span class="string">&quot;abcde&quot;</span>.getBytes();</span><br><span class="line">		<span class="comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span></span><br><span class="line">        fos.write(b);</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">文件操作前：cd</span><br><span class="line">文件操作后：cdabcde</span><br></pre></td></tr></table></figure>

<h3 id="写出换行"><a href="#写出换行" class="headerlink" title="写出换行"></a>写出换行</h3><p>Windows系统里，换行符号是<code>\r\n</code> 。把</p>
<p>以指定是否追加续写了，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>);  </span><br><span class="line">      	<span class="comment">// 定义字节数组</span></span><br><span class="line">      	<span class="keyword">byte</span>[] words = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>,<span class="number">101</span>&#125;;</span><br><span class="line">      	<span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">          	<span class="comment">// 写出一个字节</span></span><br><span class="line">            fos.write(words[i]);</span><br><span class="line">          	<span class="comment">// 写出一个换行, 换行符号转成数组写出</span></span><br><span class="line">            fos.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>回车符<code>\r</code>和换行符<code>\n</code> ：<ul>
<li>回车符：回到一行的开头（return）。</li>
<li>换行符：下一行（newline）。</li>
</ul>
</li>
<li>系统中的换行：<ul>
<li>Windows系统里，每行结尾是 <code>回车+换行</code> ，即<code>\r\n</code>；</li>
<li>Unix系统里，每行结尾只有 <code>换行</code> ，即<code>\n</code>；</li>
<li>Mac系统里，每行结尾是 <code>回车</code> ，即<code>\r</code>。从 Mac OS X开始与Linux统一。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="2-4-字节输入流【InputStream】"><a href="#2-4-字节输入流【InputStream】" class="headerlink" title="2.4 字节输入流【InputStream】"></a>2.4 字节输入流【InputStream】</h2><p><code>java.io.InputStream </code>抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p>
<ul>
<li><code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。    </li>
<li><code>public abstract int read()</code>： 从输入流读取数据的下一个字节。 </li>
<li><code>public int read(byte[] b)</code>： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。</li>
</ul>
<blockquote>
<p>小贴士：</p>
<p>close方法，当完成流的操作时，必须调用此方法，释放系统资源。</p>
</blockquote>
<h2 id="2-5-FileInputStream类"><a href="#2-5-FileInputStream类" class="headerlink" title="2.5 FileInputStream类"></a>2.5 FileInputStream类</h2><p><code>java.io.FileInputStream </code>类是文件输入流，从文件中读取字节。</p>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>FileInputStream(File file)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 </li>
<li><code>FileInputStream(String name)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。  </li>
</ul>
<p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出<code>FileNotFoundException</code> 。</p>
<ul>
<li>构造举例，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStreamConstructor</span> <span class="title">throws</span> <span class="title">IOException</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   	 	<span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        FileInputStream fos = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileInputStream fos = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取字节数据"><a href="#读取字节数据" class="headerlink" title="读取字节数据"></a>读取字节数据</h3><ol>
<li><strong>读取字节</strong>：<code>read</code>方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line">      	<span class="comment">// 读取数据，返回一个字节</span></span><br><span class="line">        <span class="keyword">int</span> read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">      	<span class="comment">// 读取到末尾,返回-1</span></span><br><span class="line">       	read = fis.read();</span><br><span class="line">        System.out.println( read);</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>循环改进读取方式，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line">      	<span class="comment">// 定义变量，保存数据</span></span><br><span class="line">        <span class="keyword">int</span> b ；</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((b = fis.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)b);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<ol>
<li>虽然读取了一个字节，但是会自动提升为int类型。</li>
<li>流操作完毕后，必须释放系统资源，调用close方法，千万记得。</li>
</ol>
</blockquote>
<ol start="2">
<li><strong>使用字节数组读取</strong>：<code>read(byte[] b)</code>，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回<code>-1</code> ，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象.</span></span><br><span class="line">       	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;read.txt&quot;</span>); <span class="comment">// 文件中为abcde</span></span><br><span class="line">      	<span class="comment">// 定义变量，作为有效个数</span></span><br><span class="line">        <span class="keyword">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字节数组，作为装字节数据的容器   </span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> (( len= fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">           	<span class="comment">// 每次读取后,把数组变成字符串打印</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(b));</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">ab</span><br><span class="line">cd</span><br><span class="line">ed</span><br></pre></td></tr></table></figure>

<p>错误数据<code>d</code>，是由于最后一次读取时，只读取一个字节<code>e</code>，数组中，上次读取的数据没有被完全替换，所以要通过<code>len</code> ，获取有效的字节，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象.</span></span><br><span class="line">       	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;read.txt&quot;</span>); <span class="comment">// 文件中为abcde</span></span><br><span class="line">      	<span class="comment">// 定义变量，作为有效个数</span></span><br><span class="line">        <span class="keyword">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字节数组，作为装字节数据的容器   </span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> (( len= fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">           	<span class="comment">// 每次读取后,把数组的有效字节部分，变成字符串打印</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(b，<span class="number">0</span>，len));<span class="comment">//  len 每次读取的有效字节个数</span></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">ab</span><br><span class="line">cd</span><br><span class="line">e</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<p>使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。</p>
</blockquote>
<h2 id="2-6-字节流练习：图片复制"><a href="#2-6-字节流练习：图片复制" class="headerlink" title="2.6 字节流练习：图片复制"></a>2.6 字节流练习：图片复制</h2><h3 id="复制原理图解"><a href="#复制原理图解" class="headerlink" title="复制原理图解"></a>复制原理图解</h3><p><img src="/2021/05/23/day21-File%E7%B1%BB-%E5%AD%97%E8%8A%82%E6%B5%81-%E5%AD%97%E7%AC%A6%E6%B5%81/2_copy.jpg"></p>
<h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><p>复制图片文件，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 1.1 指定数据源</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\test.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2 指定目的地</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test_copy.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.读写数据</span></span><br><span class="line">        <span class="comment">// 2.1 定义数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 2.2 定义长度</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="comment">// 2.3 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.4 写出数据</span></span><br><span class="line">            fos.write(b, <span class="number">0</span> , len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<p>流的关闭原则：先开后关，后开先关。</p>
</blockquote>
<h1 id="第三章-字符流"><a href="#第三章-字符流" class="headerlink" title="第三章 字符流"></a>第三章 字符流</h1><p>当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。</p>
<h2 id="3-1-字符输入流【Reader】"><a href="#3-1-字符输入流【Reader】" class="headerlink" title="3.1 字符输入流【Reader】"></a>3.1 字符输入流【Reader】</h2><p><code>java.io.Reader</code>抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p>
<ul>
<li><code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。    </li>
<li><code>public int read()</code>： 从输入流读取一个字符。 </li>
<li><code>public int read(char[] cbuf)</code>： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。</li>
</ul>
<h2 id="3-2-FileReader类"><a href="#3-2-FileReader类" class="headerlink" title="3.2 FileReader类"></a>3.2 FileReader类</h2><p><code>java.io.FileReader </code>类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<blockquote>
<p>小贴士：</p>
<ol>
<li><p>字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。</p>
<p>idea中UTF-8</p>
</li>
<li><p>字节缓冲区：一个字节数组，用来临时存储字节数据。</p>
</li>
</ol>
</blockquote>
<h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>FileReader(File file)</code>： 创建一个新的 FileReader ，给定要读取的File对象。   </li>
<li><code>FileReader(String fileName)</code>： 创建一个新的 FileReader ，给定要读取的文件的名称。  </li>
</ul>
<p>当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。</p>
<ul>
<li>构造举例，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReaderConstructor</span> <span class="title">throws</span> <span class="title">IOException</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   	 	<span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取字符数据"><a href="#读取字符数据" class="headerlink" title="读取字符数据"></a>读取字符数据</h3><ol>
<li><strong>读取字符</strong>：<code>read</code>方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，循环读取，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：虽然读取了一个字符，但是会自动提升为int类型。</p>
</blockquote>
<ol start="2">
<li><strong>使用字符数组读取</strong>：<code>read(char[] cbuf)</code>，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回<code>-1</code> ，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FRRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line">      	<span class="comment">// 定义变量，保存有效字符个数</span></span><br><span class="line">        <span class="keyword">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字符数组，作为装字符数据的容器</span></span><br><span class="line">         <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(cbuf))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(cbuf));</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">   </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>获取有效的字符改进，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line">      	<span class="comment">// 定义变量，保存有效字符个数</span></span><br><span class="line">        <span class="keyword">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字符数组，作为装字符数据的容器</span></span><br><span class="line">        <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(cbuf))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(cbuf,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">// 关闭资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">	<span class="comment">// 元数据保持一致</span></span><br></pre></td></tr></table></figure>

<h2 id="3-3-字符输出流【Writer】"><a href="#3-3-字符输出流【Writer】" class="headerlink" title="3.3 字符输出流【Writer】"></a>3.3 字符输出流【Writer】</h2><p><code>java.io.Writer </code>抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<ul>
<li><code>void write(int c)</code> 写入单个字符。</li>
<li><code>void write(char[] cbuf) </code>写入字符数组。 </li>
<li><code>abstract  void write(char[] cbuf, int off, int len) </code>写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 </li>
<li><code>void write(String str) </code>写入字符串。 </li>
<li><code>void write(String str, int off, int len)</code> 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。</li>
<li><code>void flush() </code>刷新该流的缓冲。  </li>
<li><code>void close()</code> 关闭此流，但要先刷新它。 </li>
</ul>
<h2 id="3-4-FileWriter类"><a href="#3-4-FileWriter类" class="headerlink" title="3.4 FileWriter类"></a>3.4 FileWriter类</h2><p><code>java.io.FileWriter </code>类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<h3 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>FileWriter(File file)</code>： 创建一个新的 FileWriter，给定要读取的File对象。   </li>
<li><code>FileWriter(String fileName)</code>： 创建一个新的 FileWriter，给定要读取的文件的名称。  </li>
</ul>
<p>当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。</p>
<ul>
<li>构造举例，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileWriterConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   	 	<span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基本写出数据"><a href="#基本写出数据" class="headerlink" title="基本写出数据"></a>基本写出数据</h3><p><strong>写出字符</strong>：<code>write(int b)</code> 方法，每次可以写出一个字符数据，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 写出数据</span></span><br><span class="line">      	fw.write(<span class="number">97</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">      	fw.write(<span class="string">&#x27;b&#x27;</span>); <span class="comment">// 写出第2个字符</span></span><br><span class="line">      	fw.write(<span class="string">&#x27;C&#x27;</span>); <span class="comment">// 写出第3个字符</span></span><br><span class="line">      	fw.write(<span class="number">30000</span>); <span class="comment">// 写出第4个字符，中文编码表中30000对应一个汉字。</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">/*</span></span><br><span class="line"><span class="comment">        【注意】关闭资源时,与FileOutputStream不同。</span></span><br><span class="line"><span class="comment">      	 如果不关闭,数据只是保存到缓冲区，并未保存到文件。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// fw.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">abC田</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<ol>
<li>虽然参数为int类型四个字节，但是只会保留一个字符的信息写出。</li>
<li>未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。</li>
</ol>
</blockquote>
<h3 id="关闭和刷新"><a href="#关闭和刷新" class="headerlink" title="关闭和刷新"></a>关闭和刷新</h3><p>因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要<code>flush</code> 方法了。</p>
<ul>
<li><code>flush</code> ：刷新缓冲区，流对象可以继续使用。</li>
<li><code>close </code>:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</li>
</ul>
<p>代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出数据，通过flush</span></span><br><span class="line">        fw.write(<span class="string">&#x27;刷&#x27;</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">        fw.flush();</span><br><span class="line">        fw.write(<span class="string">&#x27;新&#x27;</span>); <span class="comment">// 继续写出第2个字符，写出成功</span></span><br><span class="line">        fw.flush();</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 写出数据，通过close</span></span><br><span class="line">        fw.write(<span class="string">&#x27;关&#x27;</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">        fw.close();</span><br><span class="line">        fw.write(<span class="string">&#x27;闭&#x27;</span>); <span class="comment">// 继续写出第2个字符,【报错】java.io.IOException: Stream closed</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。</p>
</blockquote>
<h3 id="写出其他数据"><a href="#写出其他数据" class="headerlink" title="写出其他数据"></a>写出其他数据</h3><ol>
<li><strong>写出字符数组</strong> ：<code>write(char[] cbuf)</code> 和 <code>write(char[] cbuf, int off, int len)</code> ，每次可以写出字符数组中的数据，用法类似FileOutputStream，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      	<span class="keyword">char</span>[] chars = <span class="string">&quot;我是程序员&quot;</span>.toCharArray();</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 写出字符数组</span></span><br><span class="line">      	fw.write(chars); <span class="comment">// 我是程序员</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 写出从索引2开始，2个字节。索引2是&#x27;程&#x27;，两个字节，也就是&#x27;程序&#x27;。</span></span><br><span class="line">        fw.write(b,<span class="number">2</span>,<span class="number">2</span>); <span class="comment">// 程序</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>写出字符串</strong>：<code>write(String str)</code> 和 <code>write(String str, int off, int len)</code> ，每次可以写出字符串中的数据，更为方便，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 字符串</span></span><br><span class="line">      	String msg = <span class="string">&quot;我是程序员&quot;</span>;</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 写出字符数组</span></span><br><span class="line">      	fw.write(msg); <span class="comment">//我是程序员</span></span><br><span class="line">      </span><br><span class="line">		<span class="comment">// 写出从索引2开始，2个字节。索引2是&#x27;程&#x27;，两个字节，也就是&#x27;程序&#x27;。</span></span><br><span class="line">        fw.write(msg,<span class="number">2</span>,<span class="number">2</span>);	<span class="comment">// 程序</span></span><br><span class="line">      	</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>续写和换行</strong>：操作类似于FileOutputStream。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象，可以续写数据</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>，<span class="keyword">true</span>);     </span><br><span class="line">      	<span class="comment">// 写出字符串</span></span><br><span class="line">        fw.write(<span class="string">&quot;我是&quot;</span>);</span><br><span class="line">      	<span class="comment">// 写出换行</span></span><br><span class="line">      	fw.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">      	<span class="comment">// 写出字符串</span></span><br><span class="line">  		fw.write(<span class="string">&quot;程序员&quot;</span>);</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果:</span><br><span class="line">我是</span><br><span class="line">程序员</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：字符流，只能操作文本文件，不能操作图片，视频等非文本文件。</p>
<p>当我们单纯读或者写文本文件时  使用字符流 其他情况使用字节流</p>
</blockquote>
<h1 id="第四章-IO异常的处理"><a href="#第四章-IO异常的处理" class="headerlink" title="第四章 IO异常的处理"></a>第四章 IO异常的处理</h1><h3 id="JDK7前处理"><a href="#JDK7前处理" class="headerlink" title="JDK7前处理"></a>JDK7前处理</h3><p>之前的入门练习，我们一直把异常抛出，而实际开发中并不能这样处理，建议使用<code>try...catch...finally</code> 代码块，处理异常部分，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandleException1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// 声明变量</span></span><br><span class="line">        FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建流对象</span></span><br><span class="line">            fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 写出数据</span></span><br><span class="line">            fw.write(<span class="string">&quot;我是程序员&quot;</span>); <span class="comment">//我是程序员</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fw != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fw.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDK7的处理-扩展知识点了解内容"><a href="#JDK7的处理-扩展知识点了解内容" class="headerlink" title="JDK7的处理(扩展知识点了解内容)"></a>JDK7的处理(扩展知识点了解内容)</h3><p>还可以使用JDK7优化后的<code>try-with-resource</code> 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (创建流对象语句，如果多个,使用<span class="string">&#x27;;&#x27;</span>隔开) &#123;</span><br><span class="line">	<span class="comment">// 读写数据</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandleException2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">try</span> ( FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>); ) &#123;</span><br><span class="line">            <span class="comment">// 写出数据</span></span><br><span class="line">            fw.write(<span class="string">&quot;我是程序员&quot;</span>); <span class="comment">//我是程序员</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDK9的改进-扩展知识点了解内容"><a href="#JDK9的改进-扩展知识点了解内容" class="headerlink" title="JDK9的改进(扩展知识点了解内容)"></a>JDK9的改进(扩展知识点了解内容)</h3><p>JDK9中<code>try-with-resource</code> 的改进，对于<strong>引入对象</strong>的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动close，我们来了解一下格式。</p>
<p>改进前格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 被final修饰的对象</span></span><br><span class="line"><span class="keyword">final</span> Resource resource1 = <span class="keyword">new</span> Resource(<span class="string">&quot;resource1&quot;</span>);</span><br><span class="line"><span class="comment">// 普通对象</span></span><br><span class="line">Resource resource2 = <span class="keyword">new</span> Resource(<span class="string">&quot;resource2&quot;</span>);</span><br><span class="line"><span class="comment">// 引入方式：创建新的变量保存</span></span><br><span class="line"><span class="keyword">try</span> (Resource r1 = resource1;</span><br><span class="line">     Resource r2 = resource2) &#123;</span><br><span class="line">     <span class="comment">// 使用对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进后格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 被final修饰的对象</span></span><br><span class="line"><span class="keyword">final</span> Resource resource1 = <span class="keyword">new</span> Resource(<span class="string">&quot;resource1&quot;</span>);</span><br><span class="line"><span class="comment">// 普通对象</span></span><br><span class="line">Resource resource2 = <span class="keyword">new</span> Resource(<span class="string">&quot;resource2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入方式：直接引入</span></span><br><span class="line"><span class="keyword">try</span> (resource1; resource2) &#123;</span><br><span class="line">     <span class="comment">// 使用对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进后，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       	<span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">final</span>  FileReader fr  = <span class="keyword">new</span> FileReader(<span class="string">&quot;in.txt&quot;</span>);</span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;out.txt&quot;</span>);</span><br><span class="line">       	<span class="comment">// 引入到try中</span></span><br><span class="line">        <span class="keyword">try</span> (fr; fw) &#123;</span><br><span class="line">          	<span class="comment">// 定义变量</span></span><br><span class="line">            <span class="keyword">int</span> b;</span><br><span class="line">          	<span class="comment">// 读取数据</span></span><br><span class="line">          	<span class="keyword">while</span> ((b = fr.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            	<span class="comment">// 写出数据</span></span><br><span class="line">            	fw.write(b);</span><br><span class="line">          	&#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第五章-属性集"><a href="#第五章-属性集" class="headerlink" title="第五章 属性集"></a>第五章 属性集</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p><code>java.util.Properties </code> 继承于<code> Hashtable</code> ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，<code>System.getProperties</code> 方法就是返回一个<code>Properties</code>对象。</p>
<h2 id="5-2-Properties类"><a href="#5-2-Properties类" class="headerlink" title="5.2 Properties类"></a>5.2 Properties类</h2><h3 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public Properties()</code> :创建一个空的属性列表。</li>
</ul>
<h3 id="基本的存储方法"><a href="#基本的存储方法" class="headerlink" title="基本的存储方法"></a>基本的存储方法</h3><ul>
<li><code>public Object setProperty(String key, String value)</code> ： 保存一对属性。  </li>
<li><code>public String getProperty(String key) </code> ：使用此属性列表中指定的键搜索属性值。</li>
<li><code>public Set&lt;String&gt; stringPropertyNames() </code> ：所有键的名称的集合。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建属性集对象</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 添加键值对元素</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;filename&quot;</span>, <span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;length&quot;</span>, <span class="string">&quot;209385038&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;location&quot;</span>, <span class="string">&quot;D:\\a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印属性集对象</span></span><br><span class="line">        System.out.println(properties);</span><br><span class="line">        <span class="comment">// 通过键,获取属性值</span></span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;filename&quot;</span>));</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;length&quot;</span>));</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;location&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历属性集,获取所有键的集合</span></span><br><span class="line">        Set&lt;String&gt; strings = properties.stringPropertyNames();</span><br><span class="line">        <span class="comment">// 打印键值对</span></span><br><span class="line">        <span class="keyword">for</span> (String key : strings ) &#123;</span><br><span class="line">          	System.out.println(key+<span class="string">&quot; -- &quot;</span>+properties.getProperty(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">&#123;filename=a.txt, length=<span class="number">209385038</span>, location=D:\a.txt&#125;</span><br><span class="line">a.txt</span><br><span class="line"><span class="number">209385038</span></span><br><span class="line">D:\a.txt</span><br><span class="line">filename -- a.txt</span><br><span class="line">length -- <span class="number">209385038</span></span><br><span class="line">location -- D:\a.txt</span><br></pre></td></tr></table></figure>

<h3 id="与流相关的方法"><a href="#与流相关的方法" class="headerlink" title="与流相关的方法"></a>与流相关的方法</h3><ul>
<li><code>public void load(InputStream inStream)</code>： 从字节输入流中读取键值对。 </li>
</ul>
<p>参数中使用了字节输入流，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。文本数据格式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filename&#x3D;a.txt</span><br><span class="line">length&#x3D;209385038</span><br><span class="line">location&#x3D;D:\a.txt</span><br></pre></td></tr></table></figure>

<p>加载代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建属性集对象</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 加载文本中信息到属性集</span></span><br><span class="line">        pro.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;read.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 遍历集合并打印</span></span><br><span class="line">        Set&lt;String&gt; strings = pro.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String key : strings ) &#123;</span><br><span class="line">          	System.out.println(key+<span class="string">&quot; -- &quot;</span>+pro.getProperty(key));</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">filename -- a.txt</span><br><span class="line">length -- <span class="number">209385038</span></span><br><span class="line">location -- D:\a.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>培训学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>day20-线程通信-线程池-Lambda表达式</title>
    <url>/2021/05/20/day20-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1-%E7%BA%BF%E7%A8%8B%E6%B1%A0-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p><strong><em>今日内容：线程通信、线程池、Lambda表达式</em></strong></p>
<span id="more"></span>

<h1 id="第一章、线程通信"><a href="#第一章、线程通信" class="headerlink" title="第一章、线程通信"></a>第一章、线程通信</h1><h2 id="1-1-线程间通信"><a href="#1-1-线程间通信" class="headerlink" title="1.1 线程间通信"></a>1.1 线程间通信</h2><p><strong>概念：</strong>多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。</p>
<p>比如：线程A用来生成包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在线程通信问题。</p>
<p><img src="/2021/05/20/day20-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1-%E7%BA%BF%E7%A8%8B%E6%B1%A0-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.bmp"></p>
<p><strong>为什么要处理线程间通信：</strong></p>
<p>多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。</p>
<p><strong>如何保证线程间通信有效利用资源：</strong></p>
<p>多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即—— <strong>等待唤醒机制。</strong></p>
<h2 id="1-2-等待唤醒机制"><a href="#1-2-等待唤醒机制" class="headerlink" title="1.2 等待唤醒机制"></a>1.2 等待唤醒机制</h2><p><strong>什么是等待唤醒机制</strong></p>
<p>这是多个线程间的一种<strong>协作</strong>机制。谈到线程我们经常想到的是线程间的<strong>竞争（race）</strong>，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。</p>
<p>就是在一个线程进行了规定操作后，就进入等待状态（**wait()<strong>）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（</strong>notify()**）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。</p>
<p>wait/notify 就是线程间的一种协作机制。</p>
<p><strong>等待唤醒中的方法</strong></p>
<p>等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下：</p>
<ol>
<li>wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个<strong>特别的动作</strong>，也即是“<strong>通知（notify）</strong>”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中</li>
<li>notify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。 </li>
<li>notifyAll：则释放所通知对象的 wait set 上的全部线程。</li>
</ol>
<blockquote>
<p>注意：</p>
<p>哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。</p>
<p>总结如下：</p>
<ul>
<li>如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态；</li>
<li>否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态</li>
</ul>
</blockquote>
<p><strong>调用wait和notify方法需要注意的细节</strong></p>
<ol>
<li>wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。</li>
<li>wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</li>
<li>wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。 </li>
</ol>
<h2 id="1-3-生产者与消费者问题"><a href="#1-3-生产者与消费者问题" class="headerlink" title="1.3 生产者与消费者问题"></a>1.3 生产者与消费者问题</h2><p>等待唤醒机制其实就是经典的“生产者与消费者”的问题。</p>
<p>就拿生产包子消费包子来说等待唤醒机制如何有效利用资源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">包子铺线程生产包子，吃货线程消费包子。当包子没有时（包子状态为<span class="keyword">false</span>），吃货线程等待，包子铺线程生产包子（即包子状态为<span class="keyword">true</span>），并通知吃货线程（解除吃货的等待状态）,因为已经有包子了，那么包子铺线程进入等待状态。接下来，吃货线程能否进一步执行则取决于锁的获取情况。如果吃货获取到锁，那么就执行吃包子动作，包子吃完（包子状态为<span class="keyword">false</span>），并通知包子铺线程（解除包子铺的等待状态）,吃货线程进入等待。包子铺线程能否进一步执行则取决于锁的获取情况。</span><br></pre></td></tr></table></figure>

<p><strong>代码演示：</strong></p>
<p>包子资源类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaoZi</span> </span>&#123;</span><br><span class="line">     String  pier ;</span><br><span class="line">     String  xianer ;</span><br><span class="line">     <span class="keyword">boolean</span>  flag = <span class="keyword">false</span> ;<span class="comment">//包子资源 是否存在  包子资源状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>吃货线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChiHuo</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BaoZi bz;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChiHuo</span><span class="params">(String name,BaoZi bz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.bz = bz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (bz)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bz.flag == <span class="keyword">false</span>)&#123;<span class="comment">//没包子</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        bz.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;吃货正在吃&quot;</span>+bz.pier+bz.xianer+<span class="string">&quot;包子&quot;</span>);</span><br><span class="line">                bz.flag = <span class="keyword">false</span>;</span><br><span class="line">                bz.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包子铺线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaoZiPu</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BaoZi bz;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaoZiPu</span><span class="params">(String name,BaoZi bz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.bz = bz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//造包子</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//同步</span></span><br><span class="line">            <span class="keyword">synchronized</span> (bz)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bz.flag == <span class="keyword">true</span>)&#123;<span class="comment">//包子资源  存在</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                        bz.wait();</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 没有包子  造包子</span></span><br><span class="line">                System.out.println(<span class="string">&quot;包子铺开始做包子&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(count%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 冰皮  五仁</span></span><br><span class="line">                    bz.pier = <span class="string">&quot;冰皮&quot;</span>;</span><br><span class="line">                    bz.xianer = <span class="string">&quot;五仁&quot;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 薄皮  牛肉大葱</span></span><br><span class="line">                    bz.pier = <span class="string">&quot;薄皮&quot;</span>;</span><br><span class="line">                    bz.xianer = <span class="string">&quot;牛肉大葱&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line"></span><br><span class="line">                bz.flag=<span class="keyword">true</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;包子造好了：&quot;</span>+bz.pier+bz.xianer);</span><br><span class="line">                System.out.println(<span class="string">&quot;吃货来吃吧&quot;</span>);</span><br><span class="line">                <span class="comment">//唤醒等待线程 （吃货）</span></span><br><span class="line">                bz.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//等待唤醒案例</span></span><br><span class="line">        BaoZi bz = <span class="keyword">new</span> BaoZi();</span><br><span class="line"></span><br><span class="line">        ChiHuo ch = <span class="keyword">new</span> ChiHuo(<span class="string">&quot;吃货&quot;</span>,bz);</span><br><span class="line">        BaoZiPu bzp = <span class="keyword">new</span> BaoZiPu(<span class="string">&quot;包子铺&quot;</span>,bz);</span><br><span class="line"></span><br><span class="line">        ch.start();</span><br><span class="line">        bzp.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">包子铺开始做包子</span><br><span class="line">包子造好了：冰皮五仁</span><br><span class="line">吃货来吃吧</span><br><span class="line">吃货正在吃冰皮五仁包子</span><br><span class="line">包子铺开始做包子</span><br><span class="line">包子造好了：薄皮牛肉大葱</span><br><span class="line">吃货来吃吧</span><br><span class="line">吃货正在吃薄皮牛肉大葱包子</span><br><span class="line">包子铺开始做包子</span><br><span class="line">包子造好了：冰皮五仁</span><br><span class="line">吃货来吃吧</span><br><span class="line">吃货正在吃冰皮五仁包子</span><br></pre></td></tr></table></figure>

<h1 id="第二章、线程池"><a href="#第二章、线程池" class="headerlink" title="第二章、线程池"></a>第二章、线程池</h1><h2 id="2-1-线程池思想概述"><a href="#2-1-线程池思想概述" class="headerlink" title="2.1 线程池思想概述"></a>2.1 线程池思想概述</h2><p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：</p>
<p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p>
<p>那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？</p>
<p>在Java中可以通过线程池来达到这样的效果。今天我们就来详细讲解一下Java的线程池。</p>
<h2 id="2-2-线程池概念"><a href="#2-2-线程池概念" class="headerlink" title="2.2 线程池概念"></a>2.2 线程池概念</h2><ul>
<li><strong>线程池：</strong>其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</li>
</ul>
<p>由于线程池中有很多操作都是与优化资源相关的，我们在这里就不多赘述。我们通过一张图来了解线程池的工作原理：</p>
<p><img src="/2021/05/20/day20-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1-%E7%BA%BF%E7%A8%8B%E6%B1%A0-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86.bmp"></p>
<p>合理利用线程池能够带来三个好处：</p>
<ol>
<li>降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li>
<li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</li>
</ol>
<h2 id="2-3-线程池的使用"><a href="#2-3-线程池的使用" class="headerlink" title="2.3 线程池的使用"></a>2.3 线程池的使用</h2><p>Java里面线程池的顶级接口是<code>java.util.concurrent.Executor</code>，但是严格意义上讲<code>Executor</code>并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是<code>java.util.concurrent.ExecutorService</code>。</p>
<p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在<code>java.util.concurrent.Executors</code>线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。</p>
<p>Executors类中有个创建线程池的方法如下：</p>
<ul>
<li><code>public static ExecutorService newFixedThreadPool(int nThreads)</code>：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量)</li>
</ul>
<p>获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下：</p>
<ul>
<li><p><code>public Future&lt;?&gt; submit(Runnable task)</code>:获取线程池中的某一个线程对象，并执行</p>
<blockquote>
<p>Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。</p>
</blockquote>
</li>
</ul>
<p>使用线程池中线程对象的步骤：</p>
<ol>
<li>创建线程池对象。</li>
<li>创建Runnable接口子类对象。(task)</li>
<li>提交Runnable接口子类对象。(take task)</li>
<li>关闭线程池(一般不做)。</li>
</ol>
<p>Runnable实现类代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我要一个教练&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;教练来了： &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;教我游泳,交完后，教练回到了游泳池&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程池测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程池对象</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>);<span class="comment">//包含2个线程对象</span></span><br><span class="line">        <span class="comment">// 创建Runnable实例对象</span></span><br><span class="line">        MyRunnable r = <span class="keyword">new</span> MyRunnable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自己创建线程对象的方式</span></span><br><span class="line">        <span class="comment">// Thread t = new Thread(r);</span></span><br><span class="line">        <span class="comment">// t.start(); ---&gt; 调用MyRunnable中的run()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从线程池中获取线程对象,然后调用MyRunnable中的run()</span></span><br><span class="line">        service.submit(r);</span><br><span class="line">        <span class="comment">// 再获取个线程对象，调用MyRunnable中的run()</span></span><br><span class="line">        service.submit(r);</span><br><span class="line">        service.submit(r);</span><br><span class="line">        <span class="comment">// 注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。</span></span><br><span class="line">        <span class="comment">// 将使用完的线程又归还到了线程池中</span></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        <span class="comment">//service.shutdown();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="第三章、Lambda表达式"><a href="#第三章、Lambda表达式" class="headerlink" title="第三章、Lambda表达式"></a>第三章、Lambda表达式</h1><h2 id="3-1-函数式编程思想概述"><a href="#3-1-函数式编程思想概述" class="headerlink" title="3.1 函数式编程思想概述"></a>3.1 函数式编程思想概述</h2><p>在数学中，<strong>函数</strong>就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——<strong>强调做什么，而不是以什么形式做</strong>。</p>
<p>面向对象的思想:</p>
<p>​    做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.</p>
<p>函数式编程思想:</p>
<p>​    只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程</p>
<h2 id="3-2-冗余的Runnable代码"><a href="#3-2-冗余的Runnable代码" class="headerlink" title="3.2 冗余的Runnable代码"></a>3.2 冗余的Runnable代码</h2><h3 id="传统写法"><a href="#传统写法" class="headerlink" title="传统写法"></a>传统写法</h3><p>当需要启动一个线程去完成任务时，通常会通过<code>java.lang.Runnable</code>接口来定义任务内容，并使用<code>java.lang.Thread</code>类来启动该线程。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Runnable</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 匿名内部类</span></span><br><span class="line">		Runnable task = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">// 覆盖重写抽象方法</span></span><br><span class="line">				System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">new</span> Thread(task).start(); <span class="comment">// 启动线程</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个<code>Runnable</code>接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>对于<code>Runnable</code>的匿名内部类用法，可以分析出几点内容：</p>
<ul>
<li><code>Thread</code>类需要<code>Runnable</code>接口作为参数，其中的抽象<code>run</code>方法是用来指定线程任务内容的核心；</li>
<li>为了指定<code>run</code>的方法体，<strong>不得不</strong>需要<code>Runnable</code>接口的实现类；</li>
<li>为了省去定义一个<code>RunnableImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li>
<li>必须覆盖重写抽象<code>run</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li>
<li>而实际上，<strong>似乎只有方法体才是关键所在</strong>。</li>
</ul>
<h2 id="3-3-编程思想转换"><a href="#3-3-编程思想转换" class="headerlink" title="3.3 编程思想转换"></a>3.3 编程思想转换</h2><h3 id="做什么，而不是怎么做"><a href="#做什么，而不是怎么做" class="headerlink" title="做什么，而不是怎么做"></a>做什么，而不是怎么做</h3><p>我们真的希望创建一个匿名内部类对象吗？不。我们只是为了做这件事情而<strong>不得不</strong>创建一个对象。我们真正希望做的事情是：将<code>run</code>方法体内的代码传递给<code>Thread</code>类知晓。</p>
<p><strong>传递一段代码</strong>——这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。那，有没有更加简单的办法？如果我们将关注点从“怎么做”回归到“做什么”的本质上，就会发现只要能够更好地达到目的，过程与形式其实并不重要。</p>
<h3 id="生活举例"><a href="#生活举例" class="headerlink" title="生活举例"></a>生活举例</h3><p>当我们需要从北京到上海时，可以选择高铁、汽车、骑行或是徒步。我们的真正目的是到达上海，而如何才能到达上海的形式并不重要，所以我们一直在探索有没有比高铁更好的方式——搭乘飞机。</p>
<p>而现在这种飞机（甚至是飞船）已经诞生：2014年3月Oracle所发布的Java 8（JDK 1.8）中，加入了<strong>Lambda表达式</strong>的重量级新特性，为我们打开了新世界的大门。</p>
<h2 id="3-4-体验Lambda的更优写法"><a href="#3-4-体验Lambda的更优写法" class="headerlink" title="3.4 体验Lambda的更优写法"></a>3.4 体验Lambda的更优写法</h2><p>借助Java 8的全新语法，上述<code>Runnable</code>接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02LambdaRunnable</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(() -&gt;    System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>)   ).start(); <span class="comment">// 启动线程</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码和刚才的执行效果是完全一样的，可以在1.8或更高的编译级别下通过。从代码的语义中可以看出：我们启动了一个线程，而线程任务的内容以一种更加简洁的形式被指定。</p>
<p>不再有“不得不创建接口对象”的束缚，不再有“抽象方法覆盖重写”的负担，就是这么简单！</p>
<h2 id="3-5-回顾匿名内部类"><a href="#3-5-回顾匿名内部类" class="headerlink" title="3.5 回顾匿名内部类"></a>3.5 回顾匿名内部类</h2><p>Lambda是怎样击败面向对象的？在上例中，核心代码其实只是如下所示的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">() -&gt; System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>为了理解Lambda的语义，我们需要从传统的代码起步。</p>
<h3 id="使用实现类"><a href="#使用实现类" class="headerlink" title="使用实现类"></a>使用实现类</h3><p>要启动一个线程，需要创建一个<code>Thread</code>类的对象并调用<code>start</code>方法。而为了指定线程执行的内容，需要调用<code>Thread</code>类的构造方法：</p>
<ul>
<li><code>public Thread(Runnable target)</code></li>
</ul>
<p>为了获取<code>Runnable</code>接口的实现对象，可以为该接口定义一个实现类<code>RunnableImpl</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建该实现类的对象作为<code>Thread</code>类的构造参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03ThreadInitParam</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Runnable task = <span class="keyword">new</span> RunnableImpl();</span><br><span class="line">		<span class="keyword">new</span> Thread(task).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用匿名内部类"><a href="#使用匿名内部类" class="headerlink" title="使用匿名内部类"></a>使用匿名内部类</h3><p>这个<code>RunnableImpl</code>类只是为了实现<code>Runnable</code>接口而存在的，而且仅被使用了唯一一次，所以使用匿名内部类的语法即可省去该类的单独定义，即匿名内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04ThreadNameless</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名内部类的好处与弊端"><a href="#匿名内部类的好处与弊端" class="headerlink" title="匿名内部类的好处与弊端"></a>匿名内部类的好处与弊端</h3><p>一方面，匿名内部类可以帮我们<strong>省去实现类的定义</strong>；另一方面，匿名内部类的语法——<strong>确实太复杂了！</strong></p>
<h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>仔细分析该代码中的语义，<code>Runnable</code>接口只有一个<code>run</code>方法的定义：</p>
<ul>
<li><code>public abstract void run();</code></li>
</ul>
<p>即制定了一种做事情的方案（其实就是一个函数）：</p>
<ul>
<li><strong>无参数</strong>：不需要任何条件即可执行该方案。</li>
<li><strong>无返回值</strong>：该方案不产生任何结果。</li>
<li><strong>代码块</strong>（方法体）：该方案的具体执行步骤。</li>
</ul>
<p>同样的语义体现在<code>Lambda</code>语法中，要更加简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">() -&gt; System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>前面的一对小括号即<code>run</code>方法的参数（无），代表不需要任何条件；</li>
<li>中间的一个箭头代表将前面的参数传递给后面的代码；</li>
<li>后面的输出语句即业务逻辑代码。</li>
</ul>
<h2 id="3-6-Lambda标准格式"><a href="#3-6-Lambda标准格式" class="headerlink" title="3.6 Lambda标准格式"></a>3.6 Lambda标准格式</h2><p>Lambda省去面向对象的条条框框，格式由<strong>3个部分</strong>组成：</p>
<ul>
<li>一些参数</li>
<li>一个箭头</li>
<li>一段代码</li>
</ul>
<p>Lambda表达式的<strong>标准格式</strong>为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(参数类型 参数名称) -&gt; &#123; 代码语句 &#125;</span><br></pre></td></tr></table></figure>

<p>格式说明：</p>
<ul>
<li>小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。</li>
<li><code>-&gt;</code>是新引入的语法格式，代表指向动作。</li>
<li>大括号内的语法与传统方法体要求基本一致。</li>
</ul>
<h2 id="3-7-练习：使用Lambda标准格式（无参无返回）"><a href="#3-7-练习：使用Lambda标准格式（无参无返回）" class="headerlink" title="3.7 练习：使用Lambda标准格式（无参无返回）"></a>3.7 练习：使用Lambda标准格式（无参无返回）</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个厨子<code>Cook</code>接口，内含唯一的抽象方法<code>makeFood</code>，且无参数、无返回值。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cook</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeFood</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在下面的代码中，请使用Lambda的<strong>标准格式</strong>调用<code>invokeCook</code>方法，打印输出“吃饭啦！”字样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05InvokeCook</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO 请在此使用Lambda【标准格式】调用invokeCook方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeCook</span><span class="params">(Cook cook)</span> </span>&#123;</span><br><span class="line">        cook.makeFood();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    invokeCook(() -&gt; &#123;</span><br><span class="line">      	System.out.println(<span class="string">&quot;吃饭啦！&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：小括号代表<code>Cook</code>接口<code>makeFood</code>抽象方法的参数为空，大括号代表<code>makeFood</code>的方法体。</p>
</blockquote>
<h2 id="3-8-Lambda的参数和返回值"><a href="#3-8-Lambda的参数和返回值" class="headerlink" title="3.8 Lambda的参数和返回值"></a>3.8 Lambda的参数和返回值</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">需求:</span><br><span class="line">    使用数组存储多个Person对象</span><br><span class="line">    对数组中的Person对象使用Arrays的sort方法通过年龄进行升序排序</span><br></pre></td></tr></table></figure>

<p>下面举例演示<code>java.util.Comparator&lt;T&gt;</code>接口的使用场景代码，其中的抽象方法定义为：</p>
<ul>
<li><code>public abstract int compare(T o1, T o2);</code></li>
</ul>
<p>当需要对一个对象数组进行排序时，<code>Arrays.sort</code>方法需要一个<code>Comparator</code>接口实例来指定排序的规则。假设有一个<code>Person</code>类，含有<code>String name</code>和<code>int age</code>两个成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略构造器、toString方法与Getter Setter </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="传统写法-1"><a href="#传统写法-1" class="headerlink" title="传统写法"></a>传统写法</h3><p>如果使用传统的代码对<code>Person[]</code>数组进行排序，写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06Comparator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// 本来年龄乱序的对象数组</span></span><br><span class="line">        Person[] array = &#123;</span><br><span class="line">        	<span class="keyword">new</span> Person(<span class="string">&quot;古力娜扎&quot;</span>, <span class="number">19</span>),</span><br><span class="line">        	<span class="keyword">new</span> Person(<span class="string">&quot;迪丽热巴&quot;</span>, <span class="number">18</span>),</span><br><span class="line">       		<span class="keyword">new</span> Person(<span class="string">&quot;马尔扎哈&quot;</span>, <span class="number">20</span>) &#125;;</span><br><span class="line"></span><br><span class="line">      	<span class="comment">// 匿名内部类</span></span><br><span class="line">        Comparator&lt;Person&gt; comp = <span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Arrays.sort(array, comp); <span class="comment">// 第二个参数为排序规则，即Comparator接口实例</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person person : array) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种做法在面向对象的思想中，似乎也是“理所当然”的。其中<code>Comparator</code>接口的实例（使用了匿名内部类）代表了“按照年龄从小到大”的排序规则。</p>
<h3 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h3><p>下面我们来搞清楚上述代码真正要做什么事情。</p>
<ul>
<li>为了排序，<code>Arrays.sort</code>方法需要排序规则，即<code>Comparator</code>接口的实例，抽象方法<code>compare</code>是关键；</li>
<li>为了指定<code>compare</code>的方法体，<strong>不得不</strong>需要<code>Comparator</code>接口的实现类；</li>
<li>为了省去定义一个<code>ComparatorImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li>
<li>必须覆盖重写抽象<code>compare</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li>
<li>实际上，<strong>只有参数和方法体才是关键</strong>。</li>
</ul>
<h3 id="Lambda写法"><a href="#Lambda写法" class="headerlink" title="Lambda写法"></a>Lambda写法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo07ComparatorLambda</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person[] array = &#123;</span><br><span class="line">          	<span class="keyword">new</span> Person(<span class="string">&quot;古力娜扎&quot;</span>, <span class="number">19</span>),</span><br><span class="line">          	<span class="keyword">new</span> Person(<span class="string">&quot;迪丽热巴&quot;</span>, <span class="number">18</span>),</span><br><span class="line">          	<span class="keyword">new</span> Person(<span class="string">&quot;马尔扎哈&quot;</span>, <span class="number">20</span>) &#125;;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(array, (Person a, Person b) -&gt; &#123;</span><br><span class="line">          	<span class="keyword">return</span> a.getAge() - b.getAge();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person person : array) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-9-练习：使用Lambda标准格式（有参有返回）"><a href="#3-9-练习：使用Lambda标准格式（有参有返回）" class="headerlink" title="3.9 练习：使用Lambda标准格式（有参有返回）"></a>3.9 练习：使用Lambda标准格式（有参有返回）</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定一个计算器<code>Calculator</code>接口，内含抽象方法<code>calc</code>可以将两个int数字相加得到和值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在下面的代码中，请使用Lambda的<strong>标准格式</strong>调用<code>invokeCalc</code>方法，完成120和130的相加计算：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo08InvokeCalc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO 请在此使用Lambda【标准格式】调用invokeCalc方法来计算120+130的结果ß</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeCalc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, Calculator calculator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = calculator.calc(a, b);</span><br><span class="line">        System.out.println(<span class="string">&quot;结果是：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    invokeCalc(<span class="number">120</span>, <span class="number">130</span>, (<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; &#123;</span><br><span class="line">      	<span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：小括号代表<code>Calculator</code>接口<code>calc</code>抽象方法的参数，大括号代表<code>calc</code>的方法体。</p>
</blockquote>
<h2 id="3-10-Lambda省略格式"><a href="#3-10-Lambda省略格式" class="headerlink" title="3.10 Lambda省略格式"></a>3.10 Lambda省略格式</h2><h3 id="可推导即可省略"><a href="#可推导即可省略" class="headerlink" title="可推导即可省略"></a>可推导即可省略</h3><p>Lambda强调的是“做什么”而不是“怎么做”，所以凡是可以根据上下文推导得知的信息，都可以省略。例如上例还可以使用Lambda的省略写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  	invokeCalc(<span class="number">120</span>, <span class="number">130</span>, (a, b) -&gt; a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="省略规则"><a href="#省略规则" class="headerlink" title="省略规则"></a>省略规则</h3><p>在Lambda标准格式的基础上，使用省略写法的规则为：</p>
<ol>
<li>小括号内参数的类型可以省略；</li>
<li>如果小括号内<strong>有且仅有一个参</strong>，则小括号可以省略；</li>
<li>如果大括号内<strong>有且仅有一个语句</strong>，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。</li>
</ol>
<blockquote>
<p>备注：掌握这些省略规则后，请对应地回顾本章开头的多线程案例。</p>
</blockquote>
<h2 id="3-11-练习：使用Lambda省略格式"><a href="#3-11-练习：使用Lambda省略格式" class="headerlink" title="3.11 练习：使用Lambda省略格式"></a>3.11 练习：使用Lambda省略格式</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>仍然使用前文含有唯一<code>makeFood</code>抽象方法的厨子<code>Cook</code>接口，在下面的代码中，请使用Lambda的<strong>省略格式</strong>调用<code>invokeCook</code>方法，打印输出“吃饭啦！”字样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo09InvokeCook</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO 请在此使用Lambda【省略格式】调用invokeCook方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeCook</span><span class="params">(Cook cook)</span> </span>&#123;</span><br><span class="line">        cook.makeFood();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  	invokeCook(() -&gt; System.out.println(<span class="string">&quot;吃饭啦！&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-12-Lambda的使用前提"><a href="#3-12-Lambda的使用前提" class="headerlink" title="3.12 Lambda的使用前提"></a>3.12 Lambda的使用前提</h2><p>Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：</p>
<ol>
<li>使用Lambda必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong>。<br>无论是JDK内置的<code>Runnable</code>、<code>Comparator</code>接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。</li>
<li>使用Lambda必须具有<strong>上下文推断</strong>。<br>也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li>
</ol>
<blockquote>
<p>备注：有且仅有一个抽象方法的接口，称为“<strong>函数式接口</strong>”。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>培训学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>day19-线程-线程安全</title>
    <url>/2021/05/18/day19-%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<p><Strong><em>今日内容：线程、线程安全</em></Strong></p>
<span id="more"></span>

<h1 id="第一章、线程"><a href="#第一章、线程" class="headerlink" title="第一章、线程"></a>第一章、线程</h1><h2 id="1-1-多线程原理"><a href="#1-1-多线程原理" class="headerlink" title="1.1 多线程原理"></a>1.1 多线程原理</h2><p>昨天的时候我们已经写过一版多线程的代码，很多同学对原理不是很清楚，那么我们今天先画个多线程执行时序图<br>来体现一下多线程程序的执行流程。<br>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义线程类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 利用继承中的特点</span></span><br><span class="line"><span class="comment">    * 将线程名称传递 进行设置</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    		<span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 重写run方法</span></span><br><span class="line"><span class="comment">    * 定义线程要执行的代码</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//getName()方法 来自父亲</span></span><br><span class="line">            System.out.println(getName()+i);</span><br><span class="line">    		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这里是main线程&quot;</span>);</span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread(<span class="string">&quot;小强&quot;</span>);</span><br><span class="line">        mt.start();<span class="comment">//开启了一个新的线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        		System.out.println(<span class="string">&quot;旺财:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2021/05/18/day19-%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/2019-12-15_17-29-43.jpg" style="zoom:50%;">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用mt的对象的start方法，另外一个新的线程也启动了，这样，整个应用就在多线程下运行。通过这张图我们可以很清晰的看到多线程的执行流程，那么为什么可以完成并发执行呢？我们再来讲一讲原理。多线程执行时，到底在内存中是如何运行的呢？以上个程序为例，进行图解说明：</span><br><span class="line">多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈</span><br></pre></td></tr></table></figure>

<img src="/2021/05/18/day19-%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/2019-12-15_17-35-52.jpg" style="zoom:50%;">

<blockquote>
<p>当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了</p>
</blockquote>
<h3 id="1-2、Thread类"><a href="#1-2、Thread类" class="headerlink" title="1.2、Thread类"></a>1.2、Thread类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在上一天内容中我们已经可以完成最基本的线程开启，那么在我们完成操作过程中用到了 java.lang.Thread 类，API中该类中定义了有关线程的一些方法，具体如下：</span></span><br><span class="line">构造方法：</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> :分配一个新的线程对象。</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="title">Thread</span><span class="params">(String name)</span> :分配一个指定名字的新的线程对象。</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> :分配一个带有指定目标新的线程对象。</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target,String name)</span> :分配一个带有指定目标新的线程对象并指定名字。</span></span><br><span class="line"><span class="function">常用方法：</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> :获取当前线程名称。</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> :导致此线程开始执行</span>; Java虚拟机调用此线程的run方法。</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> :此线程要执行的任务在此处定义代码。</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">static</span> Thread <span class="title">currentThread</span><span class="params">()</span> :返回对当前正在执行的线程对象的引用。</span></span><br><span class="line"><span class="function"><span class="comment">// 翻阅API后得知创建线程的方式总共有两种，一种是继承Thread类方式，一种是实现Runnable接口方式，方式一我们上一天已经完成，接下来讲解方式二实现的方式。</span></span></span><br></pre></td></tr></table></figure>

<h3 id="1-3、线程创建方式二"><a href="#1-3、线程创建方式二" class="headerlink" title="1.3、线程创建方式二"></a>1.3、线程创建方式二</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 采用 java.lang.Runnable 也是非常常见的一种，我们只需要重写run方法即可。</span></span><br><span class="line">步骤如下：</span><br><span class="line">      <span class="number">1.</span> 定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</span><br><span class="line">      <span class="number">2.</span> 创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线							程对象。</span><br><span class="line">      <span class="number">3.</span> 调用线程对象的start()方法来启动线程</span><br><span class="line"><span class="comment">// 示例：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        		System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建自定义类对象 线程任务对象</span></span><br><span class="line">        MyRunnable mr = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(mr, <span class="string">&quot;小强&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        		System.out.println(<span class="string">&quot;旺财 &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分析：通过实现Runnable接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个执行目标。所有的多线程代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方法来运行多线程代码。实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 总结：:Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4、Thread和Runnable的区别"><a href="#1-4、Thread和Runnable的区别" class="headerlink" title="1.4、Thread和Runnable的区别"></a>1.4、Thread和Runnable的区别</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。</span></span><br><span class="line">总结：</span><br><span class="line">    实现Runnable接口比继承Thread类所具有的优势：</span><br><span class="line">    <span class="number">1.</span> 适合多个相同的程序代码的线程去共享同一个资源。</span><br><span class="line">    <span class="number">2.</span> 可以避免java中的单继承的局限性。</span><br><span class="line">    <span class="number">3.</span> 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。</span><br><span class="line">    <span class="number">4.</span> 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类</span><br><span class="line"><span class="comment">// 扩充：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。</span></span><br></pre></td></tr></table></figure>

<h3 id="1-5、匿名内部类形式创建线程"><a href="#1-5、匿名内部类形式创建线程" class="headerlink" title="1.5、匿名内部类形式创建线程"></a>1.5、匿名内部类形式创建线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 思考题：使用匿名内部类的形式创建多线程</span></span><br></pre></td></tr></table></figure>

<h2 id="第二章、线程安全"><a href="#第二章、线程安全" class="headerlink" title="第二章、线程安全"></a>第二章、线程安全</h2><h3 id="2-1、线程安全"><a href="#2-1、线程安全" class="headerlink" title="2.1、线程安全"></a>2.1、线程安全</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 演示卖票案例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 执行卖票操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每个窗口卖票的操作</span></span><br><span class="line">        <span class="comment">//窗口 永远开启</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;<span class="comment">//有票 可以卖</span></span><br><span class="line">                <span class="comment">//出票操作</span></span><br><span class="line">                <span class="comment">//使用sleep模拟一下出票时间</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                		Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto‐generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取当前线程对象的名字</span></span><br><span class="line">                String name = Thread.currentThread().getName();</span><br><span class="line">                System.out.println(name + <span class="string">&quot;正在卖:&quot;</span> + ticket‐‐);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程任务对象</span></span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="comment">//创建三个窗口对象</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(ticket, <span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(ticket, <span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(ticket, <span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line">        <span class="comment">//同时卖票</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分析结果---线程安全问题：多个线程同时写同一资源，所引发的数据错误就是线程安全问题</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2、线程同步"><a href="#2-2、线程同步" class="headerlink" title="2.2、线程同步"></a>2.2、线程同步</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。要解决上述多线程并发访问一个资源的安全性问题:也就是解决重复票与不存在票问题，Java中提供了同步机制(synchronized)来解决。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分析：</span></span><br><span class="line">  	窗口<span class="number">1</span>线程进入操作的时候，窗口<span class="number">2</span>和窗口<span class="number">3</span>线程只能在外等着，窗口<span class="number">1</span>操作结束，窗口<span class="number">1</span>和窗口<span class="number">2</span>和窗口<span class="number">3</span>才有机会进入代码</span><br><span class="line">去执行。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU</span><br><span class="line">资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 为了保证每个线程都能正常执行原子操作,Java引入了线程同步机制。那么怎么去使用呢？有三种方式完成同步操作：</span></span><br><span class="line">    <span class="number">1.</span> 同步代码块。</span><br><span class="line">    <span class="number">2.</span> 同步方法。</span><br><span class="line">    <span class="number">3.</span> 锁机制。</span><br></pre></td></tr></table></figure>

<h3 id="2-3、同步代码块"><a href="#2-3、同步代码块" class="headerlink" title="2.3、同步代码块"></a>2.3、同步代码块</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">同步代码块: <span class="keyword">synchronized</span> 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问</span><br><span class="line"><span class="comment">// 格式</span></span><br><span class="line">  <span class="keyword">synchronized</span>(同步锁)&#123;</span><br><span class="line">			需要同步操作的代码</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 同步锁：对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁</span></span><br><span class="line">    <span class="number">1.</span> 锁对象 可以是任意类型。</span><br><span class="line">    <span class="number">2.</span> 多个线程对象 要使用同一把锁。</span><br><span class="line">    ⚠️注意：在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着</span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 执行卖票操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每个窗口卖票的操作</span></span><br><span class="line">        <span class="comment">//窗口 永远开启</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">// 添加同步锁，防止多个线程同时操作</span></span><br><span class="line">                <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;<span class="comment">//有票 可以卖</span></span><br><span class="line">                    <span class="comment">//出票操作</span></span><br><span class="line">                    <span class="comment">//使用sleep模拟一下出票时间</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                    		Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto‐generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//获取当前线程对象的名字</span></span><br><span class="line">                    String name = Thread.currentThread().getName();</span><br><span class="line">                    System.out.println(name+<span class="string">&quot;正在卖:&quot;</span>+ticket‐‐);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4、同步方法"><a href="#2-4、同步方法" class="headerlink" title="2.4、同步方法"></a>2.4、同步方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">同步方法:使用 <span class="keyword">synchronized</span> 修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着</span><br><span class="line"><span class="comment">// 格式</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        可能会产生线程安全问题的代码</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 同步锁</span></span><br><span class="line">    <span class="number">1.</span>对于非<span class="keyword">static</span>方法,同步锁就是<span class="keyword">this</span>。</span><br><span class="line">    <span class="number">2.</span>对于<span class="keyword">static</span>方法,我们使用当前方法所在类的字节码对象(类名.class)。</span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每个窗口卖票的操作</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        		sellTicket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 锁对象 是 谁调用这个方法 就是谁</span></span><br><span class="line"><span class="comment">    * 隐含 锁对象 就是 this</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;<span class="comment">//有票 可以卖</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            		Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取当前线程对象的名字</span></span><br><span class="line">            String name = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(name+<span class="string">&quot;正在卖:&quot;</span>+ticket‐‐);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5、Lock锁"><a href="#2-5、Lock锁" class="headerlink" title="2.5、Lock锁"></a>2.5、Lock锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.Lock 机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。</span></span><br><span class="line"><span class="comment">// Lock锁也称同步锁，加锁与释放锁方法化了，如下：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> :加同步锁。</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> :释放同步锁。	</span></span><br><span class="line"><span class="function"><span class="comment">// 示例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class Ticket implements Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">  	<span class="comment">// 创建锁对象</span></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            lock.lock(); <span class="comment">// 加锁</span></span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                		Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                		e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取当前线程对象的名字</span></span><br><span class="line">                String name = Thread.currentThread().getName();</span><br><span class="line">                System.out.println(name+<span class="string">&quot;正在卖:&quot;</span>+ticket‐‐);</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();<span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第三章、线程生命周期"><a href="#第三章、线程生命周期" class="headerlink" title="第三章、线程生命周期"></a>第三章、线程生命周期</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 画图：生命周期</span></span><br><span class="line"><span class="comment">// sleep方法</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
        <category>培训学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>day18-多线程入门</title>
    <url>/2021/05/18/day18-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p><strong><em>今日内容：多线程入门</em></strong></p>
<span id="more"></span>

<h1 id="第四章、多线程"><a href="#第四章、多线程" class="headerlink" title="第四章、多线程"></a>第四章、多线程</h1><p>我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？</p>
<p>要解决上述问题,咱们得使用多进程或者多线程来解决.</p>
<h2 id="4-1-并发与并行"><a href="#4-1-并发与并行" class="headerlink" title="4.1 并发与并行"></a>4.1 并发与并行</h2><ul>
<li><strong>并发</strong>：指两个或多个事件在<strong>同一个时间段内</strong>发生。</li>
<li><strong>并行</strong>：指两个或多个事件在<strong>同一时刻</strong>发生（同时发生）。</li>
</ul>
<p><img src="/2021/05/18/day18-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91.bmp"></p>
<p>在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。</p>
<p>而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核 越多，并行处理的程序越多，能大大的提高电脑运行的效率。</p>
<blockquote>
<p>注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。</p>
</blockquote>
<h2 id="4-2-线程与进程"><a href="#4-2-线程与进程" class="headerlink" title="4.2 线程与进程"></a>4.2 线程与进程</h2><ul>
<li><p><strong>进程</strong>：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</p>
</li>
<li><p><strong>线程</strong>：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有2个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 </p>
<p>简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 </p>
</li>
</ul>
<p>我们可以再电脑底部任务栏，右键—–&gt;打开任务管理器,可以查看当前任务的进程：</p>
<p><strong>线程调度:</strong></p>
<ul>
<li><p>分时调度</p>
<p>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</p>
</li>
<li><p>抢占式调度</p>
<p>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。</p>
<ul>
<li>设置线程的优先级</li>
</ul>
<p><img src="/2021/05/18/day18-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8/%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7.bmp" alt="设置线程优先级"></p>
<ul>
<li><p>抢占式调度详解</p>
<p>大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。</p>
<p>实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。<br>其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。</p>
<p><img src="/2021/05/18/day18-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8/%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6.bmp" alt="抢占式调度"></p>
</li>
</ul>
</li>
</ul>
<h2 id="4-3-创建线程类"><a href="#4-3-创建线程类" class="headerlink" title="4.3 创建线程类"></a>4.3 创建线程类</h2><p>Java使用<code>java.lang.Thread</code>类代表<strong>线程</strong>，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p>
<ol>
<li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</li>
<li>创建Thread子类的实例，即创建了线程对象</li>
<li>调用线程对象的start()方法来启动该线程</li>
</ol>
<p>代码如下：</p>
<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建自定义线程对象</span></span><br><span class="line">		MyThread mt = <span class="keyword">new</span> MyThread(<span class="string">&quot;新的线程！&quot;</span>);</span><br><span class="line">		<span class="comment">//开启新线程</span></span><br><span class="line">		mt.start();</span><br><span class="line">		<span class="comment">//在主方法中执行for循环</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;main线程！&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义指定线程名称的构造方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//调用父类的String参数的构造方法，指定线程的名称</span></span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 重写run方法，完成该线程执行的逻辑</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(getName()+<span class="string">&quot;：正在执行！&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>培训学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>day17-异常</title>
    <url>/2021/05/13/day17-%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p><strong><em>今日内容：异常</em></strong></p>
<span id="more"></span>

<h1 id="第一章、异常"><a href="#第一章、异常" class="headerlink" title="第一章、异常"></a>第一章、异常</h1><h2 id="1-1-异常概念"><a href="#1-1-异常概念" class="headerlink" title="1.1 异常概念"></a>1.1 异常概念</h2><p>异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是：</p>
<ul>
<li><font style="color:red"><strong>异常</strong> ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。</font></li>
</ul>
<p>在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。</p>
<blockquote>
<p>异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.</p>
</blockquote>
<h2 id="1-2-异常体系"><a href="#1-2-异常体系" class="headerlink" title="1.2 异常体系"></a>1.2 异常体系</h2><p>异常机制其实是帮助我们<strong>找到</strong>程序中的问题，异常的根类是<code>java.lang.Throwable</code>，其下有两个子类：<code>java.lang.Error</code>与<code>java.lang.Exception</code>，平常所说的异常指<code>java.lang.Exception</code>。</p>
<p><img src="/2021/05/13/day17-%E5%BC%82%E5%B8%B8/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.png"></p>
<p><strong>Throwable体系：</strong></p>
<ul>
<li><strong>Error</strong>:系统错误，程序无法处理，只能事先避免。</li>
<li><strong>Exception</strong>:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。</li>
</ul>
<p><strong>Throwable中的常用方法：</strong></p>
<ul>
<li><p><code>public void printStackTrace()</code>:打印异常的详细信息。</p>
<p><em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p>
</li>
<li><p><code>public String getMessage()</code>:获取发生异常的原因。</p>
<p><em>提示给用户的时候,就提示错误原因。</em></p>
</li>
<li><p><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</p>
</li>
</ul>
<p><em><strong>出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。</strong></em></p>
<p><img src="/2021/05/13/day17-%E5%BC%82%E5%B8%B8/%E7%AE%80%E5%8D%95%E7%9A%84%E5%BC%82%E5%B8%B8%E6%9F%A5%E7%9C%8B.bmp"></p>
<h2 id="1-3-异常分类"><a href="#1-3-异常分类" class="headerlink" title="1.3 异常分类"></a>1.3 异常分类</h2><p>我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。</p>
<p><strong>异常(Exception)的分类</strong>:根据在编译时期还是运行时期去检查异常?</p>
<ul>
<li><strong>编译时期异常</strong>:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)</li>
<li>** 运行时期异常**:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)</li>
</ul>
<p>​    <img src="/2021/05/13/day17-%E5%BC%82%E5%B8%B8/%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB.png"></p>
<h2 id="1-4-异常的产生过程解析"><a href="#1-4-异常的产生过程解析" class="headerlink" title="1.4     异常的产生过程解析"></a>1.4     异常的产生过程解析</h2><p>先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。</p>
<p> 工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTools</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对给定的数组通过给定的角标获取元素。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> element = arr[index];</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123; <span class="number">34</span>, <span class="number">12</span>, <span class="number">67</span> &#125;;</span><br><span class="line">        intnum = ArrayTools.getElement(arr, <span class="number">4</span>)</span><br><span class="line">        System.out.println(<span class="string">&quot;num=&quot;</span> + num);</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序执行过程图解：</p>
<p> <img src="/2021/05/13/day17-%E5%BC%82%E5%B8%B8/%E5%BC%82%E5%B8%B8%E4%BA%A7%E7%94%9F%E8%BF%87%E7%A8%8B.png"></p>
<h1 id="第二章、异常的处理"><a href="#第二章、异常的处理" class="headerlink" title="第二章、异常的处理"></a>第二章、异常的处理</h1><p>Java异常处理的五个关键字：<strong>try、catch、finally、throw、throws</strong></p>
<h2 id="2-1-抛出异常throw"><a href="#2-1-抛出异常throw" class="headerlink" title="2.1     抛出异常throw"></a>2.1     抛出异常throw</h2><p>在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。</p>
<p>在java中，提供了一个<strong>throw</strong>关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？</p>
<ol>
<li><p>创建一个异常对象。封装一些提示信息(信息可以自己编写)。</p>
</li>
<li><p>需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。</p>
<p>throw<strong>用在方法内</strong>，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</p>
</li>
</ol>
<p><strong>使用格式：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">throw new 异常类名(参数);</span><br></pre></td></tr></table></figure>

<p> 例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;要访问的arr数组不存在&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">&quot;该索引在数组中不存在，已超出范围&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个数组 </span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">52</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="comment">//根据索引找对应的元素 </span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> element = getElement(arr, index);</span><br><span class="line"></span><br><span class="line">        System.out.println(element);</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 根据 索引找到数组中对应的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index)</span></span>&#123; </span><br><span class="line">       	<span class="comment">//判断  索引是否越界</span></span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">             判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。</span></span><br><span class="line"><span class="comment">             这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 </span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">&quot;哥们，角标越界了~~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> element = arr[index];</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。</p>
<p>那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。</p>
</blockquote>
<h2 id="2-2-Objects非空判断"><a href="#2-2-Objects非空判断" class="headerlink" title="2.2 Objects非空判断"></a>2.2 Objects非空判断</h2><p>还记得我们学习过一个类Objects吗，曾经提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。</p>
<ul>
<li><code>public static &lt;T&gt; T requireNonNull(T obj)</code>:查看指定引用对象不是null。</li>
</ul>
<p>查看源码发现这里对为null的进行了抛出异常操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">requireNonNull</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">      	<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-声明异常throws"><a href="#2-3-声明异常throws" class="headerlink" title="2.3  声明异常throws"></a>2.3  声明异常throws</h2><p><strong>声明异常</strong>：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。</p>
<p>关键字<strong>throws</strong>运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).</p>
<p><strong>声明异常格式：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123;   &#125;	</span><br></pre></td></tr></table></figure>

<p>声明异常的代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        read(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String path)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">&quot;a.txt&quot;</span>)) &#123;<span class="comment">//如果不是 a.txt这个文件 </span></span><br><span class="line">            <span class="comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowsDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        read(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String path)</span><span class="keyword">throws</span> FileNotFoundException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">&quot;a.txt&quot;</span>)) &#123;<span class="comment">//如果不是 a.txt这个文件 </span></span><br><span class="line">            <span class="comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">&quot;b.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-捕获异常try…catch"><a href="#2-4-捕获异常try…catch" class="headerlink" title="2.4  捕获异常try…catch"></a>2.4  捕获异常try…catch</h2><p>如果异常出现的话,会立刻终止程序,所以我们得处理异常:</p>
<ol>
<li>该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。</li>
<li>在方法中使用try-catch的语句块来处理异常。</li>
</ol>
<p><strong>try-catch</strong>的方式就是捕获异常。</p>
<ul>
<li><strong>捕获异常</strong>：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。</li>
</ul>
<p>捕获异常语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">     编写可能会出现异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  e)&#123;</span><br><span class="line">     处理异常的代码</span><br><span class="line">     <span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>try：</strong>该代码块中编写可能产生异常的代码。</p>
<p><strong>catch：</strong>用来进行某种异常的捕获，实现对捕获到的异常进行处理。</p>
<blockquote>
<p>注意:try和catch都不能单独使用,必须连用。</p>
</blockquote>
<p>演示如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryCatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">// 当产生异常时，必须有处理方式。要么捕获，要么声明。</span></span><br><span class="line">            read(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;<span class="comment">// 括号中需要定义什么呢？</span></span><br><span class="line">          	<span class="comment">//try中抛出的是什么异常，在括号中就定义什么异常类型</span></span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 我们 当前的这个方法中 有异常  有编译期异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String path)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">&quot;a.txt&quot;</span>)) &#123;<span class="comment">//如果不是 a.txt这个文件 </span></span><br><span class="line">            <span class="comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何获取异常信息：</p>
<p>Throwable类中定义了一些查看方法:</p>
<ul>
<li><code>public String getMessage()</code>:获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。</li>
</ul>
<ul>
<li><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</li>
<li><code>public void printStackTrace()</code>:打印异常的跟踪栈信息并输出到控制台。</li>
</ul>
<p>​            <em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p>
<h2 id="2-4-finally-代码块"><a href="#2-4-finally-代码块" class="headerlink" title="2.4 finally 代码块"></a>2.4 finally 代码块</h2><p><strong>finally</strong>：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。</p>
<p>什么时候的代码必须最终执行？</p>
<p>当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。</p>
<p>finally的语法:</p>
<p> try…catch….finally:自身需要处理异常,最终还得关闭资源。</p>
<blockquote>
<p>注意:finally不能单独使用。</p>
</blockquote>
<p>比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。</p>
<p>finally代码参考如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryCatchDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            read(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">//抓取到的是编译期异常  抛出去的是运行期 </span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不管程序怎样，这里都将会被执行。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 我们 当前的这个方法中 有异常  有编译期异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String path)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">&quot;a.txt&quot;</span>)) &#123;<span class="comment">//如果不是 a.txt这个文件 </span></span><br><span class="line">            <span class="comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。</p>
</blockquote>
<h2 id="2-5-异常注意事项"><a href="#2-5-异常注意事项" class="headerlink" title="2.5   异常注意事项"></a>2.5   异常注意事项</h2><ul>
<li><p>多个异常使用捕获又该如何处理呢？</p>
<ol>
<li>多个异常分别处理。</li>
<li>多个异常一次捕获，多次处理。</li>
<li>多个异常一次捕获一次处理。</li>
</ol>
<p>一般我们是使用一次捕获多次处理方式，格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">     编写可能会出现异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型A  e)&#123;  当<span class="keyword">try</span>中出现A类型异常,就用该<span class="keyword">catch</span>来捕获.</span><br><span class="line">     处理异常的代码</span><br><span class="line">     <span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型B  e)&#123;  当<span class="keyword">try</span>中出现B类型异常,就用该<span class="keyword">catch</span>来捕获.</span><br><span class="line">     处理异常的代码</span><br><span class="line">     <span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。</p>
</blockquote>
</li>
<li><p>运行时异常被抛出可以不处理。即不捕获也不声明抛出。</p>
</li>
<li><p>如果finally有return语句,永远返回finally中的结果,避免该情况. </p>
</li>
<li><p>如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。</p>
</li>
<li><p>父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出</p>
</li>
</ul>
<h1 id="第三章、自定义异常"><a href="#第三章、自定义异常" class="headerlink" title="第三章、自定义异常"></a>第三章、自定义异常</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p><strong>为什么需要自定义异常类:</strong></p>
<p>我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题,考试成绩负数问题等等。</p>
<p>在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？</p>
<p><strong>什么是自定义异常类:</strong></p>
<p>在开发中根据自己业务的异常情况来定义异常类.</p>
<p>自定义一个业务逻辑异常: <strong>RegisterException</strong>。一个注册异常类。</p>
<p><strong>异常类如何定义:</strong></p>
<ol>
<li>自定义一个编译期异常: 自定义类 并继承于<code>java.lang.Exception</code>。</li>
<li>自定义一个运行时期的异常类:自定义类 并继承于<code>java.lang.RuntimeException</code>。</li>
</ol>
<h2 id="3-2-自定义异常的练习"><a href="#3-2-自定义异常的练习" class="headerlink" title="3.2 自定义异常的练习"></a>3.2 自定义异常的练习</h2><p>要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。</p>
<p>首先定义一个登陆异常类RegisterException：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 业务逻辑异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空参构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegisterException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 表示异常提示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegisterException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟数据库中已存在账号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] names = &#123;<span class="string">&quot;bill&quot;</span>,<span class="string">&quot;hill&quot;</span>,<span class="string">&quot;jill&quot;</span>&#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     </span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">              <span class="comment">// 可能出现异常的代码</span></span><br><span class="line">            checkUsername(<span class="string">&quot;nill&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;注册成功&quot;</span>);<span class="comment">//如果没有异常就是注册成功</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(RegisterException e)&#123;</span><br><span class="line">            <span class="comment">//处理异常</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前注册账号是否存在</span></span><br><span class="line">    <span class="comment">//因为是编译期异常，又想调用者去处理 所以声明该异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkUsername</span><span class="params">(String uname)</span> <span class="keyword">throws</span> RegisterException</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            <span class="keyword">if</span>(name.equals(uname))&#123;<span class="comment">//如果名字在这里面 就抛出登陆异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RegisterException(<span class="string">&quot;亲&quot;</span>+name+<span class="string">&quot;已经被注册了！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      <categories>
        <category>Java</category>
        <category>培训学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>day016-Map</title>
    <url>/2021/05/10/day016-Map/</url>
    <content><![CDATA[<p><strong><em>今日内容：Map集合。</em></strong></p>
<span id="more"></span>

<h1 id="第一章、Map集合"><a href="#第一章、Map集合" class="headerlink" title="第一章、Map集合"></a>第一章、Map集合</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即<code>java.util.Map</code>接口。</p>
<p>我们通过查看<code>Map</code>接口描述，发现<code>Map</code>接口下的集合与<code>Collection</code>接口下的集合，它们存储数据的形式不同，如下图。</p>
<p><img src="/2021/05/10/day016-Map/Collection%E4%B8%8EMap.bmp"></p>
<ul>
<li><code>Collection</code>中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。</li>
<li><code>Map</code>中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。</li>
<li><code>Collection</code>中的集合称为单列集合，<code>Map</code>中的集合称为双列集合。</li>
<li>需要注意的是，<code>Map</code>中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</li>
</ul>
<h2 id="1-2-Map常用子类"><a href="#1-2-Map常用子类" class="headerlink" title="1.2  Map常用子类"></a>1.2  Map常用子类</h2><p>通过查看Map接口描述，看到Map有多个子类，这里我们主要讲解常用的HashMap集合、LinkedHashMap集合。</p>
<ul>
<li>**HashMap&lt;K,V&gt;**：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li>
<li>**LinkedHashMap&lt;K,V&gt;**：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li>
</ul>
<blockquote>
<p>tips：Map接口中的集合都有两个泛型变量&lt;K,V&gt;,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。</p>
</blockquote>
<h2 id="1-3-Map接口中的常用方法"><a href="#1-3-Map接口中的常用方法" class="headerlink" title="1.3  Map接口中的常用方法"></a>1.3  Map接口中的常用方法</h2><p>Map接口中定义了很多方法，常用的如下：</p>
<ul>
<li><code>public V put(K key, V value)</code>:  把指定的键与指定的值添加到Map集合中。</li>
<li><code>public V remove(Object key)</code>: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</li>
<li><code>public V get(Object key)</code> 根据指定的键，在Map集合中获取对应的值。</li>
<li><code>boolean containsKey(Object key)  </code> 判断集合中是否包含指定的键。</li>
<li><code>public Set&lt;K&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。</li>
<li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li>
</ul>
<p>Map接口的方法演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建 map对象</span></span><br><span class="line">        HashMap&lt;String, String&gt;  map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素到集合</span></span><br><span class="line">        map.put(<span class="string">&quot;黄晓明&quot;</span>, <span class="string">&quot;杨颖&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;文章&quot;</span>, <span class="string">&quot;马伊琍&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;邓超&quot;</span>, <span class="string">&quot;孙俪&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//String remove(String key)</span></span><br><span class="line">        System.out.println(map.remove(<span class="string">&quot;邓超&quot;</span>));</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 想要查看 黄晓明的媳妇 是谁</span></span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;黄晓明&quot;</span>));</span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;邓超&quot;</span>));    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:</p>
<p>使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； </p>
<p>若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 </p>
</blockquote>
<h2 id="1-4-Map集合遍历键找值方式"><a href="#1-4-Map集合遍历键找值方式" class="headerlink" title="1.4   Map集合遍历键找值方式"></a>1.4   Map集合遍历键找值方式</h2><p>键找值方式：即通过元素中的键，获取键所对应的值</p>
<p>分析步骤：</p>
<ol>
<li>获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:<code>keyset()</code></li>
<li>遍历键的Set集合，得到每一个键。</li>
<li>根据键，获取键所对应的值。方法提示:<code>get(K key)</code></li>
</ol>
<p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Map集合对象 </span></span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">        <span class="comment">//添加元素到集合 </span></span><br><span class="line">        map.put(<span class="string">&quot;胡歌&quot;</span>, <span class="string">&quot;霍建华&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;郭德纲&quot;</span>, <span class="string">&quot;于谦&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;薛之谦&quot;</span>, <span class="string">&quot;大张伟&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有的键  获取键集</span></span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        <span class="comment">// 遍历键集 得到 每一个键</span></span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">          	<span class="comment">//key  就是键</span></span><br><span class="line">            <span class="comment">//获取对应值</span></span><br><span class="line">            String value = map.get(key);</span><br><span class="line">            System.out.println(key+<span class="string">&quot;的CP是：&quot;</span>+value);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历图解：</p>
<p><img src="/2021/05/10/day016-Map/Map%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E4%B8%80.bmp"></p>
<h2 id="1-5-Entry键值对对象"><a href="#1-5-Entry键值对对象" class="headerlink" title="1.5  Entry键值对对象"></a>1.5  Entry键值对对象</h2><p>我们已经知道，<code>Map</code>中存放的是两种对象，一种称为<strong>key</strong>(键)，一种称为<strong>value</strong>(值)，它们在在<code>Map</code>中是一一对应关系，这一对对象又称做<code>Map</code>中的一个<code>Entry(项)</code>。<code>Entry</code>将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历<code>Map</code>集合时，就可以从每一个键值对（<code>Entry</code>）对象中获取对应的键与对应的值。</p>
<p> 既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法：</p>
<ul>
<li><code>public K getKey()</code>：获取Entry对象中的键。</li>
<li><code>public V getValue()</code>：获取Entry对象中的值。</li>
</ul>
<p>在Map集合中也提供了获取所有Entry对象的方法：</p>
<ul>
<li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li>
</ul>
<h2 id="1-6-Map集合遍历键值对方式"><a href="#1-6-Map集合遍历键值对方式" class="headerlink" title="1.6 Map集合遍历键值对方式"></a>1.6 Map集合遍历键值对方式</h2><p>键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。</p>
<p>操作步骤与图解：</p>
<ol>
<li><p> 获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:<code>entrySet()</code>。</p>
</li>
<li><p> 遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。</p>
</li>
<li><p> 通过键值对(Entry)对象，获取Entry对象中的键与值。  方法提示:<code>getkey() getValue()</code>     </p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Map集合对象 </span></span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">        <span class="comment">// 添加元素到集合 </span></span><br><span class="line">        map.put(<span class="string">&quot;胡歌&quot;</span>, <span class="string">&quot;霍建华&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;郭德纲&quot;</span>, <span class="string">&quot;于谦&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;薛之谦&quot;</span>, <span class="string">&quot;大张伟&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 所有的 entry对象  entrySet</span></span><br><span class="line">        Set&lt;Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历得到每一个entry对象</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : entrySet) &#123;</span><br><span class="line">           	<span class="comment">// 解析 </span></span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            String value = entry.getValue();  </span><br><span class="line">            System.out.println(key+<span class="string">&quot;的CP是:&quot;</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历图解：</p>
<p><img src="/2021/05/10/day016-Map/Map%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E4%BA%8C.bmp"></p>
<blockquote>
<p>tips：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。</p>
</blockquote>
<h2 id="1-7-HashMap存储自定义类型键值"><a href="#1-7-HashMap存储自定义类型键值" class="headerlink" title="1.7  HashMap存储自定义类型键值"></a>1.7  HashMap存储自定义类型键值</h2><p>练习：每位学生（姓名，年龄）都有自己的家庭住址。那么，既然有对应关系，则将学生对象和家庭住址存储到map集合中。学生作为键, 家庭住址作为值。</p>
<blockquote>
<p>注意，学生姓名相同并且年龄相同视为同一名学生。</p>
</blockquote>
<p>编写学生类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Student student = (Student) o;</span><br><span class="line">        <span class="keyword">return</span> age == student.age &amp;&amp; Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1,创建Hashmap集合对象。</span></span><br><span class="line">        Map&lt;Student,String&gt; map = <span class="keyword">new</span> HashMap&lt;Student,String&gt;();</span><br><span class="line">        <span class="comment">//2,添加元素。</span></span><br><span class="line">        map.put(newStudent(<span class="string">&quot;lisi&quot;</span>,<span class="number">28</span>), <span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        map.put(newStudent(<span class="string">&quot;wangwu&quot;</span>,<span class="number">22</span>), <span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        map.put(newStudent(<span class="string">&quot;zhaoliu&quot;</span>,<span class="number">24</span>), <span class="string">&quot;成都&quot;</span>);</span><br><span class="line">        map.put(newStudent(<span class="string">&quot;zhouqi&quot;</span>,<span class="number">25</span>), <span class="string">&quot;广州&quot;</span>);</span><br><span class="line">        map.put(newStudent(<span class="string">&quot;wangwu&quot;</span>,<span class="number">22</span>), <span class="string">&quot;南京&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3,取出元素。键找值方式</span></span><br><span class="line">        Set&lt;Student&gt;keySet = map.keySet();</span><br><span class="line">        <span class="keyword">for</span>(Student key: keySet)&#123;</span><br><span class="line">            Stringvalue = map.get(key);</span><br><span class="line">            System.out.println(key.toString()+<span class="string">&quot;.....&quot;</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。</li>
<li>如果要保证map中存放的key和取出的顺序一致，可以使用<code>java.util.LinkedHashMap</code>集合来存放。</li>
</ul>
<h2 id="1-8-LinkedHashMap"><a href="#1-8-LinkedHashMap" class="headerlink" title="1.8   LinkedHashMap"></a>1.8   LinkedHashMap</h2><p>我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要速度快怎么办呢？</p>
<p>在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedHashMap&lt;String, String&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;邓超&quot;</span>, <span class="string">&quot;孙俪&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;李晨&quot;</span>, <span class="string">&quot;范冰冰&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;刘德华&quot;</span>, <span class="string">&quot;朱丽倩&quot;</span>);</span><br><span class="line">        Set&lt;Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : entrySet) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot;  &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">邓超  孙俪</span><br><span class="line">李晨  范冰冰</span><br><span class="line">刘德华  朱丽倩</span><br></pre></td></tr></table></figure>

<h2 id="1-9-Map集合练习"><a href="#1-9-Map集合练习" class="headerlink" title="1.9 Map集合练习"></a>1.9 Map集合练习</h2><p><strong>需求：</strong></p>
<p>计算一个字符串中每个字符出现次数。</p>
<p><strong>分析：</strong></p>
<ol>
<li> 获取一个字符串对象</li>
<li> 创建一个Map集合，键代表字符，值代表次数。</li>
<li> 遍历字符串得到每个字符。</li>
<li> 判断Map中是否有该键。</li>
<li> 如果没有，第一次出现，存储次数为1；如果有，则说明已经出现过，获取到对应的值进行++，再次存储。     </li>
<li> 打印最终结果</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//友情提示</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请录入一个字符串:&quot;</span>);</span><br><span class="line">        String line = <span class="keyword">new</span> Scanner(System.in).nextLine();</span><br><span class="line">        <span class="comment">// 定义 每个字符出现次数的方法</span></span><br><span class="line">        findChar(line);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findChar</span><span class="params">(String line)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1:创建一个集合 存储  字符 以及其出现的次数</span></span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="comment">//2:遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; line.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = line.charAt(i);</span><br><span class="line">            <span class="comment">//判断 该字符 是否在键集中</span></span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(c)) &#123;<span class="comment">//说明这个字符没有出现过</span></span><br><span class="line">                <span class="comment">//那就是第一次</span></span><br><span class="line">                map.put(c, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//先获取之前的次数</span></span><br><span class="line">                Integer count = map.get(c);</span><br><span class="line">                <span class="comment">//count++;</span></span><br><span class="line">                <span class="comment">//再次存入  更新</span></span><br><span class="line">                map.put(c, ++count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第二章、补充知识点"><a href="#第二章、补充知识点" class="headerlink" title="第二章、补充知识点"></a>第二章、补充知识点</h1><h2 id="2-1-JDK9对集合添加的优化"><a href="#2-1-JDK9对集合添加的优化" class="headerlink" title="2.1  JDK9对集合添加的优化"></a>2.1  JDK9对集合添加的优化</h2><p>通常，我们在代码中创建一个集合（例如，List 或 Set ），并直接用一些元素填充它。 实例化集合，几个 add方法 调用，使得代码重复。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;def&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;ghi&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> Java 9，添加了几种集合工厂方法,更方便创建少量元素的集合、map实例。新的List、Set、Map的静态工厂方法可以更方便地创建集合的不可变实例。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJDK9</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Set&lt;String&gt; str1=Set.of(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);  </span><br><span class="line">        <span class="comment">//str1.add(&quot;c&quot;);这里编译的时候不会错，但是执行的时候会报错，因为是不可变的集合  </span></span><br><span class="line">        System.out.println(str1);  </span><br><span class="line">        Map&lt;String,Integer&gt; str2=Map.of(<span class="string">&quot;a&quot;</span>,<span class="number">1</span>,<span class="string">&quot;b&quot;</span>,<span class="number">2</span>);  </span><br><span class="line">        System.out.println(str2);  </span><br><span class="line">        List&lt;String&gt; str3=List.of(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>);  </span><br><span class="line">        System.out.println(str3);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>需要注意以下两点：</p>
<blockquote>
<p>1:of()方法只是Map，List，Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法，比如    HashSet，ArrayList等待；</p>
<p>2:返回的集合是不可变的；</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>培训学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>day15-List-Set-Collections</title>
    <url>/2021/05/09/day15-List-Set-Collections/</url>
    <content><![CDATA[<p><strong><em>今日内容：List集合、Set接口、Collections工具类</em></strong></p>
<span id="more"></span>

<h1 id="第一章、数据结构"><a href="#第一章、数据结构" class="headerlink" title="第一章、数据结构"></a>第一章、数据结构</h1><h2 id="2-2-常见的数据结构"><a href="#2-2-常见的数据结构" class="headerlink" title="2.2 常见的数据结构"></a>2.2 常见的数据结构</h2><p>数据存储的常用结构有：栈、队列、数组、链表和红黑树。我们分别来了解一下：</p>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ul>
<li><strong>栈</strong>：<strong>stack</strong>,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。</li>
</ul>
<p>简单的说：采用该结构的集合，对元素的存取有如下的<font style="color:red"><strong>特点</strong></font></p>
<ul>
<li><p><strong><font style="color:red">先进后出</font>（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。</strong></p>
</li>
<li><p><strong><font style="color:red">栈的入口、出口的都是栈的顶端位置。</font></strong></p>
<p><img src="/2021/05/09/day15-List-Set-Collections/%E5%A0%86%E6%A0%88.png"></p>
</li>
</ul>
<p>这里两个名词需要注意：</p>
<ul>
<li><strong>压栈</strong>：就是<strong style="color:red">存</strong>元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。</li>
<li><strong>弹栈</strong>：就是<strong style="color:red">取</strong>元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。</li>
</ul>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul>
<li><strong>队列</strong>：<strong>queue</strong>,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。</li>
</ul>
<p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p>
<ul>
<li><strong><strong style="color:red">先进先出</strong>（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，小火车过山洞，车头先进去，车尾后进去；车头先出来，车尾后出来。</strong></li>
<li><strong><strong style="color:red">队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。</strong></strong></li>
</ul>
<p><img src="/2021/05/09/day15-List-Set-Collections/%E9%98%9F%E5%88%97%E5%9B%BE.bmp"></p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul>
<li><strong>数组</strong>:<strong>Array</strong>,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。</li>
</ul>
<p>简单的说,采用该结构的集合，对元素的存取有如下的特点：</p>
<ul>
<li><p><strong>查找元素快：通过索引，可以快速访问指定位置的元素</strong></p>
<p><img src="/2021/05/09/day15-List-Set-Collections/%E6%95%B0%E7%BB%84%E6%9F%A5%E8%AF%A2%E5%BF%AB.png"></p>
</li>
<li><p><strong>增删元素慢</strong></p>
<ul>
<li><strong>指定索引位置增加元素</strong>：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。如下图<img src="/2021/05/09/day15-List-Set-Collections/%E6%95%B0%E7%BB%84%E6%B7%BB%E5%8A%A0.png"></li>
<li><strong>指定索引位置删除元素：</strong>需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图<img src="/2021/05/09/day15-List-Set-Collections/%E6%95%B0%E7%BB%84%E5%88%A0%E9%99%A4.png"></li>
</ul>
</li>
</ul>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><ul>
<li><p><strong>链表</strong>:<strong>linked list</strong>,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有单向链表与双向链表，那么这里给大家介绍的是<strong>单向链表</strong>。</p>
<p><img src="/2021/05/09/day15-List-Set-Collections/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E7%89%B9%E7%82%B9.png"></p>
</li>
</ul>
<p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p>
<ul>
<li><p><strong>多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。</strong></p>
<p><img src="/2021/05/09/day15-List-Set-Collections/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84.png"></p>
</li>
<li><p><strong>查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素</strong></p>
</li>
<li><p><strong>增删元素快：</strong></p>
<ul>
<li><p>增加元素：只需要修改连接下个元素的地址即可。</p>
<p><img src="/2021/05/09/day15-List-Set-Collections/%E5%A2%9E%E5%8A%A0%E7%BB%93%E7%82%B9.png"></p>
</li>
<li><p>删除元素：只需要修改连接下个元素的地址即可。</p>
<p><img src="/2021/05/09/day15-List-Set-Collections/%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9.bmp"></p>
</li>
</ul>
</li>
</ul>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><ul>
<li><strong>二叉树</strong>：<strong>binary tree</strong> ,是每个结点不超过2的有序<strong>树（tree）</strong> 。</li>
</ul>
<p>简单的理解，就是一种类似于我们生活中树的结构，只不过每个结点上都最多只能有两个子结点。</p>
<p>二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。</p>
<p>如图：</p>
<p><img src="/2021/05/09/day15-List-Set-Collections/%E4%BA%8C%E5%8F%89%E6%A0%91.jpg"></p>
<p>我们要说的是二叉树的一种比较有意思的叫做<strong>红黑树</strong>，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。</p>
<p>​    <strong><strong style="color:red">速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍</strong></strong></p>
<h1 id="第二章、List集合"><a href="#第二章、List集合" class="headerlink" title="第二章、List集合"></a>第二章、List集合</h1><h2 id="1-1-List接口介绍"><a href="#1-1-List接口介绍" class="headerlink" title="1.1 List接口介绍"></a>1.1 List接口介绍</h2><p><code>java.util.List</code>接口继承自<code>Collection</code>接口，是单列集合的一个重要分支，习惯性地会将实现了<code>List</code>接口的对象称为List集合。**<strong style="color:red">在List集合中允许出现重复的元素</strong>**，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，<strong style="color:red">List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。</strong></p>
<p>看完API，我们总结一下：</p>
<p>List接口特点：</p>
<ol>
<li>它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</li>
<li>它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li>
<li>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</li>
</ol>
<blockquote>
<p>tips:我们学习过List接口的子类java.util.ArrayList类，该类中的方法都是来自List中定义。</p>
</blockquote>
<h2 id="1-2-List接口中常用方法"><a href="#1-2-List接口中常用方法" class="headerlink" title="1.2 List接口中常用方法"></a>1.2 List接口中常用方法</h2><p>List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下：</p>
<ul>
<li><code>public void add(int index, E element)</code>: 将指定的元素，添加到该集合中的指定位置上。</li>
<li><code>public E get(int index)</code>:返回集合中指定位置的元素。</li>
<li><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</li>
<li><code>public E set(int index, E element)</code>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</li>
</ul>
<p>List集合特有的方法都是跟索引相关，我们都学习过，那么我们再来复习一遍吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建List集合对象</span></span><br><span class="line">    	List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 往 尾部添加 指定元素</span></span><br><span class="line">    	list.add(<span class="string">&quot;图图&quot;</span>);</span><br><span class="line">    	list.add(<span class="string">&quot;小美&quot;</span>);</span><br><span class="line">    	list.add(<span class="string">&quot;不高兴&quot;</span>);</span><br><span class="line">    	</span><br><span class="line">    	System.out.println(list);</span><br><span class="line">    	<span class="comment">// add(int index,String s) 往指定位置添加</span></span><br><span class="line">    	list.add(<span class="number">1</span>,<span class="string">&quot;没头脑&quot;</span>);</span><br><span class="line">    	</span><br><span class="line">    	System.out.println(list);</span><br><span class="line">    	<span class="comment">// String remove(int index) 删除指定位置元素  返回被删除元素</span></span><br><span class="line">    	<span class="comment">// 删除索引位置为2的元素 </span></span><br><span class="line">    	System.out.println(<span class="string">&quot;删除索引位置为2的元素&quot;</span>);</span><br><span class="line">    	System.out.println(list.remove(<span class="number">2</span>));</span><br><span class="line">    	</span><br><span class="line">    	System.out.println(list);</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// String set(int index,String s)</span></span><br><span class="line">    	<span class="comment">// 在指定位置 进行 元素替代（改） </span></span><br><span class="line">    	<span class="comment">// 修改指定位置元素</span></span><br><span class="line">    	list.set(<span class="number">0</span>, <span class="string">&quot;三毛&quot;</span>);</span><br><span class="line">    	System.out.println(list);</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// String get(int index)  获取指定位置元素</span></span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 跟size() 方法一起用  来 遍历的 </span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">    		System.out.println(list.get(i));</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">//还可以使用增强for</span></span><br><span class="line">    	<span class="keyword">for</span> (String string : list) &#123;</span><br><span class="line">			System.out.println(string);</span><br><span class="line">		&#125;  	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第三章、List的子类"><a href="#第三章、List的子类" class="headerlink" title="第三章、List的子类"></a>第三章、List的子类</h1><h2 id="3-1-ArrayList集合"><a href="#3-1-ArrayList集合" class="headerlink" title="3.1 ArrayList集合"></a>3.1 ArrayList集合</h2><p><code>java.util.ArrayList</code>集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以<code>ArrayList</code>是最常用的集合。</p>
<p>许多程序员开发时非常随意地使用ArrayList完成任何需求，并不严谨，这种用法是不提倡的。</p>
<h2 id="3-2-LinkedList集合"><a href="#3-2-LinkedList集合" class="headerlink" title="3.2 LinkedList集合"></a>3.2 LinkedList集合</h2><p><code>java.util.LinkedList</code>集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p>
<blockquote>
<p>LinkedList是一个双向链表，那么双向链表是什么样子的呢，我们用个图了解下</p>
</blockquote>
<p><img src="/2021/05/09/day15-List-Set-Collections/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png"></p>
<p>实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可：</p>
<ul>
<li><code>public void addFirst(E e)</code>:将指定元素插入此列表的开头。</li>
<li><code>public void addLast(E e)</code>:将指定元素添加到此列表的结尾。</li>
<li><code>public E getFirst()</code>:返回此列表的第一个元素。</li>
<li><code>public E getLast()</code>:返回此列表的最后一个元素。</li>
<li><code>public E removeFirst()</code>:移除并返回此列表的第一个元素。</li>
<li><code>public E removeLast()</code>:移除并返回此列表的最后一个元素。</li>
<li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li>
<li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。</li>
<li><code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</li>
</ul>
<p>LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。（了解即可）</p>
<p>方法演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; link = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        link.addFirst(<span class="string">&quot;abc1&quot;</span>);</span><br><span class="line">        link.addFirst(<span class="string">&quot;abc2&quot;</span>);</span><br><span class="line">        link.addFirst(<span class="string">&quot;abc3&quot;</span>);</span><br><span class="line">        System.out.println(link);</span><br><span class="line">        <span class="comment">// 获取元素</span></span><br><span class="line">        System.out.println(link.getFirst());</span><br><span class="line">        System.out.println(link.getLast());</span><br><span class="line">        <span class="comment">// 删除元素</span></span><br><span class="line">        System.out.println(link.removeFirst());</span><br><span class="line">        System.out.println(link.removeLast());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!link.isEmpty()) &#123; <span class="comment">//判断集合是否为空</span></span><br><span class="line">            System.out.println(link.pop()); <span class="comment">//弹出集合中的栈顶元素</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(link);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第四章、Set接口"><a href="#第四章、Set接口" class="headerlink" title="第四章、Set接口"></a>第四章、Set接口</h1><p><code>java.util.Set</code>接口和<code>java.util.List</code>接口一样，同样继承自<code>Collection</code>接口，它与<code>Collection</code>接口中的方法基本一致，并没有对<code>Collection</code>接口进行功能上的扩充，只是比<code>Collection</code>接口更加严格了。与<code>List</code>接口不同的是，<code>Set</code>接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。</p>
<p><code>Set</code>集合有多个子类，这里我们介绍其中的<code>java.util.HashSet</code>、<code>java.util.LinkedHashSet</code>这两个集合。</p>
<blockquote>
<p>tips:Set集合取出元素的方式可以采用：迭代器、增强for。</p>
</blockquote>
<h2 id="3-1-HashSet集合介绍"><a href="#3-1-HashSet集合介绍" class="headerlink" title="3.1 HashSet集合介绍"></a>3.1 HashSet集合介绍</h2><p><code>java.util.HashSet</code>是<code>Set</code>接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。<code>java.util.HashSet</code>底层的实现其实是一个<code>java.util.HashMap</code>支持，由于我们暂时还未学习，先做了解。</p>
<p><strong><strong style="color:red"><code>HashSet</code>是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：<code>hashCode</code>与<code>equals</code>方法。</strong></strong></p>
<p>我们先来使用一下Set集合存储，看下现象，再进行原理的讲解:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建 Set集合</span></span><br><span class="line">        HashSet&lt;String&gt;  set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        set.add(<span class="keyword">new</span> String(<span class="string">&quot;cba&quot;</span>));</span><br><span class="line">        set.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;bac&quot;</span>); </span><br><span class="line">        set.add(<span class="string">&quot;cba&quot;</span>);  </span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (String name : set) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下，说明集合中不能存储重复元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cba</span><br><span class="line">abc</span><br><span class="line">bac</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:根据结果我们发现字符串”cba”只存储了一个，也就是说重复的元素set集合不存储。</p>
</blockquote>
<h2 id="2-2-HashSet集合存储数据的结构（哈希表）"><a href="#2-2-HashSet集合存储数据的结构（哈希表）" class="headerlink" title="2.2  HashSet集合存储数据的结构（哈希表）"></a>2.2  HashSet集合存储数据的结构（哈希表）</h2><p>什么是哈希表呢？</p>
<p>在<strong>JDK1.8</strong>之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p>
<p>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。<img src="/2021/05/09/day15-List-Set-Collections/%E5%93%88%E5%B8%8C%E8%A1%A8.png"></p>
<p>看到这张图就有人要问了，这个是怎么存储的呢？</p>
<p>为了方便大家的理解我们结合一个存储流程图来说明一下：</p>
<p><img src="/2021/05/09/day15-List-Set-Collections/%E5%93%88%E5%B8%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p>
<p>总而言之，<strong>JDK1.8</strong>引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。</p>
<h2 id="2-3-HashSet存储自定义类型元素"><a href="#2-3-HashSet存储自定义类型元素" class="headerlink" title="2.3  HashSet存储自定义类型元素"></a>2.3  HashSet存储自定义类型元素</h2><p><strong><strong style="color:red">给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一</strong></strong></p>
<p>创建自定义Student类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Student student = (Student) o;</span><br><span class="line">        <span class="keyword">return</span> age == student.age &amp;&amp;</span><br><span class="line">               Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建集合对象   该集合中存储 Student类型对象</span></span><br><span class="line">        HashSet&lt;Student&gt; stuSet = <span class="keyword">new</span> HashSet&lt;Student&gt;();</span><br><span class="line">        <span class="comment">//存储 </span></span><br><span class="line">        Student stu = <span class="keyword">new</span> Student(<span class="string">&quot;于谦&quot;</span>, <span class="number">43</span>);</span><br><span class="line">        stuSet.add(stu);</span><br><span class="line">        stuSet.add(<span class="keyword">new</span> Student(<span class="string">&quot;郭德纲&quot;</span>, <span class="number">44</span>));</span><br><span class="line">        stuSet.add(<span class="keyword">new</span> Student(<span class="string">&quot;于谦&quot;</span>, <span class="number">43</span>));</span><br><span class="line">        stuSet.add(<span class="keyword">new</span> Student(<span class="string">&quot;郭麒麟&quot;</span>, <span class="number">23</span>));</span><br><span class="line">        stuSet.add(stu);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Student stu2 : stuSet) &#123;</span><br><span class="line">            System.out.println(stu2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">执行结果：</span><br><span class="line">Student [name=郭德纲, age=<span class="number">44</span>]</span><br><span class="line">Student [name=于谦, age=<span class="number">43</span>]</span><br><span class="line">Student [name=郭麒麟, age=<span class="number">23</span>]</span><br></pre></td></tr></table></figure>

<h2 id="2-3-LinkedHashSet"><a href="#2-3-LinkedHashSet" class="headerlink" title="2.3 LinkedHashSet"></a>2.3 LinkedHashSet</h2><p>我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？</p>
<p>在HashSet下面有一个子类<code>java.util.LinkedHashSet</code>，它是链表和哈希表组合的一个数据存储结构。</p>
<p>演示代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSetDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Set&lt;String&gt; set = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;();</span><br><span class="line">		set.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">		set.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">		set.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">		set.add(<span class="string">&quot;bbc&quot;</span>);</span><br><span class="line">    Iterator&lt;String&gt; it = set.iterator();</span><br><span class="line">		<span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">			System.out.println(it.next());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">  bbb</span><br><span class="line">  aaa</span><br><span class="line">  abc</span><br><span class="line">  bbc</span><br></pre></td></tr></table></figure>

<h2 id="1-9-可变参数"><a href="#1-9-可变参数" class="headerlink" title="1.9  可变参数"></a>1.9  可变参数</h2><p>在<strong>JDK1.5</strong>之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型... 形参名)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>其实这个书写完全等价与</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型[] 形参名)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。</p>
<p><strong>JDK1.5</strong>以后。出现了简化操作。**…** 用在参数上，称之为可变参数。</p>
<p>同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。</p>
<p>代码演示：    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeArgs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">62</span>, <span class="number">431</span>, <span class="number">2</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> sum = getSum(arr);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        <span class="comment">//  6  7  2 12 2121</span></span><br><span class="line">        <span class="comment">// 求 这几个元素和 6  7  2 12 2121</span></span><br><span class="line">        <span class="keyword">int</span> sum2 = getSum(<span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">2121</span>);</span><br><span class="line">        System.out.println(sum2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 完成数组  所有元素的求和 原始写法</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">      public static int getSum(int[] arr)&#123;</span></span><br><span class="line"><span class="comment">        int sum = 0;</span></span><br><span class="line"><span class="comment">        for(int a : arr)&#123;</span></span><br><span class="line"><span class="comment">            sum += a;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        return sum;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//可变参数写法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span>... arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : arr) &#123;</span><br><span class="line">            sum += a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips: 上述add方法在同一个类中，只能存在一个。因为会发生调用的不确定性</p>
<p>注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。</p>
</blockquote>
<h1 id="第五章、Collections"><a href="#第五章、Collections" class="headerlink" title="第五章、Collections"></a>第五章、Collections</h1><h2 id="2-1-常用功能"><a href="#2-1-常用功能" class="headerlink" title="2.1 常用功能"></a>2.1 常用功能</h2><ul>
<li><code>java.utils.Collections</code>是集合工具类，用来对集合进行操作。部分方法如下：</li>
</ul>
<ul>
<li><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)  </code>:往集合中添加一些元素。</li>
<li><code>public static void shuffle(List&lt;?&gt; list) 打乱顺序</code>:打乱集合顺序。</li>
<li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</li>
<li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。</li>
</ul>
<p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//原来写法</span></span><br><span class="line">        <span class="comment">//list.add(12);</span></span><br><span class="line">        <span class="comment">//list.add(14);</span></span><br><span class="line">        <span class="comment">//list.add(15);</span></span><br><span class="line">        <span class="comment">//list.add(1000);</span></span><br><span class="line">        <span class="comment">//采用工具类 完成 往集合中添加元素  </span></span><br><span class="line">        Collections.addAll(list, <span class="number">5</span>, <span class="number">222</span>, <span class="number">1</span>，<span class="number">2</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//排序方法 </span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">[<span class="number">5</span>, <span class="number">222</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">222</span>]</span><br></pre></td></tr></table></figure>

<p>代码演示之后 ，发现我们的集合按照顺序进行了排列，可是这样的顺序是采用默认的顺序，如果想要指定顺序那该怎么办呢？</p>
<p>我们发现还有个方法没有讲，<code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。接下来讲解一下指定规则的排列。</p>
<h2 id="2-2-Comparator比较器"><a href="#2-2-Comparator比较器" class="headerlink" title="2.2 Comparator比较器"></a>2.2 Comparator比较器</h2><p>我们还是先研究这个方法</p>
<p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</p>
<p>不过这次存储的是字符串类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt;  list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;cba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;aba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;sba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;nba&quot;</span>);</span><br><span class="line">        <span class="comment">//排序方法</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[aba, cba, nba, sba]</span><br></pre></td></tr></table></figure>

<p>我们使用的是默认的规则完成字符串的排序，那么默认规则是怎么定义出来的呢？</p>
<p>说到排序了，简单的说就是两个对象之间比较大小，那么在JAVA中提供了两种比较实现的方式，一种是比较死板的采用<code>java.lang.Comparable</code>接口去实现，一种是灵活的当我需要做排序的时候在去选择的<code>java.util.Comparator</code>接口完成。</p>
<p>那么我们采用的<code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>这个方法完成的排序，实际上要求了被排序的类型需要实现Comparable接口完成比较的功能，在String类型上如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p>String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，那比如我想要字符串按照第一个字符降序排列，那么这样就要修改String的源代码，这是不可能的了，那么这个时候我们可以使用</p>
<p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>方法灵活的完成，这个里面就涉及到了Comparator这个接口，位于位于java.util包下，排序是comparator能实现的功能之一,该接口代表一个比较器，比较器具有可比性！顾名思义就是做排序的，通俗地讲需要比较两个对象谁排在前谁排在后，那么比较的方法就是：</p>
<ul>
<li><p><code> public int compare(String o1, String o2)</code>：比较其两个参数的顺序。</p>
<blockquote>
<p>两个对象比较的结果有三种：大于，等于，小于。</p>
<p>如果要按照升序排序，<br>则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）<br>如果要按照降序排序<br>则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数）</p>
</blockquote>
</li>
</ul>
<p>操作如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;cba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;aba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;sba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;nba&quot;</span>);</span><br><span class="line">        <span class="comment">//排序方法  按照第一个单词的降序</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.charAt(<span class="number">0</span>) - o1.charAt(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[sba, nba, cba, aba]</span><br></pre></td></tr></table></figure>

<h2 id="2-3-简述Comparable和Comparator两个接口的区别。"><a href="#2-3-简述Comparable和Comparator两个接口的区别。" class="headerlink" title="2.3 简述Comparable和Comparator两个接口的区别。"></a>2.3 简述Comparable和Comparator两个接口的区别。</h2><p><strong>Comparable</strong>：<strong style="color:red">强行对实现它的每个类的对象进行整体排序。</strong>这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</p>
<p><strong>Comparator</strong><strong style="color:red">强行对某个对象进行整体排序。</strong>可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。</p>
<h2 id="2-4-练习"><a href="#2-4-练习" class="headerlink" title="2.4  练习"></a>2.4  练习</h2><p>创建一个学生类，存储到ArrayList集合中完成指定排序操作。</p>
<p>Student 初始类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">               <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">               <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">               <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建四个学生对象 存储到集合中</span></span><br><span class="line">        ArrayList&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">&quot;rose&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">&quot;jack&quot;</span>,<span class="number">16</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">&quot;abc&quot;</span>,<span class="number">16</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">&quot;ace&quot;</span>,<span class="number">17</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">&quot;mark&quot;</span>,<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          让学生 按照年龄排序 升序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">//        Collections.sort(list);//要求 该list中元素类型  必须实现比较器Comparable接口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Student student : list) &#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现，当我们调用Collections.sort()方法的时候 程序报错了。</p>
<p>原因：如果想要集合中的元素完成排序，那么必须要实现比较器Comparable接口。</p>
<p>于是我们就完成了Student类的一个实现，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt;</span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age-o.age;<span class="comment">//升序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次测试，代码就OK 了效果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student&#123;name=<span class="string">&#x27;jack&#x27;</span>, age=<span class="number">16</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;abc&#x27;</span>, age=<span class="number">16</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;mark&#x27;</span>, age=<span class="number">16</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;ace&#x27;</span>, age=<span class="number">17</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;rose&#x27;</span>, age=<span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-扩展"><a href="#2-5-扩展" class="headerlink" title="2.5 扩展"></a>2.5 扩展</h2><p>如果在使用的时候，想要独立的定义规则去使用 可以采用Collections.sort(List list,Comparetor<T> c)方式，自己定义规则：</T></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o2.getAge()-o1.getAge();<span class="comment">//以学生的年龄降序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student&#123;name&#x3D;&#39;rose&#39;, age&#x3D;18&#125;</span><br><span class="line">Student&#123;name&#x3D;&#39;ace&#39;, age&#x3D;17&#125;</span><br><span class="line">Student&#123;name&#x3D;&#39;jack&#39;, age&#x3D;16&#125;</span><br><span class="line">Student&#123;name&#x3D;&#39;abc&#39;, age&#x3D;16&#125;</span><br><span class="line">Student&#123;name&#x3D;&#39;mark&#39;, age&#x3D;16&#125;</span><br></pre></td></tr></table></figure>



<p>如果想要规则更多一些，可以参考下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 年龄降序</span></span><br><span class="line">                <span class="keyword">int</span> result = o2.getAge()-o1.getAge();<span class="comment">//年龄降序</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(result==<span class="number">0</span>)&#123;<span class="comment">//第一个规则判断完了 下一个规则 姓名的首字母 升序</span></span><br><span class="line">                    result = o1.getName().charAt(<span class="number">0</span>)-o2.getName().charAt(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student&#123;name&#x3D;&#39;rose&#39;, age&#x3D;18&#125;</span><br><span class="line">Student&#123;name&#x3D;&#39;ace&#39;, age&#x3D;17&#125;</span><br><span class="line">Student&#123;name&#x3D;&#39;abc&#39;, age&#x3D;16&#125;</span><br><span class="line">Student&#123;name&#x3D;&#39;jack&#39;, age&#x3D;16&#125;</span><br><span class="line">Student&#123;name&#x3D;&#39;mark&#39;, age&#x3D;16&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>培训学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>day14-Collection集合-Iterator迭代器</title>
    <url>/2021/05/07/day14-Collection%E9%9B%86%E5%90%88-Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<p><strong><em>今日内容：Collection集合、Iterator迭代器</em></strong></p>
<span id="more"></span>

<h1 id="第一章-Collection集合"><a href="#第一章-Collection集合" class="headerlink" title="第一章 Collection集合"></a>第一章 Collection集合</h1><h2 id="1-1-集合概述"><a href="#1-1-集合概述" class="headerlink" title="1.1 集合概述"></a>1.1 集合概述</h2><p>在前面基础我们已经学习过并使用过集合ArrayList<E> ,那么集合到底是什么呢?</E></p>
<ul>
<li><strong>集合</strong>：集合是java中提供的一种容器，可以用来存储多个数据。</li>
</ul>
<p>集合和数组既然都是容器，它们有啥区别呢？</p>
<ul>
<li>数组的长度是固定的。集合的长度是可变的。</li>
<li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li>
</ul>
<h2 id="1-2-集合框架"><a href="#1-2-集合框架" class="headerlink" title="1.2  集合框架"></a>1.2  集合框架</h2><p>JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。</p>
<p>集合按照其存储结构可以分为两大类，分别是单列集合<code>java.util.Collection</code>和双列集合<code>java.util.Map</code>，今天我们主要学习<code>Collection</code>集合，在后面讲解<code>Map</code>集合。</p>
<ul>
<li><strong>Collection</strong>：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code>和<code>java.util.Set</code>。其中，<code>List</code>的特点是元素有序、元素可重复。<code>Set</code>的特点是元素无序，而且不可重复。<code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>，<code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code>。</li>
</ul>
<p>从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。<img src="/2021/05/07/day14-Collection%E9%9B%86%E5%90%88-Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8/教学大纲\04-JavaSE\img\2019-12-15_16-48-33.jpg" alt="2019-12-15_16-48-33" style="zoom:100%;"></p>
<p>其中，橙色框里填写的都是接口类型，而蓝色框里填写的都是具体的实现类。这几天将针对图中所列举的集合类进行逐一地讲解。</p>
<p>集合本身是一个工具，它存放在java.util包中。在<code>Collection</code>接口定义着单列集合框架中最最共性的内容。</p>
<h2 id="1-3-Collection-常用功能"><a href="#1-3-Collection-常用功能" class="headerlink" title="1.3 Collection 常用功能"></a>1.3 Collection 常用功能</h2><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p>
<ul>
<li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li>
<li><code>public void clear()</code> :清空集合中所有的元素。</li>
<li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li>
<li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li>
<li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li>
<li><code>public int size()</code>: 返回集合中元素的个数。</li>
<li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li>
</ul>
<p>方法演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1Collection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建集合对象 </span></span><br><span class="line">    	<span class="comment">// 使用多态形式</span></span><br><span class="line">    	Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    	<span class="comment">// 使用方法</span></span><br><span class="line">    	<span class="comment">// 添加功能  boolean  add(String s)</span></span><br><span class="line">    	coll.add(<span class="string">&quot;小李广&quot;</span>);</span><br><span class="line">    	coll.add(<span class="string">&quot;扫地僧&quot;</span>);</span><br><span class="line">    	coll.add(<span class="string">&quot;石破天&quot;</span>);</span><br><span class="line">    	System.out.println(coll);</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// boolean contains(E e) 判断o是否在集合中存在</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;判断  扫地僧 是否在集合中&quot;</span>+coll.contains(<span class="string">&quot;扫地僧&quot;</span>));</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//boolean remove(E e) 删除在集合中的o元素</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;删除石破天：&quot;</span>+coll.remove(<span class="string">&quot;石破天&quot;</span>));</span><br><span class="line">    	System.out.println(<span class="string">&quot;操作之后集合中元素:&quot;</span>+coll);</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// size() 集合中有几个元素</span></span><br><span class="line">		System.out.println(<span class="string">&quot;集合中有&quot;</span>+coll.size()+<span class="string">&quot;个元素&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Object[] toArray()转换成一个Object数组</span></span><br><span class="line">    	Object[] objects = coll.toArray();</span><br><span class="line">    	<span class="comment">// 遍历数组</span></span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">			System.out.println(objects[i]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// void  clear() 清空集合</span></span><br><span class="line">		coll.clear();</span><br><span class="line">		System.out.println(<span class="string">&quot;集合中内容为：&quot;</span>+coll);</span><br><span class="line">		<span class="comment">// boolean  isEmpty()  判断是否为空</span></span><br><span class="line">		System.out.println(coll.isEmpty());  	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips: 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。</p>
</blockquote>
<h1 id="第二章-Iterator迭代器"><a href="#第二章-Iterator迭代器" class="headerlink" title="第二章 Iterator迭代器"></a>第二章 Iterator迭代器</h1><h2 id="2-1-Iterator接口"><a href="#2-1-Iterator接口" class="headerlink" title="2.1 Iterator接口"></a>2.1 Iterator接口</h2><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code>。<code>Iterator</code>接口也是Java集合中的一员，但它与<code>Collection</code>、<code>Map</code>接口有所不同，<code>Collection</code>接口与<code>Map</code>接口主要用于存储元素，而<code>Iterator</code>主要用于迭代访问（即遍历）<code>Collection</code>中的元素，因此<code>Iterator</code>对象也被称为迭代器。</p>
<p>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：</p>
<ul>
<li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li>
</ul>
<p>下面介绍一下迭代的概念：</p>
<ul>
<li><strong>迭代</strong>：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</li>
</ul>
<p>Iterator接口的常用方法如下：</p>
<ul>
<li><code>public E next()</code>:返回迭代的下一个元素。</li>
<li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li>
</ul>
<p>接下来我们通过案例学习如何使用Iterator迭代集合中元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorDemo</span> </span>&#123;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用多态方式 创建对象</span></span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素到集合</span></span><br><span class="line">        coll.add(<span class="string">&quot;串串星人&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;吐槽星人&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;汪星人&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="comment">//使用迭代器 遍历   每个集合对象都有自己的迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line">        <span class="comment">//  泛型指的是 迭代出 元素的数据类型</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123; <span class="comment">//判断是否有迭代元素</span></span><br><span class="line">            String s = it.next();<span class="comment">//获取迭代出的元素</span></span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。</p>
</blockquote>
<h2 id="2-2-迭代器的实现原理"><a href="#2-2-迭代器的实现原理" class="headerlink" title="2.2 迭代器的实现原理"></a>2.2 迭代器的实现原理</h2><p>我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p>
<p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程：</p>
<p>在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p>
<h2 id="2-3-增强for"><a href="#2-3-增强for" class="headerlink" title="2.3 增强for"></a>2.3 增强for</h2><p>增强for循环(也称for each循环)是<strong>JDK1.5</strong>以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素的数据类型  变量 : Collection集合or数组)&#123; </span><br><span class="line">  	<span class="comment">//写操作代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。</p>
<h4 id="练习1：遍历数组"><a href="#练习1：遍历数组" class="headerlink" title="练习1：遍历数组"></a>练习1：遍历数组</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NBForDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">87</span>&#125;;</span><br><span class="line">       	<span class="comment">//使用增强for遍历数组</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a : arr)&#123;<span class="comment">//a代表数组中的每个元素</span></span><br><span class="line">			System.out.println(a);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="练习2-遍历集合"><a href="#练习2-遍历集合" class="headerlink" title="练习2:遍历集合"></a>练习2:遍历集合</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NBFor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">    	Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    	coll.add(<span class="string">&quot;小河神&quot;</span>);</span><br><span class="line">    	coll.add(<span class="string">&quot;老河神&quot;</span>);</span><br><span class="line">    	coll.add(<span class="string">&quot;神婆&quot;</span>);</span><br><span class="line">    	<span class="comment">//使用增强for遍历</span></span><br><span class="line">    	<span class="keyword">for</span>(String s :coll)&#123;<span class="comment">//接收变量s代表 代表被遍历到的集合元素</span></span><br><span class="line">    		System.out.println(s);</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>培训学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>day13-StringBuilder-包装类-泛型</title>
    <url>/2021/05/07/day13-StringBuilder-%E5%8C%85%E8%A3%85%E7%B1%BB-%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<p><strong><em>今日内容：StringBuilder、包装类、泛型</em></strong></p>
<span id="more"></span>

<h1 id="第四章-StringBuilder类"><a href="#第四章-StringBuilder类" class="headerlink" title="第四章 StringBuilder类"></a>第四章 StringBuilder类</h1><p><strong style="color:red">StringBuilder是线程不安全的，StringBuffer是线程安全的.</strong></p>
<h2 id="4-1-字符串拼接问题"><a href="#4-1-字符串拼接问题" class="headerlink" title="4.1 字符串拼接问题"></a>4.1 字符串拼接问题</h2><p>由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        s += <span class="string">&quot;World&quot;</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。</p>
<p>根据这句话分析我们的代码，其实总共产生了三个字符串，即<code>&quot;Hello&quot;</code>、<code>&quot;World&quot;</code>和<code>&quot;HelloWorld&quot;</code>。引用变量s首先指向<code>Hello</code>对象，最终指向拼接出来的新字符串对象，即<code>HelloWord</code> 。</p>
<p>由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用<code>java.lang.StringBuilder</code>类。</p>
<h2 id="4-2-StringBuilder概述"><a href="#4-2-StringBuilder概述" class="headerlink" title="4.2 StringBuilder概述"></a>4.2 StringBuilder概述</h2><p>查阅<code>java.lang.StringBuilder</code>的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。</p>
<p>原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。</p>
<p>它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。(默认16字符空间，超过自动扩充)</p>
<h2 id="4-3-构造方法"><a href="#4-3-构造方法" class="headerlink" title="4.3 构造方法"></a>4.3 构造方法</h2><p>根据StringBuilder的API文档，常用构造方法有2个：</p>
<ul>
<li><code>public StringBuilder()</code>：构造一个空的StringBuilder容器。</li>
<li><code>public StringBuilder(String str)</code>：构造一个StringBuilder容器，并将字符串添加进去。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        System.out.println(sb1); <span class="comment">// (空白)</span></span><br><span class="line">        <span class="comment">// 使用带参构造</span></span><br><span class="line">        StringBuilder sb2 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;hjm&quot;</span>);</span><br><span class="line">        System.out.println(sb2); <span class="comment">// hjm</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-4-常用方法"><a href="#4-4-常用方法" class="headerlink" title="4.4 常用方法"></a>4.4 常用方法</h2><p>StringBuilder常用的方法有2个：</p>
<ul>
<li><code>public StringBuilder append(...)</code>：添加任意类型数据的字符串形式，并返回当前对象自身。</li>
<li><code>public String toString()</code>：将当前StringBuilder对象转换为String对象。</li>
</ul>
<h3 id="append方法"><a href="#append方法" class="headerlink" title="append方法"></a>append方法</h3><p>append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02StringBuilder</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建对象</span></span><br><span class="line">		StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="comment">//public StringBuilder append(任意类型)</span></span><br><span class="line">		StringBuilder builder2 = builder.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		<span class="comment">//对比一下</span></span><br><span class="line">		System.out.println(<span class="string">&quot;builder:&quot;</span>+builder);</span><br><span class="line">		System.out.println(<span class="string">&quot;builder2:&quot;</span>+builder2);</span><br><span class="line">		System.out.println(builder == builder2); <span class="comment">//true</span></span><br><span class="line">	    <span class="comment">// 可以添加 任何类型</span></span><br><span class="line">		builder.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		builder.append(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">		builder.append(<span class="keyword">true</span>);</span><br><span class="line">		builder.append(<span class="number">100</span>);</span><br><span class="line">		<span class="comment">// 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。</span></span><br><span class="line">        <span class="comment">// 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下</span></span><br><span class="line">		<span class="comment">//链式编程</span></span><br><span class="line">		builder.append(<span class="string">&quot;hello&quot;</span>).append(<span class="string">&quot;world&quot;</span>).append(<span class="keyword">true</span>).append(<span class="number">100</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;builder:&quot;</span>+builder);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：StringBuilder已经覆盖重写了Object当中的toString方法。</p>
</blockquote>
<h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><p>通过toString方法，StringBuilder对象将会转换为不可变的String对象。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo16StringBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 链式创建</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;Hello&quot;</span>).append(<span class="string">&quot;World&quot;</span>).append(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        String str = sb.toString();</span><br><span class="line">        System.out.println(str); <span class="comment">// HelloWorldJava</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第五章-包装类"><a href="#第五章-包装类" class="headerlink" title="第五章 包装类"></a>第五章 包装类</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>对应的包装类（位于java.lang包中）</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td><strong>Integer</strong></td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td><strong>Character</strong></td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<h2 id="5-2-装箱与拆箱"><a href="#5-2-装箱与拆箱" class="headerlink" title="5.2 装箱与拆箱"></a>5.2 装箱与拆箱</h2><p>基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：</p>
<ul>
<li><p><strong>装箱</strong>：从基本类型转换为对应的包装类对象。</p>
</li>
<li><p><strong>拆箱</strong>：从包装类对象转换为对应的基本类型。</p>
</li>
</ul>
<p>用Integer与 int为例：（看懂代码即可）</p>
<p>基本数值—-&gt;包装对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">4</span>);<span class="comment">//使用构造函数函数</span></span><br><span class="line">Integer iii = Integer.valueOf(<span class="number">4</span>);<span class="comment">//使用包装类中的valueOf方法</span></span><br></pre></td></tr></table></figure>

<p>包装对象—-&gt;基本数值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = i.intValue();</span><br></pre></td></tr></table></figure>

<h2 id="5-3自动装箱与自动拆箱"><a href="#5-3自动装箱与自动拆箱" class="headerlink" title="5.3自动装箱与自动拆箱"></a>5.3自动装箱与自动拆箱</h2><p>由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="number">4</span>;<span class="comment">//自动装箱。相当于Integer i = Integer.valueOf(4);</span></span><br><span class="line">i = i + <span class="number">5</span>;<span class="comment">//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;</span></span><br><span class="line"><span class="comment">//加法运算完成后，再次装箱，把基本数值转成对象。</span></span><br></pre></td></tr></table></figure>

<h2 id="5-3-基本类型与字符串之间的转换"><a href="#5-3-基本类型与字符串之间的转换" class="headerlink" title="5.3 基本类型与字符串之间的转换"></a>5.3 基本类型与字符串之间的转换</h2><h3 id="基本类型转换为String"><a href="#基本类型转换为String" class="headerlink" title="基本类型转换为String"></a>基本类型转换为String</h3><p>   基本类型转换String总共有三种方式，查看课后资料可以得知，这里只讲最简单的一种方式： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">基本类型直接与””相连接即可；如：34+&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>String转换成对应的基本类型 </p>
<p>除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：</p>
<ul>
<li><code>public static byte parseByte(String s)</code>：将字符串参数转换为对应的byte基本类型。</li>
<li><code>public static short parseShort(String s)</code>：将字符串参数转换为对应的short基本类型。</li>
<li><code>public static int parseInt(String s)</code>：将字符串参数转换为对应的int基本类型。</li>
<li><code>public static long parseLong(String s)</code>：将字符串参数转换为对应的long基本类型。</li>
<li><code>public static float parseFloat(String s)</code>：将字符串参数转换为对应的float基本类型。</li>
<li><code>public static double parseDouble(String s)</code>：将字符串参数转换为对应的double基本类型。</li>
<li><code>public static boolean parseBoolean(String s)</code>：将字符串参数转换为对应的boolean基本类型。</li>
</ul>
<p>代码使用（仅以Integer类的静态方法parseXxx为例）如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo18WrapperParse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = Integer.parseInt(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出<code>java.lang.NumberFormatException</code>异常。</p>
</blockquote>
<h1 id="第六章-泛型"><a href="#第六章-泛型" class="headerlink" title="第六章 泛型"></a>第六章 泛型</h1><h2 id="6-1-泛型概述"><a href="#6-1-泛型概述" class="headerlink" title="6.1  泛型概述"></a>6.1  泛型概述</h2><p>在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。</p>
<p>大家观察下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">		coll.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">		coll.add(<span class="string">&quot;hjm&quot;</span>);</span><br><span class="line">		coll.add(<span class="number">5</span>);<span class="comment">//由于集合没有做任何限定，任何类型都可以给其中存放</span></span><br><span class="line">		Iterator it = coll.iterator();</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">			<span class="comment">//需要打印每个字符串的长度,就要把迭代出来的对象转成String类型</span></span><br><span class="line">			String str = (String) it.next();</span><br><span class="line">			System.out.println(str.length());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序在运行时发生了问题<strong>java.lang.ClassCastException</strong>。                                                                                             为什么会发生类型转换异常呢？                                                                                                                                       我们来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时 ClassCastException。                                                                                                                                                       怎么来解决这个问题呢？                                                                                                                                                           Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了<strong>泛型</strong>(<strong>Generic</strong>)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。</p>
<ul>
<li><strong>泛型</strong>：可以在类或方法中预知地使用未知的类型。</li>
</ul>
<blockquote>
<p>tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。</p>
</blockquote>
<h2 id="6-2-使用泛型的好处"><a href="#6-2-使用泛型的好处" class="headerlink" title="6.2  使用泛型的好处"></a>6.2  使用泛型的好处</h2><p>上一节只是讲解了泛型的引入，那么泛型带来了哪些好处呢？</p>
<ul>
<li>将运行时期的ClassCastException，转移到了编译时期变成了编译失败。</li>
<li>避免了类型强转的麻烦。</li>
</ul>
<p>通过我们如下代码体验一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;hjm&quot;</span>);</span><br><span class="line">        <span class="comment">// list.add(5);//当集合明确类型后，存放类型不一致就会编译报错</span></span><br><span class="line">        <span class="comment">// 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            String str = it.next();</span><br><span class="line">            <span class="comment">//当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型</span></span><br><span class="line">            System.out.println(str.length());</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。</p>
</blockquote>
<h2 id="6-3-泛型的定义与使用"><a href="#6-3-泛型的定义与使用" class="headerlink" title="6.3  泛型的定义与使用"></a>6.3  泛型的定义与使用</h2><p>我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。</p>
<p>泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。</p>
<h3 id="定义和使用含有泛型的类"><a href="#定义和使用含有泛型的类" class="headerlink" title="定义和使用含有泛型的类"></a>定义和使用含有泛型的类</h3><p>定义格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 class 类名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>例如，API中的ArrayList集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123; &#125;</span><br><span class="line">   	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用泛型： 即什么时候确定泛型。</p>
<p><strong>在创建对象的时候确定泛型</strong></p>
<p> 例如，<code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></p>
<p>此时，变量E的值就是String类型,那么我们的类型就可以理解为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">String</span>&gt;</span>&#123; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(String e)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;  &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再例如，<code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</code></p>
<p>此时，变量E的值就是Integer类型,那么我们的类型就可以理解为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">Integer</span>&gt; </span>&#123; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Integer e)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例自定义泛型类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericClass</span>&lt;<span class="title">MVP</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">//没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型</span></span><br><span class="line">	<span class="keyword">private</span> MVP mvp;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMVP</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mvp = mvp;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> MVP <span class="title">getMVP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClassDemo</span> </span>&#123;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;		 </span><br><span class="line">         <span class="comment">// 创建一个泛型为String的类</span></span><br><span class="line">         MyGenericClass&lt;String&gt; my = <span class="keyword">new</span> MyGenericClass&lt;String&gt;();    	</span><br><span class="line">         <span class="comment">// 调用setMVP</span></span><br><span class="line">         my.setMVP(<span class="string">&quot;大胡子登登&quot;</span>);</span><br><span class="line">         <span class="comment">// 调用getMVP</span></span><br><span class="line">         String mvp = my.getMVP();</span><br><span class="line">         System.out.println(mvp);</span><br><span class="line">         <span class="comment">//创建一个泛型为Integer的类</span></span><br><span class="line">         MyGenericClass&lt;Integer&gt; my2 = <span class="keyword">new</span> MyGenericClass&lt;Integer&gt;(); </span><br><span class="line">         my2.setMVP(<span class="number">123</span>);   	  </span><br><span class="line">         Integer mvp2 = my2.getMVP();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h3><p>定义格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>例如，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericMethod</span> </span>&#123;	  </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">    	System.out.println(mvp.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="function">MVP <span class="title">show2</span><span class="params">(MVP mvp)</span> </span>&#123;	</span><br><span class="line">    	<span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用格式：<strong>调用方法时，确定泛型的类型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethodDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        MyGenericMethod mm = <span class="keyword">new</span> MyGenericMethod();</span><br><span class="line">        <span class="comment">// 演示看方法提示</span></span><br><span class="line">        mm.show(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        mm.show(<span class="number">123</span>);</span><br><span class="line">        mm.show(<span class="number">12.45</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h3><p>定义格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 interface接口名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>例如，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> E <span class="title">getE</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用格式：</p>
<p><strong>1、定义类时确定泛型的类型</strong></p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImp1</span> <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，泛型E的值就是String类型。</p>
<p> <strong>2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型</strong></p>
<p> 例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImp2</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       	 <span class="comment">// 省略...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> E <span class="title">getE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确定泛型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyImp2&lt;String&gt;  my = <span class="keyword">new</span> MyImp2&lt;String&gt;();  </span><br><span class="line">        my.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-4-泛型通配符"><a href="#6-4-泛型通配符" class="headerlink" title="6.4  泛型通配符"></a>6.4  泛型通配符</h2><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p>
<h4 id="通配符基本使用"><a href="#通配符基本使用" class="headerlink" title="通配符基本使用"></a>通配符基本使用</h4><p>泛型的通配符:<strong>不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。</strong></p>
<p>此时只能接受数据,不能往该集合中存储数据。</p>
<p>举个例子大家理解使用即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Intger&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    getElement(list1);</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    getElement(list2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement</span><span class="params">(Collection&lt;?&gt; coll)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//？代表可以接收任意类型</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:泛型不存在继承关系 Collection<Object> list = new ArrayList<String>();这种是错误的。</String></Object></p>
</blockquote>
<h4 id="通配符高级使用—-受限泛型"><a href="#通配符高级使用—-受限泛型" class="headerlink" title="通配符高级使用—-受限泛型"></a>通配符高级使用—-受限泛型</h4><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p>
<p><strong>泛型的上限</strong>：</p>
<ul>
<li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li>
<li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li>
</ul>
<p><strong>泛型的下限</strong>：</p>
<ul>
<li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li>
<li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li>
</ul>
<p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    Collection&lt;Number&gt; list3 = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">    Collection&lt;Object&gt; list4 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">    </span><br><span class="line">    getElement1(list1);</span><br><span class="line">    getElement1(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement1(list3);</span><br><span class="line">    getElement1(list4);<span class="comment">//报错</span></span><br><span class="line">  </span><br><span class="line">    getElement2(list1);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list3);</span><br><span class="line">    getElement2(list4);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement1</span><span class="params">(Collection&lt;? extends Number&gt; coll)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement2</span><span class="params">(Collection&lt;? <span class="keyword">super</span> Number&gt; coll)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第七章-集合综合案例"><a href="#第七章-集合综合案例" class="headerlink" title="第七章 集合综合案例"></a>第七章 集合综合案例</h1><h2 id="7-1-案例介绍"><a href="#7-1-案例介绍" class="headerlink" title="7.1 案例介绍"></a>7.1 案例介绍</h2><p>按照斗地主的规则，完成洗牌发牌的动作。<br>具体规则：</p>
<p>使用54张牌打乱顺序,三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</p>
<h2 id="7-2-案例分析"><a href="#7-2-案例分析" class="headerlink" title="7.2 案例分析"></a>7.2 案例分析</h2><ul>
<li><p>准备牌：</p>
<p>牌可以设计为一个ArrayList<String>,每个字符串为一张牌。<br>每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。<br>牌由Collections类的shuffle方法进行随机排序。</String></p>
</li>
<li><p>发牌</p>
<p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</String></p>
</li>
</ul>
<ul>
<li><p>看牌</p>
<p>直接打印每个集合。</p>
</li>
</ul>
<h2 id="7-3-代码实现"><a href="#7-3-代码实现" class="headerlink" title="7.3 代码实现"></a>7.3 代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 1: 准备牌操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//1.1 创建牌盒 将来存储牌面的 </span></span><br><span class="line">        ArrayList&lt;String&gt; pokerBox = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//1.2 创建花色集合</span></span><br><span class="line">        ArrayList&lt;String&gt; colors = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.3 创建数字集合</span></span><br><span class="line">        ArrayList&lt;String&gt; numbers = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.4 分别给花色 以及 数字集合添加元素</span></span><br><span class="line">        colors.add(<span class="string">&quot;♥&quot;</span>);</span><br><span class="line">        colors.add(<span class="string">&quot;♦&quot;</span>);</span><br><span class="line">        colors.add(<span class="string">&quot;♠&quot;</span>);</span><br><span class="line">        colors.add(<span class="string">&quot;♣&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">            numbers.add(i+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        numbers.add(<span class="string">&quot;J&quot;</span>);</span><br><span class="line">        numbers.add(<span class="string">&quot;Q&quot;</span>);</span><br><span class="line">        numbers.add(<span class="string">&quot;K&quot;</span>);</span><br><span class="line">        numbers.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="comment">//1.5 创造牌  拼接牌操作</span></span><br><span class="line">        <span class="comment">// 拿出每一个花色  然后跟每一个数字 进行结合  存储到牌盒中</span></span><br><span class="line">        <span class="keyword">for</span> (String color : colors) &#123;</span><br><span class="line">            <span class="comment">//color每一个花色 </span></span><br><span class="line">            <span class="comment">//遍历数字集合</span></span><br><span class="line">            <span class="keyword">for</span>(String number : numbers)&#123;</span><br><span class="line">                <span class="comment">//结合</span></span><br><span class="line">                String card = color+number;</span><br><span class="line">                <span class="comment">//存储到牌盒中</span></span><br><span class="line">                pokerBox.add(card);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.6大王小王</span></span><br><span class="line">        pokerBox.add(<span class="string">&quot;小☺&quot;</span>);</span><br><span class="line">        pokerBox.add(<span class="string">&quot;大☠&quot;</span>);	  </span><br><span class="line">        <span class="comment">// System.out.println(pokerBox);</span></span><br><span class="line">        <span class="comment">//洗牌 是不是就是将  牌盒中 牌的索引打乱 </span></span><br><span class="line">        <span class="comment">// Collections类  工具类  都是 静态方法</span></span><br><span class="line">        <span class="comment">// shuffer方法   </span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * static void shuffle(List&lt;?&gt; list) </span></span><br><span class="line"><span class="comment">         *     使用默认随机源对指定列表进行置换。 </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//2:洗牌</span></span><br><span class="line">        Collections.shuffle(pokerBox);</span><br><span class="line">        <span class="comment">//3 发牌</span></span><br><span class="line">        <span class="comment">//3.1 创建 三个 玩家集合  创建一个底牌集合</span></span><br><span class="line">        ArrayList&lt;String&gt; player1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; player2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; player3 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; dipai = <span class="keyword">new</span> ArrayList&lt;String&gt;();	  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历 牌盒  必须知道索引   </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;pokerBox.size();i++)&#123;</span><br><span class="line">            <span class="comment">//获取 牌面</span></span><br><span class="line">            String card = pokerBox.get(i);</span><br><span class="line">            <span class="comment">//留出三张底牌 存到 底牌集合中</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">51</span>)&#123;<span class="comment">//存到底牌集合中</span></span><br><span class="line">                dipai.add(card);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//玩家1   %3  ==0</span></span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                  	player1.add(card);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">1</span>)&#123;<span class="comment">//玩家2</span></span><br><span class="line">                  	player2.add(card);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//玩家3</span></span><br><span class="line">                  	player3.add(card);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//看看</span></span><br><span class="line">        System.out.println(<span class="string">&quot;令狐冲：&quot;</span>+player1);</span><br><span class="line">        System.out.println(<span class="string">&quot;田伯光：&quot;</span>+player2);</span><br><span class="line">        System.out.println(<span class="string">&quot;绿竹翁：&quot;</span>+player3);</span><br><span class="line">        System.out.println(<span class="string">&quot;底牌：&quot;</span>+dipai);  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>培训学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>day12-Object-日期时间类-System类</title>
    <url>/2021/04/27/day12-Object-%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%B1%BB-System%E7%B1%BB/</url>
    <content><![CDATA[<p><strong><em>今日内容：Object类、日期时间类、System类</em></strong></p>
<span id="more"></span>

<h1 id="第一章-Object类"><a href="#第一章-Object类" class="headerlink" title="第一章 Object类"></a>第一章 Object类</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p><code>java.lang.Object</code>类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。</p>
<p>如果一个类没有特别指定父类，    那么默认则继承自Object类。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> /*<span class="keyword">extends</span> <span class="title">Object</span>*/ </span>&#123;</span><br><span class="line">  	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的2个：</p>
<ul>
<li><code>public String toString()</code>：返回该对象的字符串表示。</li>
<li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li>
</ul>
<h2 id="1-2-toString方法"><a href="#1-2-toString方法" class="headerlink" title="1.2 toString方法"></a>1.2 toString方法</h2><h3 id="方法摘要"><a href="#方法摘要" class="headerlink" title="方法摘要"></a>方法摘要</h3><ul>
<li><code>public String toString()</code>：返回该对象的字符串表示。</li>
</ul>
<p>toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。</p>
<p>由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。</p>
<h3 id="覆盖重写"><a href="#覆盖重写" class="headerlink" title="覆盖重写"></a>覆盖重写</h3><p>如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> + <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略构造器与Getter Setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。</p>
</blockquote>
<h2 id="1-3-equals方法"><a href="#1-3-equals方法" class="headerlink" title="1.3 equals方法"></a>1.3 equals方法</h2><h3 id="方法摘要-1"><a href="#方法摘要-1" class="headerlink" title="方法摘要"></a>方法摘要</h3><ul>
<li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li>
</ul>
<p>调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。</p>
<h3 id="默认地址比较"><a href="#默认地址比较" class="headerlink" title="默认地址比较"></a>默认地址比较</h3><p>如果没有覆盖重写equals方法，那么Object类中默认进行<code>==</code>运算符的对象地址比较，只要不是同一个对象，结果必然为false。</p>
<h3 id="对象内容比较"><a href="#对象内容比较" class="headerlink" title="对象内容比较"></a>对象内容比较</h3><p>如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;	</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果对象地址一样，则认为相同</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 如果参数为空，或者类型信息不一样，则认为不同</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 转换为当前类型</span></span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="comment">// 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果</span></span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp; Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips：Object类当中的hashCode等其他方法，今后学习。</p>
</blockquote>
<h2 id="1-4-Objects类"><a href="#1-4-Objects类" class="headerlink" title="1.4 Objects类"></a>1.4 Objects类</h2><p>在<strong>JDK7</strong>添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是<strong style="color:red">null-save（空指针安全的）</strong>或<strong style="color:red">null-tolerant（容忍空指针的）</strong>，用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。</p>
<p>在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下：</p>
<ul>
<li><code>public static boolean equals(Object a, Object b)</code>:判断两个对象是否相等。</li>
</ul>
<blockquote>
<p> 我们可以查看一下源码，学习一下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="keyword">null</span> &amp;&amp; a.equals(b));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第二章-日期时间类"><a href="#第二章-日期时间类" class="headerlink" title="第二章 日期时间类"></a>第二章 日期时间类</h1><h2 id="2-1-Date类"><a href="#2-1-Date类" class="headerlink" title="2.1 Date类"></a>2.1 Date类</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code> java.util.Date</code>类 表示特定的瞬间，精确到毫秒。</p>
<p>继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。</p>
<ul>
<li><code>public Date()</code>：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。</li>
<li><code>public Date(long date)</code>：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。</li>
</ul>
<blockquote>
<p>tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。</p>
</blockquote>
<p>简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Date</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建日期对象，把当前的时间</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date()); <span class="comment">// Tue Jan 16 14:37:35 CST 2018</span></span><br><span class="line">        <span class="comment">// 创建日期对象，把当前的毫秒值转成日期对象</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date(<span class="number">0L</span>)); <span class="comment">// Thu Jan 01 08:00:00 CST 1970</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。</p>
</blockquote>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>Date类中的多数方法已经过时，常用的方法有：</p>
<ul>
<li><code>public long getTime()</code> 把日期对象转换成对应的时间毫秒值。</li>
</ul>
<h2 id="2-2-DateFormat类"><a href="#2-2-DateFormat类" class="headerlink" title="2.2 DateFormat类"></a>2.2 DateFormat类</h2><p><code>java.text.DateFormat</code> 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。</p>
<ul>
<li><strong>格式化</strong>：按照指定的格式，从Date对象转换为String对象。</li>
<li><strong>解析</strong>：按照指定的格式，从String对象转换为Date对象。</li>
</ul>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>由于DateFormat为抽象类，不能直接使用，所以需要常用的子类<code>java.text.SimpleDateFormat</code>。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为：</p>
<ul>
<li><code>public SimpleDateFormat(String pattern)</code>：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。</li>
</ul>
<p>参数pattern是一个字符串，代表日期时间的自定义格式。</p>
<h3 id="格式规则"><a href="#格式规则" class="headerlink" title="格式规则"></a>格式规则</h3><p>常用的格式规则为：</p>
<table>
<thead>
<tr>
<th>标识字母（区分大小写）</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>y</td>
<td>年</td>
</tr>
<tr>
<td>M</td>
<td>月</td>
</tr>
<tr>
<td>d</td>
<td>日</td>
</tr>
<tr>
<td>H</td>
<td>时</td>
</tr>
<tr>
<td>m</td>
<td>分</td>
</tr>
<tr>
<td>s</td>
<td>秒</td>
</tr>
</tbody></table>
<blockquote>
<p>备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档0。</p>
</blockquote>
<p>创建SimpleDateFormat对象的代码如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02SimpleDateFormat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对应的日期格式如：2018-01-16 15:06:38</span></span><br><span class="line">        DateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        format.format(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><p>DateFormat类的常用方法有：</p>
<ul>
<li><code>public String format(Date date)</code>：将Date对象格式化为字符串。</li>
<li><code>public Date parse(String source)</code>：将字符串解析为Date对象。</li>
</ul>
<h4 id="format方法"><a href="#format方法" class="headerlink" title="format方法"></a>format方法</h4><p>使用format方法的代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 把Date对象转换成String</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03DateFormatMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="comment">// 创建日期格式化对象,在获取格式化对象时可以指定风格</span></span><br><span class="line">        DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日&quot;</span>);</span><br><span class="line">        String str = df.format(date);</span><br><span class="line">        System.out.println(str); <span class="comment">// 2008年1月23日</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="parse方法"><a href="#parse方法" class="headerlink" title="parse方法"></a>parse方法</h4><p>使用parse方法的代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 把String转换成Date对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04DateFormatMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日&quot;</span>);</span><br><span class="line">        String str = <span class="string">&quot;2018年12月11日&quot;</span>;</span><br><span class="line">        Date date = df.parse(str);</span><br><span class="line">        System.out.println(date); <span class="comment">// Tue Dec 11 00:00:00 CST 2018</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-练习"><a href="#2-3-练习" class="headerlink" title="2.3 练习"></a>2.3 练习</h2><p>请使用日期时间相关的API，计算出一个人已经出生了多少天。</p>
<p><strong>思路：</strong></p>
<p>1.获取当前时间对应的毫秒值</p>
<p>2.获取自己出生日期对应的毫秒值</p>
<p>3.两个时间相减（当前时间– 出生日期）</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;请输入出生日期 格式 YYYY-MM-dd&quot;</span>);</span><br><span class="line">	<span class="comment">// 获取出生日期,键盘输入</span></span><br><span class="line">	String birthdayString = <span class="keyword">new</span> Scanner(System.in).next();</span><br><span class="line">	<span class="comment">// 将字符串日期,转成Date对象</span></span><br><span class="line">	<span class="comment">// 创建SimpleDateFormat对象,写日期模式</span></span><br><span class="line">	SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">	<span class="comment">// 调用方法parse,字符串转成日期对象</span></span><br><span class="line">	Date birthdayDate = sdf.parse(birthdayString);	</span><br><span class="line">	<span class="comment">// 获取今天的日期对象</span></span><br><span class="line">	Date todayDate = <span class="keyword">new</span> Date();	</span><br><span class="line">	<span class="comment">// 将两个日期转成毫秒值,Date类的方法getTime</span></span><br><span class="line">	<span class="keyword">long</span> birthdaySecond = birthdayDate.getTime();</span><br><span class="line">	<span class="keyword">long</span> todaySecond = todayDate.getTime();</span><br><span class="line">	<span class="keyword">long</span> secone = todaySecond-birthdaySecond;	</span><br><span class="line">	<span class="keyword">if</span> (secone &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;还没出生呢&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		System.out.println(secone/<span class="number">1000</span>/<span class="number">60</span>/<span class="number">60</span>/<span class="number">24</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-Calendar类"><a href="#2-4-Calendar类" class="headerlink" title="2.4 Calendar类"></a>2.4 Calendar类</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><code>java.util.Calendar</code>是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。</p>
<h3 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h3><p>Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下：</p>
<p>Calendar静态方法</p>
<ul>
<li><code>public static Calendar getInstance()</code>：使用默认时区和语言环境获得一个日历</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06CalendarInit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><p>根据Calendar类的API文档，常用方法有：</p>
<ul>
<li><code>public int get(int field)</code>：返回给定日历字段的值。</li>
<li><code>public void set(int field, int value)</code>：将给定的日历字段设置为给定值。</li>
<li><code>public abstract void add(int field, int amount)</code>：根据日历的规则，为给定的日历字段添加或减去指定的时间量。</li>
<li><code>public Date getTime()</code>：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。</li>
</ul>
<p>Calendar类中提供很多成员常量，代表给定的日历字段：</p>
<table>
<thead>
<tr>
<th>字段值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>YEAR</td>
<td>年</td>
</tr>
<tr>
<td>MONTH</td>
<td>月（从0开始，可以+1使用）</td>
</tr>
<tr>
<td>DAY_OF_MONTH</td>
<td>月中的天（几号）</td>
</tr>
<tr>
<td>HOUR</td>
<td>时（12小时制）</td>
</tr>
<tr>
<td>HOUR_OF_DAY</td>
<td>时（24小时制）</td>
</tr>
<tr>
<td>MINUTE</td>
<td>分</td>
</tr>
<tr>
<td>SECOND</td>
<td>秒</td>
</tr>
<tr>
<td>DAY_OF_WEEK</td>
<td>周中的天（周几，周日为1，可以-1使用）</td>
</tr>
</tbody></table>
<h4 id="get-set方法"><a href="#get-set方法" class="headerlink" title="get/set方法"></a>get/set方法</h4><p>get方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalendarUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Calendar对象</span></span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 设置年 </span></span><br><span class="line">        <span class="keyword">int</span> year = cal.get(Calendar.YEAR);</span><br><span class="line">        <span class="comment">// 设置月</span></span><br><span class="line">        <span class="keyword">int</span> month = cal.get(Calendar.MONTH) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 设置日</span></span><br><span class="line">        <span class="keyword">int</span> dayOfMonth = cal.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo07CalendarMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        cal.set(Calendar.YEAR, <span class="number">2020</span>);</span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>); <span class="comment">// 2020年1月17日</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><p>add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo08CalendarMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>); <span class="comment">// 2018年1月17日</span></span><br><span class="line">        <span class="comment">// 使用add方法</span></span><br><span class="line">        cal.add(Calendar.DAY_OF_MONTH, <span class="number">2</span>); <span class="comment">// 加2天</span></span><br><span class="line">        cal.add(Calendar.YEAR, -<span class="number">3</span>); <span class="comment">// 减3年</span></span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>); <span class="comment">// 2015年1月18日; </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getTime方法"><a href="#getTime方法" class="headerlink" title="getTime方法"></a>getTime方法</h4><p>Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo09CalendarMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        Date date = cal.getTime();</span><br><span class="line">        System.out.println(date); <span class="comment">// Tue Jan 16 16:03:09 CST 2018</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<p>​     西方星期的开始为周日，中国为 周一。</p>
<p>​     在Calendar类中，月份的表示是以0-11代表1-12月。</p>
<p>​     日期是有大小关系的，时间靠后，时间越大。</p>
</blockquote>
<h1 id="第三章-System类"><a href="#第三章-System类" class="headerlink" title="第三章 System类"></a>第三章 System类</h1><p><code>java.lang.System</code>类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有：</p>
<ul>
<li><code>public static long currentTimeMillis()</code>：返回以毫秒为单位的当前时间。</li>
<li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li>
</ul>
<h2 id="3-1-currentTimeMillis方法"><a href="#3-1-currentTimeMillis方法" class="headerlink" title="3.1 currentTimeMillis方法"></a>3.1 currentTimeMillis方法</h2><p>实际上，currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       	<span class="comment">//获取当前时间毫秒值</span></span><br><span class="line">        System.out.println(System.currentTimeMillis()); <span class="comment">// 1516090531144</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>验证for循环打印数字1-9999所需要使用的时间（毫秒）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;共耗时毫秒：&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-arraycopy方法"><a href="#3-2-arraycopy方法" class="headerlink" title="3.2 arraycopy方法"></a>3.2 arraycopy方法</h2><ul>
<li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li>
</ul>
<p>数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为：</p>
<table>
<thead>
<tr>
<th>参数序号</th>
<th>参数名称</th>
<th>参数类型</th>
<th>参数含义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>src</td>
<td>Object</td>
<td>源数组</td>
</tr>
<tr>
<td>2</td>
<td>srcPos</td>
<td>int</td>
<td>源数组索引起始位置</td>
</tr>
<tr>
<td>3</td>
<td>dest</td>
<td>Object</td>
<td>目标数组</td>
</tr>
<tr>
<td>4</td>
<td>destPos</td>
<td>int</td>
<td>目标数组索引起始位置</td>
</tr>
<tr>
<td>5</td>
<td>length</td>
<td>int</td>
<td>复制元素个数</td>
</tr>
</tbody></table>
<h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><p>将src数组中前3个元素，复制到dest数组的前3个位置上复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo11SystemArrayCopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] src = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dest = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        System.arraycopy( src, <span class="number">0</span>, dest, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">/*代码运行后：两个数组中的元素发生了变化</span></span><br><span class="line"><span class="comment">         src数组元素[1,2,3,4,5]</span></span><br><span class="line"><span class="comment">         dest数组元素[1,2,3,9,10]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      <categories>
        <category>Java</category>
        <category>培训学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>day11-final-权限-内部类-引用类型</title>
    <url>/2021/04/26/day11-final-%E6%9D%83%E9%99%90-%E5%86%85%E9%83%A8%E7%B1%BB-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p><strong><em>今日内容：final、权限、内部类、引用类型</em></strong></p>
<span id="more"></span>

<h1 id="第一章、final关键字"><a href="#第一章、final关键字" class="headerlink" title="第一章、final关键字"></a>第一章、final关键字</h1><h2 id="1-1、概述"><a href="#1-1、概述" class="headerlink" title="1.1、概述"></a>1.1、概述</h2><p>学习了继承后，我们知道，子类可以在父类的基础上改写父类内容，比如，方法重写。<br>那么我们能不能随意的继承API中提供的类，改写其内容呢？显然这是不合适的。为了避免这种随意改写的情况，Java提供了 final 关键字，用于修饰不可改变的内容</p>
<p><strong style="color:red">final： 不可改变。可以用于修饰类、方法和变量。</strong><br>      <strong style="color:red">类：被修饰的类，不能被继承。</strong><br>      <strong style="color:red">方法：被修饰的方法，不能被重写。</strong><br>     <strong style="color:red">变量：被修饰的变量，不能被重新赋值</strong></p>
<h2 id="1-2、使用方式"><a href="#1-2、使用方式" class="headerlink" title="1.2、使用方式"></a>1.2、使用方式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.修饰类</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> 类名 </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询API发现像 public final class String 、 public final class Math 、 public final class Scanner等，很多我们学习过的类，都是被final修饰的，目的就是供我们使用，而不让我们所以改变其内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.修饰方法：重写被 final 修饰的方法，编译时就会报错。</span></span><br><span class="line">修饰符 <span class="keyword">final</span> 返回值类型 方法名(参数列表)&#123;</span><br><span class="line">		<span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.修饰变量</span></span><br><span class="line">	<span class="number">1</span>）局部变量——基本类型：基本类型的局部变量，被<span class="keyword">final</span>修饰后，只能赋值一次，不能再更改。代码如下：</span><br><span class="line">      <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalDemo1</span> </span>&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">              <span class="comment">// 声明变量，使用final修饰</span></span><br><span class="line">              <span class="keyword">final</span> <span class="keyword">int</span> a;</span><br><span class="line">              <span class="comment">// 第一次赋值</span></span><br><span class="line">              a = <span class="number">10</span>;</span><br><span class="line">              <span class="comment">// 第二次赋值</span></span><br><span class="line">              a = <span class="number">20</span>; <span class="comment">// 报错,不可重新赋值</span></span><br><span class="line">              <span class="comment">// 声明变量，直接赋值，使用final修饰</span></span><br><span class="line">              <span class="keyword">final</span> <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">              <span class="comment">// 第二次赋值</span></span><br><span class="line">              b = <span class="number">20</span>; <span class="comment">// 报错,不可重新赋值</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">	<span class="number">2</span>）局部变量--引用类型：引用类型的局部变量，被<span class="keyword">final</span>修饰后，只能指向一个对象，地址不能再更改。但是不影响对象内部的成员变量值的修改，代码如下：</span><br><span class="line">      <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalDemo2</span> </span>&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">              <span class="comment">// 创建 User 对象</span></span><br><span class="line">              <span class="keyword">final</span> User u = <span class="keyword">new</span> User();</span><br><span class="line">              <span class="comment">// 创建 另一个 User对象</span></span><br><span class="line">              u = <span class="keyword">new</span> User(); <span class="comment">// 报错，指向了新的对象，地址值改变。</span></span><br><span class="line">              <span class="comment">// 调用setName方法</span></span><br><span class="line">              u.setName(<span class="string">&quot;张三&quot;</span>); <span class="comment">// 可以修改</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">	<span class="number">3</span>）成员变量：成员变量涉及到初始化的问题，初始化方式有两种，只能二选一：</span><br><span class="line">    <span class="comment">//注意：被final修饰的常量名称，一般都有书写规范，所有字母都大写。</span></span><br><span class="line">    	<span class="number">1.</span>显示初始化</span><br><span class="line">    		<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">                 <span class="keyword">final</span> String USERNAME = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">                 <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="number">2.</span>构造器初始化</span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> String USERNAME ;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">            </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">this</span>.USERNAME = username;</span><br><span class="line">                <span class="keyword">this</span>.age = age;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 思考题：</span></span><br><span class="line"><span class="comment">// 写法1:</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        c = i; <span class="comment">// 编译报错</span></span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 写法2:</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> c = i; <span class="comment">// 通过</span></span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="第二章、权限修饰符"><a href="#第二章、权限修饰符" class="headerlink" title="第二章、权限修饰符"></a>第二章、权限修饰符</h1><h2 id="2-1、概述"><a href="#2-1、概述" class="headerlink" title="2.1、概述"></a>2.1、概述</h2><p>在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限，<br>    <strong>public：公共的。</strong><br>    <strong>protected：受保护的</strong><br>    <strong>default：默认的</strong><br>    <strong>private：私有的</strong></p>
<h2 id="2-2、不同权限的访问能力"><a href="#2-2、不同权限的访问能力" class="headerlink" title="2.2、不同权限的访问能力"></a>2.2、不同权限的访问能力</h2><table>
<thead>
<tr>
<th></th>
<th>public</th>
<th>protected</th>
<th>default（默认：空的）</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>同一个类中</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>同一个包中</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td></td>
</tr>
<tr>
<td>不同包中的子类</td>
<td>✅</td>
<td>✅</td>
<td></td>
<td></td>
</tr>
<tr>
<td>不同包中的无关类</td>
<td>✅</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>// 可见，public具有最大权限。private则是最小权限。<br>编写代码时，如果没有特殊的考虑，建议这样使用权限：</p>
<blockquote>
<p>   <em>成员变</em>量使用 private ，隐藏细节。*<br>    <em>构造方法使用 public ，方便创建对象。</em><br>    成员方法使用 public ，方便调用方法。*<br><strong>注意：不加权限修饰符，其访问能力与default修饰符相同</strong></p>
</blockquote>
<h1 id="第三章、内部类"><a href="#第三章、内部类" class="headerlink" title="第三章、内部类"></a>第三章、内部类</h1><h2 id="3-1、概述"><a href="#3-1、概述" class="headerlink" title="3.1、概述"></a>3.1、概述</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 什么是内部类：将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类</span></span><br><span class="line"><span class="comment">// 成员内部类：定义在类中方法外的类</span></span><br><span class="line"><span class="comment">// 示例：汽车类中还包含发动机类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123; <span class="comment">//外部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123; <span class="comment">//内部类</span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>访问特点：</strong><br>    1）内部类可以直接访问外部类的成员，包括私有成员。<br>    2）外部类要访问内部类的成员，必须要建立内部类的对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建内部类对象的格式：</span></span><br><span class="line">     外部类名.内部类名 对象名 = <span class="keyword">new</span> 外部类型().new 内部类型()；</span><br><span class="line"><span class="comment">// 示例：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> live = <span class="keyword">true</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Heart</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 直接访问外部类成员</span></span><br><span class="line">            <span class="keyword">if</span> (live) &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;心脏在跳动&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;心脏不跳了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    		<span class="keyword">return</span> live;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLive</span><span class="params">(<span class="keyword">boolean</span> live)</span> </span>&#123;</span><br><span class="line">    		<span class="keyword">this</span>.live = live;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建外部类对象</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="comment">// 创建内部类对象</span></span><br><span class="line">        Person.Heart heart = p.<span class="function">new <span class="title">Heart</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 调用内部类方法</span></span><br><span class="line">        heart.jump();</span><br><span class="line">        <span class="comment">// 调用外部类方法</span></span><br><span class="line">        p.setLive(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 调用内部类方法</span></span><br><span class="line">        heart.jump();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果:</span></span><br><span class="line">    心脏在跳动</span><br><span class="line">    心脏不跳了</span><br><span class="line"><span class="comment">//⚠️注意：内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号，比如，Person$Heart.class</span></span><br></pre></td></tr></table></figure>

<h2 id="3-2、匿名内部类（重点）"><a href="#3-2、匿名内部类（重点）" class="headerlink" title="3.2、匿名内部类（重点）"></a>3.2、匿名内部类（重点）</h2><p>// 匿名内部类 ：是内部类的简化写法。它的本质是一个 带具体实现的 父类或者父接口的 匿名的 子类对象。开发中，最常用到的内部类就是匿名内部类了。以接口举例，当你使用一个接口时，似乎得做如下几步操作：</p>
<blockquote>
<p>1.定义子类</p>
<p>2.重写接口中的方法</p>
<p>3.创建子类对象</p>
<p>4.调用重写后的方法</p>
<p>我们的目的，最终只是为了调用方法，那么能不能简化一下，把以上四步合成一步呢？匿名内部类就是做这样的快捷方式</p>
</blockquote>
<p><strong style="color:red"> 前提：匿名内部类必须继承一个父类或者实现一个父接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 格式：</span></span><br><span class="line">    <span class="keyword">new</span> 父类名或者接口名()&#123;</span><br><span class="line">        <span class="comment">// 方法重写</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        		<span class="comment">// 执行语句</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyAble</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.等号右边:是匿名内部类，定义并创建该接口的子类对象</span></span><br><span class="line"><span class="comment">        2.等号左边:是多态赋值,接口类型引用指向子类对象</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        FlyAble f = <span class="keyword">new</span> FlyAble()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            		System.out.println(<span class="string">&quot;我飞了~~~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//调用 fly方法,执行重写后的方法</span></span><br><span class="line">        f.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通常方法的形式参数是接口或者抽象类时，也可以将匿名内部类作为参数传递。代码如下：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.等号右边:定义并创建该接口的子类对象</span></span><br><span class="line"><span class="comment">        2.等号左边:是多态,接口类型引用指向子类对象</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        FlyAble f = <span class="keyword">new</span> FlyAble()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            		System.out.println(<span class="string">&quot;我飞了~~~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 将f传递给showFly方法中</span></span><br><span class="line">        showFly(f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showFly</span><span class="params">(FlyAble f)</span> </span>&#123;</span><br><span class="line">        f.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简化上面的写法：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        创建匿名内部类,直接传递给showFly(FlyAble f)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        showFly( <span class="keyword">new</span> FlyAble()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            		System.out.println(<span class="string">&quot;我飞了~~~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showFly</span><span class="params">(FlyAble f)</span> </span>&#123;</span><br><span class="line">    		f.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第四章、引用类型用法总结"><a href="#第四章、引用类型用法总结" class="headerlink" title="第四章、引用类型用法总结"></a>第四章、引用类型用法总结</h1><p>// 实际的开发中，引用类型的使用非常重要，也是非常普遍的。我们可以在理解基本类型的使用方式基础上，进一步去掌握引用类型的使用方式。基本类型可以作为成员变量、作为方法的参数、作为方法的返回值，那么当然引用类型也是可以的<br><strong style="color:red">1）类作为成员变量</strong><br> <strong style="color:green"> 类作为成员变量时，对它进行赋值的操作，实际上，是赋给它该类的一个对象</strong><br><strong style="color:red">2）接口作为成员变量</strong><br> <strong style="color:green"> 接口作为成员变量时，对它进行赋值的操作，实际上，是赋给它该接口的一个子类对象</strong><br><strong style="color:red">3）类作为参数或者返回值</strong><br>  <strong style="color:green">传递的是该类或该类子类的对象</strong><br><strong style="color:red">4）接口作为参数或返回值</strong><br>  传递的是该接口的实现类（子类）对象</p>
<h3 id="扩展：单例设计模式"><a href="#扩展：单例设计模式" class="headerlink" title="扩展：单例设计模式"></a>扩展：单例设计模式</h3><blockquote>
<p>懒汉式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Master</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Master</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">static</span> Master master=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Master <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (master==<span class="keyword">null</span>)&#123;</span><br><span class="line">            master = <span class="keyword">new</span> Master();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> master;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//饿汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">User</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">static</span> User user = <span class="keyword">new</span> User();</span><br><span class="line">    <span class="function"><span class="keyword">static</span> User <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(User.getInstance());</span><br><span class="line">        System.out.println(User.getInstance());</span><br><span class="line"></span><br><span class="line">        System.out.println(Master.getInstance());</span><br><span class="line">        System.out.println(Master.getInstance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</blockquote>
<p><img src="/2021/04/26/day11-final-%E6%9D%83%E9%99%90-%E5%86%85%E9%83%A8%E7%B1%BB-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/image-20210426220647110.png" alt="image-20210426220647110"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>培训学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>day10-接口-多态</title>
    <url>/2021/04/23/day10-%E6%8E%A5%E5%8F%A3-%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<p><strong><em>今日内容：接口、多态</em></strong></p>
<span id="more"></span>

<h1 id="第一章、接口"><a href="#第一章、接口" class="headerlink" title="第一章、接口"></a>第一章、接口</h1><h2 id="1-1、概述"><a href="#1-1、概述" class="headerlink" title="1.1、概述"></a>1.1、概述</h2><p><font style="font-size:20px"><strong><code>1、接口，是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么接口的内部主要就是封装了方法，包含抽象方法（JDK 7及以前），默认方法和静态方法（JDK 8），私有方法（JDK 9）。</code></strong></font></p>
<p><font style="font-size:20px"><strong><code>2、接口的定义，它与定义类方式相似，但是使用 interface 关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。</code></strong></font></p>
<p><font style="font-size:20px"><strong><code>3、接口的使用，它不能创建对象，但是可以被实现（ implements ，类似于被继承）。一个实现接口的类（可以看做是接口的子类），需要实现接口中所有的抽象方法，创建该类对象，就可以调用方法了，否则它必须是一个抽象类。</code></strong></font></p>
<h2 id="1-2、定义格式"><a href="#1-2、定义格式" class="headerlink" title="1.2、定义格式"></a>1.2、定义格式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名称 </span>&#123;</span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="comment">// 默认方法</span></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="comment">// 私有方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 含有抽象方法：抽象方法：使用 abstract 关键字修饰，可以省略，没有方法体。该方法供子类实现使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterFaceName</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 含有默认方法和静态方法</span></span><br><span class="line">		默认方法：使用 <span class="keyword">default</span> 修饰，不可省略，供子类调用或者子类重写。</span><br><span class="line">		静态方法：使用 <span class="keyword">static</span> 修饰，供接口直接调用</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterFaceName</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    		<span class="comment">// 执行语句</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// 执行语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 含有私有方法和私有静态方法：私有方法：使用 private 修饰，供接口中的默认方法或者静态方法调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterFaceName</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    		<span class="comment">// 执行语句</span></span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 执行语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;			</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1-3、基本实现"><a href="#1-3、基本实现" class="headerlink" title="1.3、基本实现"></a>1.3、基本实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类与接口的关系为实现关系，即类实现接口，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 implements 关键字。非抽象子类实现接口：</span></span><br><span class="line">    <span class="number">1.</span> 必须重写接口中所有抽象方法。</span><br><span class="line">    <span class="number">2.</span> 继承了接口的默认方法，即可以直接调用，也可以重写。</span><br><span class="line"><span class="comment">// 实现格式：</span></span><br><span class="line">      <span class="class"><span class="keyword">class</span> 类名 <span class="keyword">implements</span> 接口名 </span>&#123;</span><br><span class="line">          <span class="comment">// 重写接口中抽象方法【必须】</span></span><br><span class="line">          <span class="comment">// 重写接口中默认方法【可选】</span></span><br><span class="line">			&#125;</span><br><span class="line"><span class="comment">//1、 默认方法的使用：可以继承，可以重写，二选一，但是只能通过实现类的对象来调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LiveAble</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">   		 System.out.println(<span class="string">&quot;天上飞&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">LiveAble</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 继承，什么都不用写，直接调用（或者重写也可以，重写默认方法不写 default 关键字）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建子类对象</span></span><br><span class="line">        Animal a = <span class="keyword">new</span> Animal();</span><br><span class="line">        <span class="comment">// 调用默认方法</span></span><br><span class="line">        a.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line">		天上飞</span><br><span class="line"><span class="comment">// 2、私有方法的使用</span></span><br><span class="line">      <span class="number">1.</span>私有方法：只有默认方法可以调用。</span><br><span class="line">	  <span class="number">2.</span>私有静态方法：默认方法和静态方法可以调用</span><br></pre></td></tr></table></figure>

<h2 id="1-4、接口的多实现、多继承"><a href="#1-4、接口的多实现、多继承" class="headerlink" title="1.4、接口的多实现、多继承"></a>1.4、接口的多实现、多继承</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的多实现。并且，一个类能继承一个父类，同时实现多个接口。类只能单一继承，接口可以多实现</span></span><br><span class="line"><span class="comment">// 格式：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 类名 <span class="keyword">implements</span> 接口名1,接口名2,接口名3... </span>&#123;</span><br><span class="line">    <span class="comment">// 重写接口中抽象方法【必须】</span></span><br><span class="line">    <span class="comment">// 重写接口中默认方法【不重名时可选】</span></span><br><span class="line">&#125;		</span><br><span class="line"><span class="class"><span class="keyword">class</span> 类名 <span class="keyword">extends</span> 父类 <span class="keyword">implements</span> 接口名1,接口名2,接口名3... </span>&#123;</span><br><span class="line">    <span class="comment">// 重写接口中抽象方法【必须】</span></span><br><span class="line">    <span class="comment">// 重写接口中默认方法【不重名时可选】</span></span><br><span class="line">&#125;		</span><br><span class="line"><span class="comment">// ⚠️注意：</span></span><br><span class="line">	<span class="number">1.</span>如果默认方法有重名的，必须重写一次</span><br><span class="line">    <span class="number">2.</span>当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类					的成员方法</span><br><span class="line">    <span class="number">3.</span>一个接口能继承另一个或者多个接口，这和类之间的继承比较相似。接口的继承使用 extends 关键字，子接口继承父接				口的方法。如果父接口中的默认方法有重名的，那么子接口需要重写一次</span><br><span class="line">    <span class="number">4.</span>子接口重写默认方法时，<span class="keyword">default</span>关键字可以保留。</span><br><span class="line">    <span class="number">5.</span>子类重写默认方法时，<span class="keyword">default</span>关键字不可以保留</span><br></pre></td></tr></table></figure>

<h2 id="1-5、其他成员特点"><a href="#1-5、其他成员特点" class="headerlink" title="1.5、其他成员特点"></a>1.5、其他成员特点</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>接口中，无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span>修饰。</span><br><span class="line"><span class="number">2.</span>接口中，没有构造方法，不能创建对象。</span><br><span class="line"><span class="number">3.</span>接口中，没有静态代码块。</span><br></pre></td></tr></table></figure>

<h1 id="第二章、多态"><a href="#第二章、多态" class="headerlink" title="第二章、多态"></a>第二章、多态</h1><h2 id="2-1、概述"><a href="#2-1、概述" class="headerlink" title="2.1、概述"></a>2.1、概述</h2><p><font style="font-size:20px"><code>生活中，比如跑的动作，小猫、小狗和大象，跑起来是不一样的。再比如飞的动作，昆虫、鸟类和飞机，飞起来也是不一样的。可见，同一行为，通过不同的事物，可以体现出来的不同的形态。多态，描述的就是这样的状态</code></font><br>// 定义：<br><strong style="color:red">多态： 是指同一行为，具有多个不同表现形式</strong><br><strong style="color:red">多态是封装、继承之后，面向对象的第三大特性</strong> </p>
<p><strong style="color:red">多态的前提：（重点）</strong></p>
<ol>
<li><strong>继承或者实现【二选一】</strong></li>
<li><strong>方法的重写【意义体现：不重写，无意义】</strong></li>
<li><strong>父类引用指向子类对象【格式体现】</strong>    </li>
</ol>
<h2 id="2-2、多态的体现"><a href="#2-2、多态的体现" class="headerlink" title="2.2、多态的体现"></a>2.2、多态的体现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类类型：指子类对象继承的父类类型，或者实现的父接口类型</span></span><br><span class="line">父类类型 变量名 = <span class="keyword">new</span> 子类对象； </span><br><span class="line">变量名.方法名();</span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">    Fu f = <span class="keyword">new</span> Zi();</span><br><span class="line">    f.method();</span><br><span class="line">⚠️注意 当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后法</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   		 System.out.println(<span class="string">&quot;吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    		System.out.println(<span class="string">&quot;吃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 多态形式，创建对象</span></span><br><span class="line">        Animal a1 = <span class="keyword">new</span> Cat();</span><br><span class="line">        <span class="comment">// 调用的是 Cat 的 eat</span></span><br><span class="line">        a1.eat();</span><br><span class="line">        <span class="comment">// 多态形式，创建对象</span></span><br><span class="line">        Animal a2 = <span class="keyword">new</span> Dog();</span><br><span class="line">        <span class="comment">// 调用的是 Dog 的 eat</span></span><br><span class="line">        a2.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3、多态的好处"><a href="#2-3、多态的好处" class="headerlink" title="2.3、多态的好处"></a>2.3、多态的好处</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展性与便利</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      	System.out.println(<span class="string">&quot;吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    		System.out.println(<span class="string">&quot;吃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 多态形式，创建对象</span></span><br><span class="line">        Cat c = <span class="keyword">new</span> Cat();</span><br><span class="line">        Dog d = <span class="keyword">new</span> Dog();</span><br><span class="line">        <span class="comment">// 调用showCatEat</span></span><br><span class="line">        showCatEat(c);</span><br><span class="line">        <span class="comment">// 调用showDogEat</span></span><br><span class="line">        showDogEat(d);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        以上两个方法, 均可以被showAnimalEat(Animal a)方法所替代</span></span><br><span class="line"><span class="comment">        而执行效果一致</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        showAnimalEat(c);</span><br><span class="line">        showAnimalEat(d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showCatEat</span> <span class="params">(Cat c)</span></span>&#123;</span><br><span class="line">    		c.eat();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showDogEat</span> <span class="params">(Dog d)</span></span>&#123;</span><br><span class="line">    		d.eat();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showAnimalEat</span> <span class="params">(Animal a)</span></span>&#123;</span><br><span class="line">    		a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分析：由于多态特性的支持，showAnimalEat方法的Animal类型，是Cat和Dog的父类类型，父类类型接收子类对象，当然可以把Cat对象和Dog对象，传递给方法。当eat方法执行时，多态规定，执行的是子类重写的方法，那么效果自然与showCatEat、showDogEat方法一致，所以showAnimalEat完全可以替代以上两方法。不仅仅是替代，在扩展性方面，无论之后再多的子类出现，我们都不需要编写showXxxEat方法了，直接使用showAnimalEat都可以完成。</span></span><br></pre></td></tr></table></figure>

<p><strong style="color:red">⚠️多态的好处：体现在，可以使程序编写的更简单，并有良好的扩展</strong></p>
<h2 id="2-4、引用类型转换"><a href="#2-4、引用类型转换" class="headerlink" title="2.4、引用类型转换"></a>2.4、引用类型转换</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向上转型：多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。</span></span><br><span class="line"><span class="comment">// 示例：当父类引用指向一个子类对象时，便是向上转型</span></span><br><span class="line">    父类类型 变量名 = <span class="keyword">new</span> 子类类型();</span><br><span class="line">    如：Animal a = <span class="keyword">new</span> Cat();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向下转型：父类类型向子类类型向下转换的过程，这个过程是强制的</span></span><br><span class="line"><span class="comment">// 示例：一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型</span></span><br><span class="line">    子类类型 变量名 = (子类类型) 父类变量名;</span><br><span class="line">    如:Cat c = (Cat) a;</span><br><span class="line"><span class="comment">// 练习1</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    		System.out.println(<span class="string">&quot;吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">catchMouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    		System.out.println(<span class="string">&quot;抓老鼠&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    		System.out.println(<span class="string">&quot;吃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watchHouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    		System.out.println(<span class="string">&quot;看家&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 向上转型</span></span><br><span class="line">        Animal a = <span class="keyword">new</span> Cat();</span><br><span class="line">        a.eat(); <span class="comment">// 调用的是 Cat 的 eat</span></span><br><span class="line">        <span class="comment">// 向下转型</span></span><br><span class="line">        Cat c = (Cat)a;</span><br><span class="line">        c.catchMouse(); <span class="comment">// 调用的是 Cat 的 catchMouse</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 练习2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 向上转型</span></span><br><span class="line">        Animal a = <span class="keyword">new</span> Cat();</span><br><span class="line">        a.eat(); <span class="comment">// 调用的是 Cat 的 eat</span></span><br><span class="line">        <span class="comment">// 向下转型</span></span><br><span class="line">        Dog d = (Dog)a;</span><br><span class="line">        d.watchHouse(); <span class="comment">// 调用的是 Dog 的 watchHouse 【运行报错】</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分析：这段代码可以通过编译，但是运行时，却报出了 ClassCastException ，类型转换异常！这是因为，明明创建了Cat类型对象，运行时，当然不能转换成Dog对象的。这两个类型并没有任何继承关系，不符合类型转换的定义。为了避免ClassCastException的发生，Java提供了 instanceof 关键字，给引用变量做类型的校验，格式如下</span></span><br><span class="line">  变量名 <span class="keyword">instanceof</span> 数据类型</span><br><span class="line">  如果变量属于该数据类型，返回<span class="keyword">true</span>。</span><br><span class="line">  如果变量不属于该数据类型，返回<span class="keyword">false</span>。</span><br><span class="line"><span class="comment">// 修改如下：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 向上转型</span></span><br><span class="line">            Animal a = <span class="keyword">new</span> Cat();</span><br><span class="line">            a.eat(); <span class="comment">// 调用的是 Cat 的 eat</span></span><br><span class="line">            <span class="comment">// 向下转型</span></span><br><span class="line">            <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Cat)&#123;</span><br><span class="line">                Cat c = (Cat)a;</span><br><span class="line">                c.catchMouse(); <span class="comment">// 调用的是 Cat 的 catchMouse</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Dog)&#123;</span><br><span class="line">                Dog d = (Dog)a;</span><br><span class="line">                d.watchHouse(); <span class="comment">// 调用的是 Dog 的 watchHouse</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>培训学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>day09-继承-重写-super-抽象类</title>
    <url>/2021/04/22/day09-%E7%BB%A7%E6%89%BF-%E9%87%8D%E5%86%99-super-%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
    <content><![CDATA[<p><strong><em>今日内容：继承、重写、抽象类</em></strong></p>
<span id="more"></span>

<h1 id="第一章、继承"><a href="#第一章、继承" class="headerlink" title="第一章、继承"></a>第一章、继承</h1><h2 id="1-1、概述"><a href="#1-1、概述" class="headerlink" title="1.1、概述"></a>1.1、概述</h2><p>由来：多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那一个类即可，其中，多个类可以称为子类，单独那一个类称为父类、超类（superclass）或者基类。继承描述的是事物之间的所属关系，这种关系是： is-a 的关系。例如，图中兔子属于食草动物，食草动物属于动物。可见，父类更通用，子类更具体。我们通过继承，可以使多种事物之间形成一种关系体系。</p>
<img src="/2021/04/22/day09-%E7%BB%A7%E6%89%BF-%E9%87%8D%E5%86%99-super-%E6%8A%BD%E8%B1%A1%E7%B1%BB/2019-12-15_01-56-53.jpg" alt="2019-12-15_01-56-53" style="zoom:50%;">

<p>// 定义<br>继承：就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为<br>// 好处</p>
<p><strong style="color:red">1 .提高代码的复用性。</strong></p>
<p><strong style="color:red">2.类与类之间产生了关系，是多态的前提。</strong></p>
<h2 id="1-2、格式"><a href="#1-2、格式" class="headerlink" title="1.2、格式"></a>1.2、格式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 extends 关键字，可以声明一个子类继承另外一个父类，定义格式如下：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 父类 </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类 </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">  <span class="comment">// 定义员工类Employee，做为父类</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">      String name; <span class="comment">// 定义name属性</span></span><br><span class="line">      <span class="comment">// 定义员工的工作方法</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;尽心尽力地工作&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义讲师类Teacher 继承 员工类Employee</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 定义一个打印name的方法</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      		System.out.println(<span class="string">&quot;name=&quot;</span> + name);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 测试类</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendDemo01</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 创建一个讲师类对象</span></span><br><span class="line">      Teacher t = <span class="keyword">new</span> Teacher();</span><br><span class="line">      <span class="comment">// 为该员工类的name属性进行赋值</span></span><br><span class="line">      t.name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">      <span class="comment">// 调用该员工的printName()方法</span></span><br><span class="line">      t.printName(); <span class="comment">// name = 小明</span></span><br><span class="line">      <span class="comment">// 调用Teacher类继承来的work()方法</span></span><br><span class="line">      t.work(); <span class="comment">// 尽心尽力地工作</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3、继承的特点—成员变量"><a href="#1-3、继承的特点—成员变量" class="headerlink" title="1.3、继承的特点—成员变量"></a>1.3、继承的特点—成员变量</h2><h3 id="1-3-1、成员变量重名"><a href="#1-3-1、成员变量重名" class="headerlink" title="1.3.1、成员变量重名"></a>1.3.1、成员变量重名</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果子类父类中出现重名的成员变量，这时的访问是有影响的。代码如下</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Fu中的成员变量。</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Zi中的成员变量</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">6</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 访问父类中的num</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Fu num=&quot;</span> + num);</span><br><span class="line">        <span class="comment">// 访问子类中的num</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Zi num=&quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建子类对象</span></span><br><span class="line">        Zi z = <span class="keyword">new</span> Zi();</span><br><span class="line">        <span class="comment">// 调用子类中的show方法</span></span><br><span class="line">        z.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 演示结果：</span></span><br><span class="line">    Fu num = <span class="number">6</span></span><br><span class="line">    Zi num = <span class="number">6</span>	</span><br><span class="line"><span class="comment">// 分析：子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用 super 关键字，修饰父类成员变量，类似于之前学过的 this </span></span><br><span class="line"><span class="comment">// 格式：</span></span><br><span class="line">    <span class="keyword">super</span>.父类成员变量名</span><br><span class="line"><span class="comment">// 示例：修改子类方法</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Zi中的成员变量</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">6</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//访问父类中的num</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Fu num=&quot;</span> + <span class="keyword">super</span>.num);</span><br><span class="line">            <span class="comment">//访问子类中的num</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Zi num=&quot;</span> + <span class="keyword">this</span>.num);</span><br><span class="line">        &#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line">    Fu num = <span class="number">5</span></span><br><span class="line">    Zi num = <span class="number">6</span>	</span><br><span class="line">      </span><br><span class="line">⚠️注意：Fu 类中的成员变量是非私有的，子类中可以直接访问。若Fu 类中的成员变量私有了，子类是不能直接访问的。通常编码时，我们遵循封装的原则，使用<span class="keyword">private</span>修饰成员变量，那么如何访问父类的私有成员变量呢？对！可以在父类中提供公共的getXxx方法和setXxx方法</span><br></pre></td></tr></table></figure>

<h3 id="1-3-2、成员变量不重名"><a href="#1-3-2、成员变量不重名" class="headerlink" title="1.3.2、成员变量不重名"></a>1.3.2、成员变量不重名</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果子类父类中出现不重名的成员变量，这时的访问是没有影响的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Fu中的成员变量。</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Zi中的成员变量</span></span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// Zi中的成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 访问父类中的num，</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Fu num=&quot;</span>+num); <span class="comment">// 继承而来，所以直接访问。</span></span><br><span class="line">        <span class="comment">// 访问子类中的num2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Zi num2=&quot;</span>+num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建子类对象</span></span><br><span class="line">        Zi z = <span class="keyword">new</span> Zi();</span><br><span class="line">        <span class="comment">// 调用子类中的show方法</span></span><br><span class="line">        z.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 演示结果：</span></span><br><span class="line">    Fu num = <span class="number">5</span></span><br><span class="line">    Zi num2 = <span class="number">6</span></span><br></pre></td></tr></table></figure>

<h2 id="1-4、继承的特点—成员方法"><a href="#1-4、继承的特点—成员方法" class="headerlink" title="1.4、继承的特点—成员方法"></a>1.4、继承的特点—成员方法</h2><h3 id="1-4-1、成员方法不重名"><a href="#1-4-1、成员方法不重名" class="headerlink" title="1.4.1、成员方法不重名"></a>1.4.1、成员方法不重名</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果子类父类中出现不重名的成员方法，这时的调用是没有影响的。对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。代码如下：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    		System.out.println(<span class="string">&quot;Fu类中的show方法执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    		System.out.println(<span class="string">&quot;Zi类中的show2方法执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo04</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Zi z = <span class="keyword">new</span> Zi();</span><br><span class="line">        <span class="comment">//子类中没有show方法，但是可以找到父类方法去执行</span></span><br><span class="line">        z.show();</span><br><span class="line">        z.show2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;		</span><br></pre></td></tr></table></figure>

<h3 id="1-4-2、成员方法重名—重写"><a href="#1-4-2、成员方法重名—重写" class="headerlink" title="1.4.2、成员方法重名—重写"></a>1.4.2、成员方法重名—重写</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果子类父类中出现重名的成员方法，这时的访问是一种特殊情况，叫做方法重写 (Override)。</span></span><br><span class="line"><span class="comment">// 方法重写 ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。声明不变，重新实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    		System.out.println(<span class="string">&quot;Fu show&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="comment">//子类重写了父类的show方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   		 	System.out.println(<span class="string">&quot;Zi show&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo05</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Zi z = <span class="keyword">new</span> Zi();</span><br><span class="line">        <span class="comment">// 子类中有show方法，只执行重写后的show方法</span></span><br><span class="line">        z.show(); <span class="comment">// Zi show</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;		</span><br></pre></td></tr></table></figure>

<h3 id="1-4-3、重写的应用"><a href="#1-4-3、重写的应用" class="headerlink" title="1.4.3、重写的应用"></a>1.4.3、重写的应用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子类可以根据需要，定义特定于自己的行为。既沿袭了父类的功能名称，又根据子类的需要重新实现父类方法，从而进行扩展增强。比如新的手机增加来电显示头像的功能，代码如下：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    		System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">    		System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    		System.out.println(<span class="string">&quot;来电显示号码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;		</span><br><span class="line"><span class="comment">//智能手机类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="comment">//重写父类的来电显示号码功能，并增加自己的显示姓名和图片功能</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//调用父类已经存在的功能使用super</span></span><br><span class="line">        <span class="keyword">super</span>.showNum();</span><br><span class="line">        <span class="comment">//增加自己特有显示姓名和图片功能</span></span><br><span class="line">        System.out.println(<span class="string">&quot;显示来电姓名&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;显示头像&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建子类对象</span></span><br><span class="line">        NewPhone np = <span class="keyword">new</span> NewPhone()；</span><br><span class="line">        <span class="comment">// 调用父类继承而来的方法</span></span><br><span class="line">        np.call();</span><br><span class="line">        <span class="comment">// 调用子类重写的方法</span></span><br><span class="line">    	np.showNum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意：这里重写时，用到super.父类成员方法，表示调用父类的成员方法</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-4、注意事项"><a href="#1-4-4、注意事项" class="headerlink" title="1.4.4、注意事项"></a>1.4.4、注意事项</h3><p><strong style="color:red">1.子类方法覆盖父类方法，必须要保证权限大于等于父类权限</strong><br><strong style="color:red">2.子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样</strong><br><strong style="color:green">思考题：重载和重写的区别？</strong></p>
<blockquote>
<p><strong>重载(Overloading)</strong><br>方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。重载Overloading是一个类中多态性的一种表现。</p>
<p>Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。</p>
<p>调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。</p>
<p>重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回值类型作为重载函数的区分标准。</p>
<p>父类方法被默认修饰时，只能在同一包中，被其子类重写，如果不在同一包则不能重写。</p>
<p>父类的方法被protoeted时，不仅在同一包中，被其子类重写，还可以不同包的子类重写。</p>
<p><strong>重载的规则</strong><br>必须具有不同的参数列表；<br>可以有不同的返回类型，只要参数列表不同就可以了；<br>可以有不同的访问修饰符；<br>可以抛出不同的异常；</p>
<p><strong>重写方法的规则</strong><br>参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载。<br>返回的类型必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载。<br>访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private）<br>重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。例如：父类的一个方法申明了一个检查异常IOException，在重写这个方法是就不能抛出Exception,只能抛出IOException的子类异常，可以抛出非检查异常。</p>
<p><strong>重载和重写（覆盖）的特点</strong><br><strong>Overload 特点</strong><br>在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是fun(int, float)， 但是不能为fun(int, int)）；<br>不能通过访问权限、返回类型、抛出的异常进行重载；<br>方法的异常类型和数目不会对重载造成影响；<br>对于继承来说，如果某一方法在父类中是访问权限是priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。</p>
<p><strong>Override 特点</strong><br>覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；<br>覆盖的方法的返回值必须和被覆盖的方法的返回一致；<br>覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；<br>被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。</p>
<p><strong style="color:green">总结:</strong><br><strong>overload（重载）</strong><br>参数类型、个数、顺序至少有一个不相同。<br>不能重载只有返回值不同的方法名。<br>存在于父类和子类、同类中。</p>
<p><strong>override（重写）</strong><br>方法名、参数、返回值相同。<br>子类方法不能缩小父类方法的访问权限。<br>子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。<br>存在于父类和子类之间。<br>方法被定义为final不能被重写。</p>
</blockquote>
<h2 id="1-5、继承的特点—构造方法"><a href="#1-5、继承的特点—构造方法" class="headerlink" title="1.5、继承的特点—构造方法"></a>1.5、继承的特点—构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。</span><br><span class="line"><span class="number">2.</span> 构造方法的作用是初始化成员变量的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认有一个 <span class="keyword">super</span>() ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。代码如下：</span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    Fu()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Fu()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    Zi()&#123;</span><br><span class="line">        <span class="comment">// super（），调用父类构造方法</span></span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    	System.out.println(<span class="string">&quot;Zi（）&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo07</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    		Zi zi = <span class="keyword">new</span> Zi();</span><br><span class="line">        	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line">		Fu（）</span><br><span class="line">		Zi（）</span><br></pre></td></tr></table></figure>

<h2 id="1-6、super和this"><a href="#1-6、super和this" class="headerlink" title="1.6、super和this"></a>1.6、super和this</h2><h3 id="1-6-1、super和this的含义"><a href="#1-6-1、super和this的含义" class="headerlink" title="1.6.1、super和this的含义"></a>1.6.1、super和this的含义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">super</span> ：代表父类的存储空间标识(可以理解为父亲的引用)。</span><br><span class="line"><span class="keyword">this</span>  ：代表当前对象的引用(谁调用就代表谁)</span><br></pre></td></tr></table></figure>

<h3 id="1-6-2、super和this的用法"><a href="#1-6-2、super和this的用法" class="headerlink" title="1.6.2、super和this的用法"></a>1.6.2、super和this的用法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 访问成员</span><br><span class="line">    <span class="keyword">this</span>.成员变量 ‐‐ 本类的</span><br><span class="line">    <span class="keyword">super</span>.成员变量 ‐‐ 父类的</span><br><span class="line">    <span class="keyword">this</span>.成员方法名() ‐‐ 本类的</span><br><span class="line">    <span class="keyword">super</span>.成员方法名() ‐‐ 父类的</span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    		System.out.println(<span class="string">&quot;animal : eat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    		System.out.println(<span class="string">&quot;cat : eat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eatTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.eat(); <span class="comment">// this 调用本类的方法</span></span><br><span class="line">        <span class="keyword">super</span>.eat(); <span class="comment">// super 调用父类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo08</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal a = <span class="keyword">new</span> Animal();</span><br><span class="line">        a.eat();</span><br><span class="line">        Cat c = <span class="keyword">new</span> Cat();</span><br><span class="line">        c.eatTest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果为：</span></span><br><span class="line">    animal : eat</span><br><span class="line">    cat 	 : eat</span><br><span class="line">    animal : eat</span><br><span class="line"><span class="number">2.</span> 访问构造方法</span><br><span class="line">    <span class="keyword">this</span>(...) ‐‐ 本类的构造方法</span><br><span class="line">	<span class="keyword">super</span>(...) ‐‐ 父类的构造方法</span><br><span class="line">      </span><br><span class="line">⚠️注意：子类的每个构造方法中均有默认的<span class="keyword">super</span>()，调用父类的空参构造。手动调用父类构造会覆盖默认的<span class="keyword">super</span>()。				       <span class="keyword">super</span>() 和 <span class="keyword">this</span>() 都必须是在构造方法的第一行，所以不能同时出现</span><br></pre></td></tr></table></figure>

<h2 id="1-7、继承总结"><a href="#1-7、继承总结" class="headerlink" title="1.7、继承总结"></a>1.7、继承总结</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> Java只支持单继承，不支持多重继承。</span><br><span class="line">  <span class="comment">//一个类只能有一个父类，不可以有多个父类。</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125; <span class="comment">//ok</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span>，<span class="title">B</span>... //<span class="title">error</span></span></span><br><span class="line"><span class="class">2. <span class="title">Java</span>支持多层继承(继承体系)</span></span><br><span class="line"><span class="class">      <span class="title">class</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line">      <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line">      <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;&#125;</span><br><span class="line"><span class="number">3.</span> 子类和父类是一种相对的概念</span><br><span class="line">  </span><br><span class="line">⚠️注意：顶层父类是Object类。所有的类默认继承Object，作为父类</span><br></pre></td></tr></table></figure>

<h1 id="第二章、抽象类"><a href="#第二章、抽象类" class="headerlink" title="第二章、抽象类"></a>第二章、抽象类</h1><h2 id="2-1、概述"><a href="#2-1、概述" class="headerlink" title="2.1、概述"></a>2.1、概述</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由来：父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了。我们把没有方法主体的方法称为抽象方法。Java语法规定，包含抽象方法的类就是抽象类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义：</span></span><br><span class="line">		抽象方法 ： 没有方法体的方法</span><br><span class="line">		抽象类：包含抽象方法的类</span><br></pre></td></tr></table></figure>

<h2 id="2-2、格式：abstract"><a href="#2-2、格式：abstract" class="headerlink" title="2.2、格式：abstract"></a>2.2、格式：abstract</h2><h3 id="2-2-1、抽象方法"><a href="#2-2-1、抽象方法" class="headerlink" title="2.2.1、抽象方法"></a>2.2.1、抽象方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 abstract 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体</span></span><br><span class="line"><span class="comment">// 格式：修饰符 abstract 返回值类型 方法名 (参数列表)；</span></span><br><span class="line"><span class="comment">// 示例：public abstract void run();</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-2、抽象类"><a href="#2-2-2、抽象类" class="headerlink" title="2.2.2、抽象类"></a>2.2.2、抽象类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果一个类包含抽象方法，那么该类必须是抽象类</span></span><br><span class="line"><span class="comment">// 格式：</span></span><br><span class="line">		<span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名字 </span>&#123;</span><br><span class="line">				......</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    		<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function">    &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-3、抽象的使用"><a href="#2-2-3、抽象的使用" class="headerlink" title="2.2.3、抽象的使用"></a>2.2.3、抽象的使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该父类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    		System.out.println(<span class="string">&quot;小猫在墙头走~~~&quot;</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建子类对象</span></span><br><span class="line">        Cat c = <span class="keyword">new</span> Cat();</span><br><span class="line">        <span class="comment">// 调用run方法</span></span><br><span class="line">        c.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line">		小猫在墙头走~~~</span><br><span class="line"><span class="comment">// 此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做实现方法</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3、注意事项"><a href="#2-3、注意事项" class="headerlink" title="2.3、注意事项"></a>2.3、注意事项</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。</span><br><span class="line">		理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</span><br><span class="line">  </span><br><span class="line"><span class="number">2.</span> 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。</span><br><span class="line">  	理解：子类的构造方法中，有默认的<span class="keyword">super</span>()，需要访问父类构造方法。</span><br><span class="line">  </span><br><span class="line"><span class="number">3.</span> 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</span><br><span class="line">  	理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。</span><br><span class="line">  </span><br><span class="line"><span class="number">4.</span> 抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。</span><br><span class="line">	理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</span><br></pre></td></tr></table></figure>

<h1 id="第三章、继承的综合案例"><a href="#第三章、继承的综合案例" class="headerlink" title="第三章、继承的综合案例"></a>第三章、继承的综合案例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需求：群主发普通红包。某群有多名成员，群主给成员发普通红包。普通红包的规则：</span></span><br><span class="line">    <span class="number">1.</span> 群主的一笔金额，从群主余额中扣除，平均分成n等份，让成员领取。</span><br><span class="line">    <span class="number">2.</span> 成员领取红包后，保存到成员余额中。</span><br><span class="line"><span class="comment">// 请根据描述，完成案例中所有类的定义以及指定类之间的继承关系，并完成发红包的操作</span></span><br></pre></td></tr></table></figure>

<img src="/2021/04/22/day09-%E7%BB%A7%E6%89%BF-%E9%87%8D%E5%86%99-super-%E6%8A%BD%E8%B1%A1%E7%B1%BB/2019-12-15_13-58-20.jpg" alt="2019-12-15_13-58-20" style="zoom:50%;">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码实现：</span></span><br><span class="line"><span class="comment">// 定义User类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String username; <span class="comment">// 用户名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> leftMoney; <span class="comment">// 余额</span></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, <span class="keyword">double</span> leftMoney)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.leftMoney = leftMoney;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// get/set方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    		<span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">    		<span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getLeftMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    		<span class="keyword">return</span> leftMoney;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftMoney</span><span class="params">(<span class="keyword">double</span> leftMoney)</span> </span>&#123;</span><br><span class="line">    		<span class="keyword">this</span>.leftMoney = leftMoney;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 展示信息的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    		System.out.println(<span class="string">&quot;用户名:&quot;</span>+ username +<span class="string">&quot; , 余额为:&quot;</span> + leftMoney + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义群主</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QunZhu</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QunZhu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QunZhu</span><span class="params">(String username, <span class="keyword">double</span> leftMoney)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过super 调用父类构造方法</span></span><br><span class="line">        <span class="keyword">super</span>(username, leftMoney);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    群主发红包，就是把一个整数的金额，分层若干等份。</span></span><br><span class="line"><span class="comment">    1.获取群主余额,是否够发红包.</span></span><br><span class="line"><span class="comment">    不能则返回null,并提示.</span></span><br><span class="line"><span class="comment">    能则继续.</span></span><br><span class="line"><span class="comment">    2.修改群主余额.</span></span><br><span class="line"><span class="comment">    3.拆分红包.</span></span><br><span class="line"><span class="comment">    3.1.如果能整除，那么就平均分。</span></span><br><span class="line"><span class="comment">    3.2.如果不能整除，那么就把余数分给最后一份。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Double&gt; <span class="title">send</span><span class="params">(<span class="keyword">int</span> money, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取群主余额</span></span><br><span class="line">        <span class="keyword">double</span> leftMoney = getLeftMoney();</span><br><span class="line">        <span class="keyword">if</span>(money &gt; leftMoney) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// 修改群主余额的</span></span><br><span class="line">    setLeftMoney(leftMoney ‐ money);</span><br><span class="line">    <span class="comment">// 创建一个集合,保存等份金额</span></span><br><span class="line">    ArrayList&lt;Double&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 扩大100倍,相当于折算成&#x27;分&#x27;为单位,避免小数运算损失精度的问题</span></span><br><span class="line">    money = money * <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 每份的金额</span></span><br><span class="line">    <span class="keyword">int</span> m = money / count;</span><br><span class="line">    <span class="comment">// 不能整除的余数</span></span><br><span class="line">    <span class="keyword">int</span> l = money % count;</span><br><span class="line">    <span class="comment">// 无论是否整除,n‐1份,都是每份的等额金额</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count ‐ <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 缩小100倍,折算成 &#x27;元&#x27;</span></span><br><span class="line">        list.add(m / <span class="number">100.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否整除</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 能整除, 最后一份金额,与之前每份金额一致</span></span><br><span class="line">        list.add(m / <span class="number">100.0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不能整除, 最后一份的金额,是之前每份金额+余数金额</span></span><br><span class="line">        list.add((m + l) / <span class="number">100.00</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回集合</span></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义普通人</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Member</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Member</span><span class="params">(String username, <span class="keyword">double</span> leftMoney)</span> </span>&#123;</span><br><span class="line">    		<span class="keyword">super</span>(username, leftMoney);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打开红包,就是从集合中,随机取出一份,保存到自己的余额中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openHongbao</span><span class="params">(ArrayList&lt;Double&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Random对象</span></span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">// 随机生成一个角标</span></span><br><span class="line">        <span class="keyword">int</span> index = r.nextInt(list.size());</span><br><span class="line">        <span class="comment">// 移除一个金额</span></span><br><span class="line">      	Double money = list.remove(index);</span><br><span class="line">        <span class="comment">// 直接调用父类方法,设置到余额</span></span><br><span class="line">        setLeftMoney( money );</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个群主对象</span></span><br><span class="line">        QunZhu qz = <span class="keyword">new</span> QunZhu(<span class="string">&quot;群主&quot;</span> , <span class="number">200</span>);</span><br><span class="line">        <span class="comment">// 创建一个键盘录入</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入金额:&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> money = sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入个数:&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> count = sc.nextInt();</span><br><span class="line">        <span class="comment">// 发送红包</span></span><br><span class="line">        ArrayList&lt;Double&gt; sendList = qz.send(money,count);</span><br><span class="line">        <span class="comment">// 判断,如果余额不足</span></span><br><span class="line">        <span class="keyword">if</span>(sendList == <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; 余额不足...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建三个成员</span></span><br><span class="line">        Member m = <span class="keyword">new</span> Member();</span><br><span class="line">        Member m2 = <span class="keyword">new</span> Member();</span><br><span class="line">        Member m3 = <span class="keyword">new</span> Member();</span><br><span class="line">        <span class="comment">// 打开红包</span></span><br><span class="line">        m.openHongbao(sendList);</span><br><span class="line">        m2.openHongbao(sendList);</span><br><span class="line">        m3.openHongbao(sendList);</span><br><span class="line">        <span class="comment">// 展示信息</span></span><br><span class="line">        qz.show();</span><br><span class="line">        m.show();</span><br><span class="line">        m2.show();</span><br><span class="line">        m3.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 思考题：</span></span><br><span class="line">	<span class="number">1.</span>如果成员余额不为<span class="number">0</span>呢？</span><br><span class="line">  	<span class="number">2.</span>如果群主想输入带小数的额度呢？</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>培训学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>day08-命令行实现简单的用户管理系统</title>
    <url>/2021/04/19/day08-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p><strong><em>今日内容：写一个用命令行控制的简单的用户管理系统</em></strong></p>
<span id="more"></span>

<h3 id="主测试函数：Demo03"><a href="#主测试函数：Demo03" class="headerlink" title="主测试函数：Demo03"></a>主测试函数：Demo03</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> entity.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;User&gt; list = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> User(<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;123&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> User(<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;123&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> Scanner scanner=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请选择：1.登录     2.注册&quot;</span>);</span><br><span class="line">        showUI();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showUI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = scanner.nextInt();</span><br><span class="line">        <span class="keyword">switch</span> (temp)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                goLogin();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                goRegister();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;输入错误，请重新输入！&quot;</span>);</span><br><span class="line">                showUI();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">goRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入用户名：&quot;</span>);</span><br><span class="line">        String username = scanner.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入密码：&quot;</span>);</span><br><span class="line">        String password = scanner.next();</span><br><span class="line">        <span class="keyword">boolean</span> bool = isExist(username);</span><br><span class="line">        <span class="keyword">if</span> (bool)&#123;</span><br><span class="line">            System.out.println(username+ <span class="string">&quot;用户已存在，重新输入!&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            User user = <span class="keyword">new</span> User();</span><br><span class="line">            user.setUsername(username);</span><br><span class="line">            user.setPassword(password);</span><br><span class="line">            list.add(user);</span><br><span class="line">            System.out.println(<span class="string">&quot;注册成功！&quot;</span>);</span><br><span class="line">            goLogin();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">goLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入用户名：&quot;</span>);</span><br><span class="line">        String username = scanner.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入密码：&quot;</span>);</span><br><span class="line">        String password = scanner.next();</span><br><span class="line">        <span class="keyword">boolean</span> bool = isExist(username);</span><br><span class="line">        <span class="keyword">if</span> (bool)&#123;</span><br><span class="line">            <span class="comment">//登录成功，进入首页</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                User user = list.get(i);</span><br><span class="line">                <span class="keyword">if</span> (user.getPassword().equals(password))&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;登陆成功！&quot;</span>);</span><br><span class="line">                    goHome();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;用户名或密码错误！\n&quot;</span>);</span><br><span class="line">                    goLogin();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户名或密码错误！\n&quot;</span>);</span><br><span class="line">            goLogin();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">goHome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n 首页&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;序号 \t 用户名 \t 密码&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请选择功能：1.添加    2.删除   3.修改   4.退出&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> temp = scanner.nextInt();</span><br><span class="line">        <span class="keyword">switch</span> (temp)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: addUser();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: deleteUser();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: updateUser();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>: System.exit(<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;输入有误！&quot;</span>);</span><br><span class="line">                goHome();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n 添加用户：&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入你要添加的用户名：&quot;</span>);</span><br><span class="line">        String username = scanner.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入您的密码：&quot;</span>);</span><br><span class="line">        String password = scanner.next();</span><br><span class="line">        <span class="keyword">boolean</span> bool = isExist(username);</span><br><span class="line">        <span class="keyword">if</span> (bool)&#123;</span><br><span class="line">            System.out.println(username+ <span class="string">&quot;用户已存在，重新输入!&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            User user = <span class="keyword">new</span> User();</span><br><span class="line">            user.setUsername(username);</span><br><span class="line">            user.setPassword(password);</span><br><span class="line">            list.add(user);</span><br><span class="line">            System.out.println(<span class="string">&quot;添加成功！&quot;</span>);</span><br><span class="line">            goHome();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改用户信息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n 修改用户密码：&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入您要修改的用户的用户名：&quot;</span>);</span><br><span class="line">        String username = scanner.next();</span><br><span class="line">        <span class="keyword">boolean</span> bool = isExist(username);</span><br><span class="line">        <span class="keyword">if</span> (bool)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入您的新密码！&quot;</span>);</span><br><span class="line">            String password = scanner.next();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                User user = list.get(i);</span><br><span class="line">                <span class="keyword">if</span> (username.equals(user.getUsername()))&#123;</span><br><span class="line">                    user.setPassword(password);</span><br><span class="line">                    System.out.println(<span class="string">&quot;修改成功！&quot;</span>);</span><br><span class="line">                    goHome();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;该用户不存在！&quot;</span>);</span><br><span class="line">            goHome();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除用户信息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n 删除用户信息：&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入您要删除的用户的用户名：&quot;</span>);</span><br><span class="line">        String username = scanner.next();</span><br><span class="line">        <span class="keyword">boolean</span> bool = isExist(username);</span><br><span class="line">        <span class="keyword">if</span> (bool)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;您确定要删除用户&quot;</span>+username+<span class="string">&quot;吗？&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;确定：y      取消：n&quot;</span>);</span><br><span class="line">            String ch = scanner.next();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;y&quot;</span>.equals(ch))&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                    User user = list.get(i);</span><br><span class="line">                    <span class="keyword">if</span> (user.getUsername().equals(username))&#123;</span><br><span class="line">                        list.remove(i);</span><br><span class="line">                        System.out.println(<span class="string">&quot;用户&quot;</span>+username+<span class="string">&quot;删除成功！&quot;</span>);</span><br><span class="line">                        goHome();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;n&quot;</span>.equals(ch))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;您已取消删除！&quot;</span>);</span><br><span class="line">                goHome();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;输入错误代码！自动返回首页&quot;</span>);</span><br><span class="line">                goHome();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;抱歉，该用户不存在！&quot;</span>);</span><br><span class="line">            goHome();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isExist</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            String str=list.get(i).getUsername();</span><br><span class="line">            <span class="keyword">if</span> (str.equals(username))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="实体类：-User-java"><a href="#实体类：-User-java" class="headerlink" title="实体类： User.java"></a>实体类： User.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> upid=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        upid++;</span><br><span class="line">        id=upid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">        upid++;</span><br><span class="line">        id=upid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id+<span class="string">&quot;\t\t &quot;</span>+username+<span class="string">&quot;\t\t&quot;</span>+password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注册及登录演示"><a href="#注册及登录演示" class="headerlink" title="注册及登录演示"></a>注册及登录演示</h3><p><img src="/2021/04/19/day08-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95.png" alt="注册登录"></p>
<h3 id="添加演示"><a href="#添加演示" class="headerlink" title="添加演示"></a>添加演示</h3><p><img src="/2021/04/19/day08-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/%E6%B7%BB%E5%8A%A0.png" alt="添加"></p>
<h3 id="删除演示"><a href="#删除演示" class="headerlink" title="删除演示"></a>删除演示</h3><hr>
<p><img src="/2021/04/19/day08-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/delete01.png" alt="delete01"></p>
<hr>
<p><img src="/2021/04/19/day08-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/delete02.png" alt="delete02"></p>
<hr>
<h3 id="修改演示"><a href="#修改演示" class="headerlink" title="修改演示"></a>修改演示</h3><p><img src="/2021/04/19/day08-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/update.png" alt="update"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>培训学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>day07-String</title>
    <url>/2021/04/18/day07-String/</url>
    <content><![CDATA[<p><strong><em>今日内容：String</em></strong></p>
<span id="more"></span>

<h1 id="第一章、String（重点）"><a href="#第一章、String（重点）" class="headerlink" title="第一章、String（重点）"></a>第一章、String（重点）</h1><h2 id="1-1、String类的概述"><a href="#1-1、String类的概述" class="headerlink" title="1.1、String类的概述"></a>1.1、String类的概述</h2><p>java.lang.String 类代表字符串。Java程序中所有的字符串文字（例如 “abc” ）都可以被看作是实现此类的实例。类 String 中包括用于检查各个字符串的方法，比如用于比较字符串，搜索字符串，提取子字符串以及创建具有翻译为大写或小写的所有字符的字符串的副本。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 特点</span></span><br><span class="line"> 	 <span class="number">1.</span>字符串不变：字符串的值在创建后不能被更改</span><br><span class="line">      String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">      s1 += <span class="string">&quot;d&quot;</span>; <span class="comment">// s1 = s1 + &quot;d&quot;  // s1 =&quot;abcd&quot;</span></span><br><span class="line">      System.out.println(s1); <span class="comment">// &quot;abcd&quot;</span></span><br><span class="line">      <span class="comment">// 内存中有&quot;abc&quot;，&quot;abcd&quot;两个对象，s1从指向&quot;abc&quot;，改变指向，指向了&quot;abcd&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="number">2.</span>因为String对象是不可变的，所以它们可以被共享</span><br><span class="line">      String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">      String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">      <span class="comment">// 内存中只有一个&quot;abc&quot;对象被创建，同时被s1和s2共享		</span></span><br><span class="line"></span><br><span class="line">	<span class="number">3.</span><span class="string">&quot;abc&quot;</span> 等效于 <span class="keyword">char</span>[] data=&#123; <span class="string">&#x27;a&#x27;</span> , <span class="string">&#x27;b&#x27;</span> , <span class="string">&#x27;c&#x27;</span> &#125;</span><br><span class="line">      例如：</span><br><span class="line">      	String str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">      相当于：</span><br><span class="line">        <span class="keyword">char</span> data[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">        String str = <span class="keyword">new</span> String(data);</span><br><span class="line">        <span class="comment">// String底层是靠字符数组实现的</span></span><br></pre></td></tr></table></figure>

<h2 id="1-2、使用步骤"><a href="#1-2、使用步骤" class="headerlink" title="1.2、使用步骤"></a>1.2、使用步骤</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">查看类</span><br><span class="line">	java.lang.String ：此类不需要导入。</span><br><span class="line">查看构造方法</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> ：初始化新创建的 String对象，以使其表示空字符序列。</span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span>[] value)</span> ：通过当前参数中的字符数组来构造新的String。</span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> ：通过使用平台的默认字符集解码当前参数中的字节数组来构造新的String。</span></span><br><span class="line"><span class="function">构造举例，代码如下：</span></span><br><span class="line"><span class="function">  <span class="comment">// 无参构造</span></span></span><br><span class="line"><span class="function">  String str </span>= <span class="keyword">new</span> String（）；</span><br><span class="line">  <span class="comment">// 通过字符数组构造</span></span><br><span class="line">  <span class="keyword">char</span> chars[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">  String str2 = <span class="keyword">new</span> String(chars);</span><br><span class="line">  <span class="comment">// 通过字节数组构造</span></span><br><span class="line">  <span class="keyword">byte</span> bytes[] = &#123; <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span> &#125;;</span><br><span class="line">  String str3 = <span class="keyword">new</span> String(bytes)；</span><br></pre></td></tr></table></figure>

<h2 id="1-3、常用方法"><a href="#1-3、常用方法" class="headerlink" title="1.3、常用方法"></a>1.3、常用方法</h2><h3 id="1-3-1、判断字符串"><a href="#1-3-1、判断字符串" class="headerlink" title="1.3.1、判断字符串"></a>1.3.1、判断字符串</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object 是&quot;对象&quot;的意思，也是一种引用类型。作为参数类型，表示任意对象都可以传递到方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span> <span class="params">(Object anObject)</span> ：将此字符串与指定对象进行比较</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span> <span class="params">(String anotherString)</span> ：将此字符串与指定对象进行比较，忽略大小写</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 示例：</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class String_Demo01 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建字符串对象</span></span><br><span class="line">        String s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;HELLO&quot;</span>;</span><br><span class="line">        <span class="comment">// boolean equals(Object obj):比较字符串的内容是否相同</span></span><br><span class="line">        System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(s1.equals(s3)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);</span><br><span class="line">        <span class="comment">//boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写</span></span><br><span class="line">        System.out.println(s1.equalsIgnoreCase(s2)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(s1.equalsIgnoreCase(s3)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-2、获取字符串"><a href="#1-3-2、获取字符串" class="headerlink" title="1.3.2、获取字符串"></a>1.3.2、获取字符串</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span> <span class="params">()</span> ：返回此字符串的长度。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span> <span class="params">(String str)</span> ：将指定的字符串连接到该字符串的末尾。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span> <span class="params">(<span class="keyword">int</span> index)</span> ：返回指定索引处的 <span class="keyword">char</span>值。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span> <span class="params">(String str)</span> ：返回指定子字符串第一次出现在该字符串内的索引。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span> <span class="params">(<span class="keyword">int</span> beginIndex)</span> ：返回一个子字符串，从beginIndex开始截取字符串到字符串结尾。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span> <span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> ：返回一个子字符串，从beginIndex到endIndex截取字符串。含beginIndex，不含endIndex。</span></span><br><span class="line"><span class="function"><span class="comment">// 示例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class String_Demo02 </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//创建字符串对象</span></span><br><span class="line">      String s = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">      <span class="comment">// int length():获取字符串的长度，其实也就是字符个数</span></span><br><span class="line">      System.out.println(s.length());</span><br><span class="line">      System.out.println(<span class="string">&quot;‐‐‐‐‐‐‐‐&quot;</span>);</span><br><span class="line">      <span class="comment">// String concat (String str):将将指定的字符串连接到该字符串的末尾.</span></span><br><span class="line">      String s = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">      String s2 = s.concat(<span class="string">&quot;**hello HJM&quot;</span>);</span><br><span class="line">      System.out.println(s2);<span class="comment">// helloworld**hello HJM</span></span><br><span class="line">      <span class="comment">// char charAt(int index):获取指定索引处的字符</span></span><br><span class="line">      System.out.println(s.charAt(<span class="number">0</span>));</span><br><span class="line">      System.out.println(s.charAt(<span class="number">1</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;‐‐‐‐‐‐‐‐&quot;</span>);</span><br><span class="line">      <span class="comment">// int indexOf(String str):获取str在字符串对象中第一次出现的索引,没有返回‐1</span></span><br><span class="line">      System.out.println(s.indexOf(<span class="string">&quot;l&quot;</span>));</span><br><span class="line">      System.out.println(s.indexOf(<span class="string">&quot;owo&quot;</span>));</span><br><span class="line">      System.out.println(s.indexOf(<span class="string">&quot;ak&quot;</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;‐‐‐‐‐‐‐‐&quot;</span>);</span><br><span class="line">      <span class="comment">// String substring(int start):从start开始截取字符串到字符串结尾</span></span><br><span class="line">      System.out.println(s.substring(<span class="number">0</span>));</span><br><span class="line">      System.out.println(s.substring(<span class="number">5</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;‐‐‐‐‐‐‐‐&quot;</span>);</span><br><span class="line">      <span class="comment">// String substring(int start,int end):从start到end截取字符串。含start，不含end。</span></span><br><span class="line">      System.out.println(s.substring(<span class="number">0</span>, s.length())); <span class="comment">// 前开后闭</span></span><br><span class="line">      System.out.println(s.substring(<span class="number">3</span>,<span class="number">8</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-3、字符串转换"><a href="#1-3-3、字符串转换" class="headerlink" title="1.3.3、字符串转换"></a>1.3.3、字符串转换</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">char</span>[] toCharArray () ：将此字符串转换为新的字符数组。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes () ：使用平台的默认字符集将该 String编码转换为新的字节数组。</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span> <span class="params">(CharSequence target, CharSequence replacement)</span> ：将与target匹配的字符串使用replacement字符串替换</span></span><br><span class="line"><span class="function"><span class="comment">// 示例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class String_Demo03 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建字符串对象</span></span><br><span class="line">        String s = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">        <span class="comment">// char[] toCharArray():把字符串转换为字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] chs = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; chs.length; x++) &#123;</span><br><span class="line">        System.out.println(chs[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);</span><br><span class="line">        <span class="comment">// byte[] getBytes ():把字符串转换为字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = s.getBytes();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; bytes.length; x++) &#123;</span><br><span class="line">        System.out.println(bytes[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);</span><br><span class="line">        <span class="comment">// 替换字母it为大写IT</span></span><br><span class="line">        String str = <span class="string">&quot;hjm Hello&quot;</span>;</span><br><span class="line">        String replace = str.replace(<span class="string">&quot;hjm&quot;</span>, <span class="string">&quot;IT&quot;</span>);</span><br><span class="line">        System.out.println(replace); <span class="comment">// IT Hello</span></span><br><span class="line">        System.out.println(<span class="string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// CharSequence 是一个接口，也是一种引用类型。作为参数类型，可以把String对象传递到方法</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-4、字符串切割"><a href="#1-3-4、字符串切割" class="headerlink" title="1.3.4、字符串切割"></a>1.3.4、字符串切割</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String regex) ：将此字符串按照给定的regex（规则）拆分为字符串数组</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String_Demo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建字符串对象</span></span><br><span class="line">        String s = <span class="string">&quot;aa|bb|cc&quot;</span>;</span><br><span class="line">        String[] strArray = s.split(<span class="string">&quot;|&quot;</span>); <span class="comment">// [&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; strArray.length; x++) &#123;</span><br><span class="line">        		System.out.println(strArray[x]); <span class="comment">// aa bb cc</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4、String类的练习"><a href="#1-4、String类的练习" class="headerlink" title="1.4、String类的练习"></a>1.4、String类的练习</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.拼接字符串</span></span><br><span class="line"><span class="comment">// 定义一个方法，把数组&#123;1,2,3&#125;按照指定个格式拼接成一个字符串。格式参照如下：[word1#word2#word3]</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个int类型的数组</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        String s = arrayToString(arr);</span><br><span class="line">        <span class="comment">//输出结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;s:&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 写方法实现把数组中的元素按照指定的格式拼接成一个字符串</span></span><br><span class="line"><span class="comment">    * 两个明确：</span></span><br><span class="line"><span class="comment">    * 返回值类型：String</span></span><br><span class="line"><span class="comment">    * 参数列表：int[] arr</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">arrayToString</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// 创建字符串s</span></span><br><span class="line">         String s = <span class="keyword">new</span> String(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">         <span class="comment">// 遍历数组，并拼接字符串</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; arr.length; x++) &#123;</span><br><span class="line">              <span class="keyword">if</span> (x == arr.length ‐ <span class="number">1</span>) &#123;</span><br><span class="line">                  s = s.concat(arr[x] + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  s = s.concat(arr[x] + <span class="string">&quot;#&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> s;</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.统计字符个数</span></span><br><span class="line"><span class="comment">//键盘录入一个字符，统计字符串中大小写字母及数字字符个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//键盘录入一个字符串数据</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个字符串数据：&quot;</span>);</span><br><span class="line">        String s = sc.nextLine();</span><br><span class="line">        <span class="comment">//定义三个统计变量，初始化值都是0</span></span><br><span class="line">        <span class="keyword">int</span> bigCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> smallCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> numberCount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历字符串，得到每一个字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;s.length(); x++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(x);</span><br><span class="line">            <span class="comment">//拿字符进行判断</span></span><br><span class="line">            <span class="keyword">if</span>(ch&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">            		bigCount++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">            		smallCount++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            		numberCount++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            		System.out.println(<span class="string">&quot;该字符&quot;</span>+ch+<span class="string">&quot;非法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;大写字符：&quot;</span>+bigCount+<span class="string">&quot;个&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;小写字符：&quot;</span>+smallCount+<span class="string">&quot;个&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;数字字符：&quot;</span>+numberCount+<span class="string">&quot;个&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="今日作业："><a href="#今日作业：" class="headerlink" title="今日作业："></a>今日作业：</h4><h5 id="字符串计数"><a href="#字符串计数" class="headerlink" title="字符串计数"></a>字符串计数</h5><img src="/2021/04/18/day07-String/数量.png" width="65%">

<h5 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h5><img src="/2021/04/18/day07-String/拼接.png" width="65%">

<h2 id="美团面试题：String-s-new-String-“111”-会创建几个对象？"><a href="#美团面试题：String-s-new-String-“111”-会创建几个对象？" class="headerlink" title="美团面试题：String s = new String(“111”)会创建几个对象？"></a>美团面试题：String s = new String(“111”)会创建几个对象？</h2><h2 id="String不可变吗？"><a href="#String不可变吗？" class="headerlink" title="String不可变吗？"></a>String不可变吗？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">&quot;111&quot;</span>;</span><br><span class="line">        a = <span class="string">&quot;222&quot;</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有的人会认为上面这段代码应该输出：111</p>
<p>这样才和上面的不变性吻合。</p>
<p>哈哈哈，但是并不是这样滴。</p>
<blockquote>
<p>222</p>
</blockquote>
<p>这不对呀，不是不变吗？怎么变了呢？</p>
<p>其实在JVM的运行中，会单独给一块地分给String。</p>
<p>上面的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stirng a=<span class="string">&quot;111&quot;</span>；</span><br></pre></td></tr></table></figure>

<p>我们知道字符串的分配和其他对象分配一样，是需要消耗高昂的时间和空间的，而且字符串我们使用的非常多。</p>
<p><strong>JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：</strong></p>
<p>使用字符串常量池。每当我们创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性我们可以十分肯定常量池中一定不存在两个相同的字符串。</p>
<p>这里先去JVM给常量池里找，找到了就不用创建对象了，直接把对象的引用地址赋给a。找不到会重新创建一个对象，然后把对象的引用地址赋给a。同理a=”222”;也是先找，找不到就重新创建一个对象，然后把对象的引用地址赋给a。</p>
<p>大家有没有发现我上面的描述中“引用地址”。比如说 <code>Object obj = new Object();</code>很多人喜欢成<code>obj</code>为对象，其实<code>obj</code>不是对象，他只是一个变量，然后这个变量里保存一个<code>Object</code>对象的引用地址罢了。</p>
<p><strong>引用类型声明的变量是指该变量在内存中实际存储的是一个引用地址，实体在堆中。</strong></p>
<p>所以网上很多文章老喜欢这么说</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User()</span><br></pre></td></tr></table></figure>

<p>创建了一个user对象，老喜欢把user称之为对象。这里不接受反驳。</p>
<p>所以上面<code>String a = “111”；</code>表达的是变量a里保存了“111”这个对象的引用地址。变量是可以变的，不能变的是“111”。</p>
<p><strong style="color:red">String 为什么是不可变的？</strong></p>
<p>简单的来说，String 类中使用 final 关键字字符数组保存字符串。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="string">&quot;&quot;</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = original.value;</span><br><span class="line">        <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>从上面的这段源码中可以看出三点：</p>
<blockquote>
<p><strong style="color:red">String 类是final修饰</strong></p>
<p><strong style="color:red">String存储内容使用的是char数组</strong></p>
<p><strong style="color:red">char数组是final修饰</strong></p>
</blockquote>
<h2 id="这里就得复习一下，final有啥用？"><a href="#这里就得复习一下，final有啥用？" class="headerlink" title="这里就得复习一下，final有啥用？"></a>这里就得复习一下，final有啥用？</h2><p>当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。</p>
<p>当final修饰的方法表示此方法已经是“最后的、最终的”含义，亦即此方法不能被重写（可以重载多个final修饰的方法）。此处需要注意的一点是：因为重写的前提是子类可以从父类中继承此方法，如果父类中final修饰的方法同时访问控制权限为private，将会导致子类中不能直接继承到此方法，因此，此时可以在子类中定义相同的方法名和参数，此时不再产生重写与final的矛盾，而是在子类中重新定义了新的方法。（注：类的private方法会隐式地被指定为final方法。）</p>
<p>当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化。如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。本质上是一回事，因为引用的值是一个地址，final要求值，即地址的值不发生变化。另外final修饰一个成员变量（属性），必须要显示初始化。这里有两种初始化方式，（1.在申明的时候给其赋值，否则必须在其类的所有构造方法中都要为其赋值）</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalDemo</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是会会报错</p>
<p><img src="/2021/04/18/day07-String/pt_01" alt="图片"></p>
<p>关于final就简单说到这里</p>
<p>下面来看一个使用String的 案例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String name = <span class="string">&quot;老田&quot;</span>;</span><br><span class="line">        name.concat(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(name.concat(<span class="string">&quot;!&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<p><img src="/2021/04/18/day07-String/pt_02" alt="图片"></p>
<p>顺道溜达溜达 String中几个常用方法源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> otherLen = str.length();</span><br><span class="line">    <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//啥都没有，就直接把当前字符串给你</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = value.length;</span><br><span class="line">    <span class="keyword">char</span> buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">    str.getChars(buf, len);</span><br><span class="line">    <span class="comment">//看到了吗？返回的居然是新的String对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">char</span> dst[], <span class="keyword">int</span> dstBegin)</span> </span>&#123;</span><br><span class="line">    System.arraycopy(value, <span class="number">0</span>, dst, dstBegin, value.length);</span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果两个是一样的，那就必要替换了，所以返回this</span></span><br><span class="line">    <span class="keyword">if</span> (oldChar != newChar) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = value.length;</span><br><span class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//把当前的char数组复制给val，然后下面基于val来操作</span></span><br><span class="line">        <span class="keyword">char</span>[] val = value; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (++i &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val[i] == oldChar) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len) &#123;</span><br><span class="line">            <span class="comment">//创建一个新的char数组</span></span><br><span class="line">            <span class="keyword">char</span> buf[] = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                buf[j] = val[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = val[i];</span><br><span class="line">                buf[i] = (c == oldChar) ? newChar : c;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//创建一个新的String对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (endIndex &gt; value.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(endIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> subLen = endIndex - beginIndex;</span><br><span class="line">    <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正常返回的都是新new出来的String对象</span></span><br><span class="line">    <span class="keyword">return</span> ((beginIndex == <span class="number">0</span>) &amp;&amp; (endIndex == value.length)) ? <span class="keyword">this</span></span><br><span class="line">            : <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">trim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = value.length;</span><br><span class="line">    <span class="keyword">int</span> st = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] val = value;    <span class="comment">/* avoid getfield opcode */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((st &lt; len) &amp;&amp; (val[st] &lt;= <span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">        st++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((st &lt; len) &amp;&amp; (val[len - <span class="number">1</span>] &lt;= <span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是该字符串中包含了空格，调用substring方法，否则就是啥都没干原本返回</span></span><br><span class="line">    <span class="comment">//就是如果字符串里有空格，那么还是新生一个String对象返回</span></span><br><span class="line">    <span class="keyword">return</span> ((st &gt; <span class="number">0</span>) || (len &lt; value.length)) ? substring(st, len) : <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论是concat、replace、substring还是trim方法的操作都不是在原有的字符串上进行的，而是重新生成了一个新的字符串对象。也就是说进行这些操作后，最原始的字符串并没有被改变。</p>
<p>得出两个结论：</p>
<blockquote>
<p><strong style="color:red">String对象一旦被创建就是固定不变的了，对String对象的任何改变都不影响到原对象，相关的任何变化性的操作都会生成新的对象。</strong></p>
<p><strong style="color:red">String对象每次有变化性操作的时候，都会从新new一个String对象（这里指的是有变化的情况）。</strong></p>
</blockquote>
<p>回到前面的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//String a = &quot;111&quot;;相当于</span></span><br><span class="line"><span class="keyword">char</span> data [] =&#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>&#125;;</span><br><span class="line">Stirng a = <span class="keyword">new</span> String(data);</span><br><span class="line"><span class="comment">//a = &quot;222&quot;;</span></span><br><span class="line"><span class="keyword">char</span> data [] =&#123;<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;2&#x27;</span>&#125;;</span><br><span class="line">a = <span class="keyword">new</span> String(data);</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/18/day07-String/pt_03" alt="图片"></p>
<p>这会变量a里保存的是”222”对应String对象的引用。</p>
<p>继续看下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">&quot;111&quot;</span>;</span><br><span class="line">        String a1 = <span class="string">&quot;111&quot;</span>;</span><br><span class="line"></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">&quot;111&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对象地址是同一个</span></span><br><span class="line">        System.out.println(a==a1);</span><br><span class="line">        <span class="comment">//对象内容是一样的</span></span><br><span class="line">        System.out.println(a.equals(a1));</span><br><span class="line">        <span class="comment">//对象地址不一样</span></span><br><span class="line">        System.out.println(a==b);</span><br><span class="line">        <span class="comment">//对象内容是一样的</span></span><br><span class="line">        System.out.println(a.equals(b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>第一个输出true，说明a和a1两个变量保存的引用地址是同一个。</p>
<p>第二个也输出true，说明a和a1引用地址中内容是一样的。</p>
<blockquote>
<p>a和a1放在栈上，存放着对象的引用地址。</p>
<p>new的对象是在堆中。</p>
<p>常量其实是要看jdk版本的。</p>
</blockquote>
<p><img src="/2021/04/18/day07-String/pt_04" alt="图片"></p>
<p><img src="/2021/04/18/day07-String/pt_05" alt="图片"></p>
<p>所以String a = “111”; 在JVM申请内存存放”111”对应的对象，并将对象保存起来。当String a1=”1111”;的时候，会先去JVM的那块地里寻找是否存在”111”，刚好前面保存过，所以找到，然后直接把对象的引用地址给了a1。所以此时的a和a1都保存着同一个引用地址。</p>
<p>接触java后都知道可以new一个对象。所以 String b = new String(“111”);就是创建一个对象然后把对象引用地址赋给变量b。但是这里有个特殊点，那就是（“111”）,这里会先去JVM里的那块地里找找，找到了直接存放引用地址。找不到创建一个对象然后把引用地址给String的有参构造方法里。</p>
<p>所以第三个中输出false，因为a和b所保存的对象引用是不一样的。</p>
<p>最后一个输出true。那是因为两个变量所保存的引用地址中的内容都是“111”.</p>
<p><strong>答案：</strong></p>
<p><font style="color:red"><strong>如果常量池中存在，则只需创建一个对象，否则需要创建两个对象。</strong></font></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>培训学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>day06-关键字-static-Math-ArrayList</title>
    <url>/2021/04/15/day06-%E5%85%B3%E9%94%AE%E5%AD%97-static-Math-ArrayList/</url>
    <content><![CDATA[<p><strong><em>今日内容：常用 static 关键字、Math、ArrayList</em></strong></p>
<span id="more"></span>

<h1 id="第一章、API"><a href="#第一章、API" class="headerlink" title="第一章、API"></a>第一章、API</h1><h2 id="1-1、概述"><a href="#1-1、概述" class="headerlink" title="1.1、概述"></a>1.1、概述</h2><p>API(Application Programming Interface)，应用程序编程接口。Java API是一本程序员的 字典 ，是JDK中提供给<br>我们使用的类的说明文档。这些类将底层的代码实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可。所以我们可以通过查询API的方式，来学习Java提供的类，并得知如何使用它们</p>
<h2 id="1-2、使用步骤"><a href="#1-2、使用步骤" class="headerlink" title="1.2、使用步骤"></a>1.2、使用步骤</h2><ol>
<li>打开帮助文档。</li>
<li>点击显示，找到索引，看到输入框。</li>
<li>你要找谁？在输入框里输入，然后回车。</li>
<li>看包。java.lang下的类不需要导包，其他的需要导包。</li>
<li>看类的解释和说明。</li>
<li>学习构造方法。</li>
<li>使用成员方法</li>
</ol>
<h1 id="第二章、Scanner"><a href="#第二章、Scanner" class="headerlink" title="第二章、Scanner"></a>第二章、Scanner</h1><h2 id="2-1、什么是Scanner类"><a href="#2-1、什么是Scanner类" class="headerlink" title="2.1、什么是Scanner类"></a>2.1、什么是Scanner类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 键盘录入：一个可以根据键盘录入，解析出基本类型和字符串的简单文本扫描器</span></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in); <span class="comment">// System.in 指的是通过键盘录入数据</span></span><br><span class="line"><span class="keyword">int</span> i = sc.nextInt();</span><br></pre></td></tr></table></figure>

<h2 id="2-2、引用类型使用步骤"><a href="#2-2、引用类型使用步骤" class="headerlink" title="2.2、引用类型使用步骤"></a>2.2、引用类型使用步骤</h2><h3 id="2-2-1、导包"><a href="#2-2-1、导包" class="headerlink" title="2.2.1、导包"></a>2.2.1、导包</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用import关键字导包，在类的所有代码之前导包，引入要使用的类型，java.lang包下的所有类无需导入</span></span><br><span class="line"><span class="comment">// 格式：</span></span><br><span class="line">	<span class="keyword">import</span> 包名.类名;</span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2、创建对象"><a href="#2-2-2、创建对象" class="headerlink" title="2.2.2、创建对象"></a>2.2.2、创建对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用该类的构造方法，创建一个该类的对象</span></span><br><span class="line"><span class="comment">// 格式：</span></span><br><span class="line">	数据类型 变量名 = <span class="keyword">new</span> 数据类型(参数列表);</span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure>

<h3 id="2-2-3、调用方法"><a href="#2-2-3、调用方法" class="headerlink" title="2.2.3、调用方法"></a>2.2.3、调用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用该类的成员方法，完成指定功能</span></span><br><span class="line"><span class="comment">// 格式：</span></span><br><span class="line">	变量名.方法名();</span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">int</span> i = sc.nextInt(); <span class="comment">// 接收一个键盘录入的整数</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3、Scanner使用步骤"><a href="#2-3、Scanner使用步骤" class="headerlink" title="2.3、Scanner使用步骤"></a>2.3、Scanner使用步骤</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看类</span></span><br><span class="line">	java.util.Scanner ：该类需要<span class="keyword">import</span>导入后使用。</span><br><span class="line"><span class="comment">// 查看构造方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Scanner</span><span class="params">(InputStream source)</span> : 构造一个新的 Scanner ，它生成的值是从指定的输入流扫描的。</span></span><br><span class="line"><span class="function"><span class="comment">// 查看成员方法</span></span></span><br><span class="line"><span class="function">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span> ：将输入信息的下一个标记扫描为一个 <span class="keyword">int</span> 值。</span></span><br><span class="line"><span class="function"><span class="comment">// 课下练习</span></span></span><br><span class="line"><span class="function">    1.键盘录入两个数并求和</span></span><br><span class="line"><span class="function">    2.键盘录入三个数求最大值</span></span><br></pre></td></tr></table></figure>

<h2 id="2-4、匿名对象"><a href="#2-4、匿名对象" class="headerlink" title="2.4、匿名对象"></a>2.4、匿名对象</h2><p>// 概述：创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。虽然是创建对象的简化写法，但是应用场景非常有限。</p>
<p>匿名对象 ：没有变量名的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 格式：new 类名(参数列表)</span></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">应用场景</span><br><span class="line"><span class="number">1.</span> 创建匿名对象直接调用方法，没有变量名。</span><br><span class="line">	<span class="keyword">new</span> Scanner(System.in)；</span><br><span class="line"><span class="number">2.</span> 一旦调用两次方法，就是创建了两个对象，造成浪费，请看如下代码</span><br><span class="line">  	<span class="keyword">new</span> Scanner(System.in).nextInt();</span><br><span class="line">	<span class="keyword">new</span> Scanner(System.in).nextInt();</span><br><span class="line">	⚠️注意：一个匿名对象，只能使用一次。</span><br><span class="line"><span class="number">3.</span> 匿名对象可以作为方法的参数和返回值</span><br><span class="line">  <span class="comment">// 作为参数：</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 普通方式</span></span><br><span class="line">          Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">          input(sc);</span><br><span class="line">          <span class="comment">//匿名对象作为方法接收的参数</span></span><br><span class="line">          input(<span class="keyword">new</span> Scanner(System.in));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">(Scanner sc)</span></span>&#123;</span><br><span class="line">          System.out.println(sc);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 作为返回值</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 普通方式</span></span><br><span class="line">          Scanner sc = getScanner();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Scanner <span class="title">getScanner</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="comment">//普通方式</span></span><br><span class="line">          <span class="comment">//Scanner sc = new Scanner(System.in);</span></span><br><span class="line">          <span class="comment">//return sc;</span></span><br><span class="line">          <span class="comment">//匿名对象作为方法返回值</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="第三章、Random"><a href="#第三章、Random" class="headerlink" title="第三章、Random"></a>第三章、Random</h1><h2 id="3-1、什么是Random"><a href="#3-1、什么是Random" class="headerlink" title="3.1、什么是Random"></a>3.1、什么是Random</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此类的实例用于生成伪随机数</span></span><br><span class="line"><span class="comment">// 生成一个随机数</span></span><br><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">int</span> i = r.nextInt();</span><br></pre></td></tr></table></figure>

<h2 id="3-2、Random的使用"><a href="#3-2、Random的使用" class="headerlink" title="3.2、Random的使用"></a>3.2、Random的使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看类</span></span><br><span class="line">	java.util.Random ：该类需要 <span class="keyword">import</span>导入使后使用。</span><br><span class="line"><span class="comment">// 查看构造方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Random</span><span class="params">()</span> ：创建一个新的随机数生成器。</span></span><br><span class="line"><span class="function"><span class="comment">// 查看成员方法</span></span></span><br><span class="line"><span class="function">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">(<span class="keyword">int</span> n)</span> ：返回一个伪随机数，范围在 0 （包括）和 指定值 n （不包括）之间的 <span class="keyword">int</span> 值</span></span><br><span class="line"><span class="function"><span class="comment">// 示例：使用Random类，完成生成3个10以内的随机整数的操作</span></span></span><br><span class="line"><span class="function">	<span class="comment">//1. 导包</span></span></span><br><span class="line"><span class="function"><span class="keyword">import</span> java.util.Random</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01_Random</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//2. 创建键盘录入数据的对象</span></span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//3. 随机生成一个数据</span></span><br><span class="line">            <span class="keyword">int</span> number = r.nextInt(<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//4. 输出数据</span></span><br><span class="line">            System.out.println(<span class="string">&quot;number:&quot;</span>+ number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建一个 Random 对象，每次调用 nextInt() 方法，都会生成一个随机数</span></span><br></pre></td></tr></table></figure>

<h2 id="3-3、Random练习"><a href="#3-3、Random练习" class="headerlink" title="3.3、Random练习"></a>3.3、Random练习</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>获取随机数：获取<span class="number">1</span>-n之间的随机数，包含n</span><br><span class="line"><span class="comment">// 导包</span></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01Random</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">50</span>;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">// 获取随机数</span></span><br><span class="line">        <span class="keyword">int</span> number = r.nextInt(n) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 输出随机数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;number:&quot;</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2.</span>猜数字小游戏</span><br><span class="line"><span class="comment">// 导包</span></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02Random</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 系统产生一个随机数1‐100之间的。</span></span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> number = r.nextInt(<span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 键盘录入我们要猜的数据</span></span><br><span class="line">            Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入你要猜的数字(1‐100)：&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> guessNumber = sc.nextInt();</span><br><span class="line">            <span class="comment">// 比较这两个数据(用if语句)</span></span><br><span class="line">            <span class="keyword">if</span> (guessNumber &gt; number) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;你猜的数据&quot;</span> + guessNumber + <span class="string">&quot;大了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (guessNumber &lt; number) &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;你猜的数据&quot;</span> + guessNumber + <span class="string">&quot;小了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;恭喜你,猜中了&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第四章、ArrayList"><a href="#第四章、ArrayList" class="headerlink" title="第四章、ArrayList"></a>第四章、ArrayList</h1><h2 id="4-1、引入对象数组"><a href="#4-1、引入对象数组" class="headerlink" title="4.1、引入对象数组"></a>4.1、引入对象数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用学生数组，存储是3个学生对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    		<span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    		<span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    		<span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    		<span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01StudentArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建学生数组</span></span><br><span class="line">        Student[] students = <span class="keyword">new</span> Student[<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//创建学生对象</span></span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;曹操&quot;</span>,<span class="number">40</span>);</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;刘备&quot;</span>,<span class="number">35</span>);</span><br><span class="line">        Student s3 = <span class="keyword">new</span> Student(<span class="string">&quot;孙权&quot;</span>,<span class="number">30</span>);</span><br><span class="line">        <span class="comment">//把学生对象作为元素赋值给学生数组</span></span><br><span class="line">        students[<span class="number">0</span>] = s1;</span><br><span class="line">        students[<span class="number">1</span>] = s2;</span><br><span class="line">        students[<span class="number">2</span>] = s3;</span><br><span class="line">        <span class="comment">//遍历学生数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;students.length; x++) &#123;</span><br><span class="line">            Student s = students[x];</span><br><span class="line">            System.out.println(s.getName()+<span class="string">&quot;‐‐‐&quot;</span>+s.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 到目前为止，我们想存储对象数据，选择的容器，只有对象数组。而数组的长度是固定的，无法适应数据变化的需求。为了解决这个问题，Java提供了另一个容器 java.util.ArrayList 集合类,让我们可以更便捷的存储和操作对象数据</span></span><br></pre></td></tr></table></figure>

<h2 id="4-2、什么是ArrayList类"><a href="#4-2、什么是ArrayList类" class="headerlink" title="4.2、什么是ArrayList类"></a>4.2、什么是ArrayList类</h2><p> <code>java.util.ArrayList</code>是大小可变的数组的实现，存储在内的数据称为元素。此类提供一些方法来操作内部存储的元素。 ArrayList 中可不断添加元素，其大小也自动增长</p>
<h2 id="4-3、ArrayList使用步骤"><a href="#4-3、ArrayList使用步骤" class="headerlink" title="4.3、ArrayList使用步骤"></a>4.3、ArrayList使用步骤</h2><p>1.查看类<br>  <code> java.util.ArrayList&lt;E&gt;</code> ：该类需要 import导入使后使用。<br>  <code>&lt;E&gt;</code>表示一种指定的数据类型，叫做泛型 E ，取自Element（元素）的首字母。在出现 E 的地方，我们使<br>  用一种引用数据类型将其替换即可，表示我们将存储哪种引用类型的元素。代码如下：<br>    <code>ArrayList&lt;String&gt;，ArrayList&lt;Student&gt;</code></p>
<p>2.查看构造方法<br>    <code>public ArrayList()</code> ：构造一个内容为空的集合<br>  基本格式：<br>    <code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code><br>    简化格式：在JDK 7后,右侧泛型的尖括号之内可以留空，但是&lt;&gt;仍然要写<br>    <code>ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;()</code><br>3.查看成员方法<br>  <code>public boolean add(E e)</code> ： 将指定的元素添加到此集合的尾部。参数 E e ，在构造<code>ArrayList</code>对象时， <code>&lt;E&gt;</code> 指定了什么数据类型，那么 <code>add(E e)</code> 方法中，只能添加什么数据类型的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例：使用ArrayList类，存储三个字符串元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02StudentArrayList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建学生数组</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//创建学生对象</span></span><br><span class="line">        String s1 = <span class="string">&quot;曹操&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;刘备&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;孙权&quot;</span>;</span><br><span class="line">        <span class="comment">//打印学生ArrayList集合</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//把学生对象作为元素添加到集合</span></span><br><span class="line">        list.add(s1);</span><br><span class="line">        list.add(s2);</span><br><span class="line">        list.add(s3);</span><br><span class="line">        <span class="comment">//打印学生ArrayList集合</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-4、常用方法和遍历"><a href="#4-4、常用方法和遍历" class="headerlink" title="4.4、常用方法和遍历"></a>4.4、常用方法和遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于元素的操作,基本体现在——增、删、查。常用的方法有：</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> 		将指定的元素添加到此集合的尾部。</span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> 	移除此集合中指定位置上的元素。返回被删除的元素。</span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> 		返回此集合中指定位置上的元素。返回获取的元素。</span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> 					返回此集合中的元素数。遍历集合时，可以控制索引范围，防止越界</span></span><br><span class="line"><span class="function"><span class="comment">// 示例</span></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> class Demo01ArrayListMethod </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          <span class="comment">//创建集合对象</span></span><br><span class="line">          ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">          <span class="comment">//添加元素</span></span><br><span class="line">          list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">          list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">          list.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">          <span class="comment">//public E get(int index):返回指定索引处的元素</span></span><br><span class="line">          System.out.println(<span class="string">&quot;get:&quot;</span>+list.get(<span class="number">0</span>));</span><br><span class="line">          System.out.println(<span class="string">&quot;get:&quot;</span>+list.get(<span class="number">1</span>));</span><br><span class="line">          System.out.println(<span class="string">&quot;get:&quot;</span>+list.get(<span class="number">2</span>));</span><br><span class="line">          <span class="comment">//public int size():返回集合中的元素的个数</span></span><br><span class="line">          System.out.println(<span class="string">&quot;size:&quot;</span>+list.size());</span><br><span class="line">          <span class="comment">//public E remove(int index):删除指定索引处的元素，返回被删除的元素</span></span><br><span class="line">          System.out.println(<span class="string">&quot;remove:&quot;</span>+list.remove(<span class="number">0</span>));</span><br><span class="line">          <span class="comment">//遍历输出</span></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">          		System.out.println(list.get(i));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-5、如何存储基本数据类型"><a href="#4-5、如何存储基本数据类型" class="headerlink" title="4.5、如何存储基本数据类型"></a>4.5、如何存储基本数据类型</h2><p><code>ArrayList</code>对象不能存储基本类型，只能存储引用类型的数据。类似 <code>&lt;int&gt;</code> 不能写，但是存储基本数据类型对应的包装类型是可以的。所以，想要存储基本类型数据， &lt;&gt; 中的数据类型，必须转换后才能编写，转换写法如下：</p>
<table>
<thead>
<tr>
<th align="center">基本类型</th>
<th align="center">包装类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">Byte</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">Short</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">Integer</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">Long</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">Float</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">Double</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">Character</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">Boolean</td>
</tr>
</tbody></table>
<blockquote>
<p>我们发现，只有 Integer 和 Character 需要特殊记忆，其他基本类型只是首字母大写即可。那么存储基本类型数<br>据，代码如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02ArrayListMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-6、ArrayList练习"><a href="#4-6、ArrayList练习" class="headerlink" title="4.6、ArrayList练习"></a>4.6、ArrayList练习</h2><h3 id="4-6-1、数值添加到集合"><a href="#4-6-1、数值添加到集合" class="headerlink" title="4.6.1、数值添加到集合"></a>4.6.1、数值添加到集合</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成6个1~33之间的随机整数,添加到集合,并遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01ArrayList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Random 对象</span></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">// 创建ArrayList 对象</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加随机数到集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = random.nextInt(<span class="number">33</span>) + <span class="number">1</span>;</span><br><span class="line">            list.add(r);</span><br><span class="line">				&#125;</span><br><span class="line">        <span class="comment">// 遍历集合输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">        		System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-2、对象添加到"><a href="#4-6-2、对象添加到" class="headerlink" title="4.6.2、对象添加到"></a>4.6.2、对象添加到</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义4个学生对象,添加到集合,并遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02ArrayList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        ArrayList&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line">        <span class="comment">//创建学生对象</span></span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;赵丽颖&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;唐嫣&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        Student s3 = <span class="keyword">new</span> Student(<span class="string">&quot;景甜&quot;</span>,<span class="number">25</span>);</span><br><span class="line">        Student s4 = <span class="keyword">new</span> Student(<span class="string">&quot;柳岩&quot;</span>,<span class="number">19</span>);</span><br><span class="line">        <span class="comment">//把学生对象作为元素添加到集合中</span></span><br><span class="line">        list.add(s1);</span><br><span class="line">        list.add(s2);</span><br><span class="line">        list.add(s3);</span><br><span class="line">        list.add(s4);</span><br><span class="line">        <span class="comment">//遍历集合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; list.size(); x++) &#123;</span><br><span class="line">            Student s = list.get(x);</span><br><span class="line">            System.out.println(s.getName()+<span class="string">&quot;‐‐‐&quot;</span>+s.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-3、打印集合"><a href="#4-6-3、打印集合" class="headerlink" title="4.6.3、打印集合"></a>4.6.3、打印集合</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历：for循环</span></span><br><span class="line"><span class="comment">// 取值：get(index)</span></span><br></pre></td></tr></table></figure>

<h1 id="第五章、static（重点）"><a href="#第五章、static（重点）" class="headerlink" title="第五章、static（重点）"></a>第五章、static（重点）</h1><h2 id="6-1、概述"><a href="#6-1、概述" class="headerlink" title="6.1、概述"></a>6.1、概述</h2><blockquote>
<p>关于 static 关键字的使用，它可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了</p>
</blockquote>
<h2 id="6-2、定义和使用格式"><a href="#6-2、定义和使用格式" class="headerlink" title="6.2、定义和使用格式"></a>6.2、定义和使用格式</h2><h3 id="6-2-1、静态变量"><a href="#6-2-1、静态变量" class="headerlink" title="6.2.1、静态变量"></a>6.2.1、静态变量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 static关键字修饰的成员变量</span></span><br><span class="line">  <span class="keyword">static</span> 数据类型 变量名；</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> numberID；</span><br><span class="line"><span class="comment">// 示例：比如说，基础班新班开班，学员报到。现在想为每一位新来报到的同学编学号（sid），从第一名同学开始，sid为1，以此类推。学号必须是唯一的，连续的，并且与班级的人数相符，这样以便知道，要分配给下一名新同学的学号是多少。这样我们就需要一个变量，与单独的每一个学生对象无关，而是与整个班级同学数量有关。所以，我们可以这样定义一个静态变量numberOfStudent，代码如下：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 学生的id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sid;</span><br><span class="line">    <span class="comment">// 类变量，记录学生数量，分配学号</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> numberOfStudent = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="comment">// 通过 numberOfStudent 给学生分配学号</span></span><br><span class="line">        <span class="keyword">this</span>.sid = ++numberOfStudent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印属性值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    		System.out.println(<span class="string">&quot;Student : name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;, sid=&quot;</span> + sid );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StuDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>, <span class="number">23</span>);</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;李四&quot;</span>, <span class="number">24</span>);</span><br><span class="line">        Student s3 = <span class="keyword">new</span> Student(<span class="string">&quot;王五&quot;</span>, <span class="number">25</span>);</span><br><span class="line">        Student s4 = <span class="keyword">new</span> Student(<span class="string">&quot;赵六&quot;</span>, <span class="number">26</span>);</span><br><span class="line">        s1.show(); <span class="comment">// Student : name=张三, age=23, sid=1</span></span><br><span class="line">        s2.show(); <span class="comment">// Student : name=李四, age=24, sid=2</span></span><br><span class="line">        s3.show(); <span class="comment">// Student : name=王五, age=25, sid=3</span></span><br><span class="line">        s4.show(); <span class="comment">// Student : name=赵六, age=26, sid=4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-2、静态方法"><a href="#6-2-2、静态方法" class="headerlink" title="6.2.2、静态方法"></a>6.2.2、静态方法</h3><blockquote>
<p>当 static 修饰成员方法时，该方法称为类方法，习惯称为静态方法。静态方法在声明中有 static ，建议使用类名来调用，而不需要创建类的对象。调用方式非常简单。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">static</span> 返回值类型 方法名 (参数列表)&#123;</span><br><span class="line">  		<span class="comment">// 执行语句</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  		System.out.println(<span class="string">&quot;num:&quot;</span> + numberOfStudent);</span><br><span class="line">  &#125;</span><br><span class="line">⚠️静态方法调用的注意事项：</span><br><span class="line">    <span class="number">1</span>）静态方法只能访问类静态变量和静态方法。</span><br><span class="line">    <span class="number">2</span>）静态方法不能直接访问普通成员变量或成员方法。反之，成员方法可以直接访问类静态变量或静态方法。</span><br><span class="line">    <span class="number">3</span>）静态方法中，不能使用<span class="keyword">this</span>关键字</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-2-3、调用格式"><a href="#6-2-3、调用格式" class="headerlink" title="6.2.3、调用格式"></a>6.2.3、调用格式</h3><blockquote>
<p>被static修饰的成员可以并且建议通过类名直接访问。虽然也可以通过对象名访问静态成员，原因即多个对象均属于一个类，共享使用同一个静态成员，但是不建议，会出现警告信息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 格式</span></span><br><span class="line">    <span class="comment">// 访问类变量</span></span><br><span class="line">    类名.类变量名；</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 调用静态方法</span></span><br><span class="line">    类名.静态方法名(参数)；</span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StuDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 访问类变量</span></span><br><span class="line">        System.out.println(Student.numberOfStudent);</span><br><span class="line">        <span class="comment">// 调用静态方法</span></span><br><span class="line">        Student.showNum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-3、静态原理图解"><a href="#6-3、静态原理图解" class="headerlink" title="6.3、静态原理图解"></a>6.3、静态原理图解</h2><p><strong style="color:red">static 修饰的内容：</strong><br>        <strong>1）是随着类的加载而加载的，且只加载一次。</strong><br>        <strong>2）存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。</strong><br>        <strong>3）它优先于对象存在，所以，可以被所有对象共享</strong></p>
<img src="/2021/04/15/day06-%E5%85%B3%E9%94%AE%E5%AD%97-static-Math-ArrayList/教学大纲\04-JavaSE\img\2019-12-15_00-48-05.jpg" alt="2019-12-15_00-48-05" style="zoom:50%;">

<h2 id="6-4、静态代码块"><a href="#6-4、静态代码块" class="headerlink" title="6.4、静态代码块"></a>6.4、静态代码块</h2><blockquote>
<p>静态代码块：定义在成员位置，使用static修饰的代码块{ }。<br>        位置：类中方法外（不在乎在哪一行，只要是类中方法外就行）<br>        执行：随着类的加载而执行且执行一次，优先于main方法和构造方法的执行。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 格式：</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span>&#123;</span><br><span class="line">			<span class="keyword">static</span> &#123;</span><br><span class="line">				<span class="comment">// 执行语句</span></span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 作用：进行初始化赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;String&gt; list;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 给类变量赋值</span></span><br><span class="line">        number = <span class="number">2</span>;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 添加元素到集合中</span></span><br><span class="line">        list.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">⚠️<span class="keyword">static</span> 关键字，可以修饰变量、方法和代码块。在使用的过程中，其主要目的还是想在不创建对象的情况</span><br><span class="line">下，去调用方法。</span><br></pre></td></tr></table></figure>

<h1 id="第六章、Arrays"><a href="#第六章、Arrays" class="headerlink" title="第六章、Arrays"></a>第六章、Arrays</h1><h2 id="7-1、操作数组"><a href="#7-1、操作数组" class="headerlink" title="7.1、操作数组"></a>7.1、操作数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java.util.Arrays 此类包含用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法，调用起来非常简单</span></span><br><span class="line"><span class="number">1</span>）<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span>[] a)</span> ：将数组转为字符串</span></span><br><span class="line"><span class="function"><span class="comment">// 示例1</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义int 数组</span></span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>,<span class="number">34</span>,<span class="number">35</span>,<span class="number">4</span>,<span class="number">657</span>,<span class="number">8</span>,<span class="number">69</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="comment">// 打印数组,输出地址值</span></span><br><span class="line">    System.out.println(arr); <span class="comment">// [I@2ac1fdc4</span></span><br><span class="line">    <span class="comment">// 数组内容转为字符串</span></span><br><span class="line">    String s = Arrays.toString(arr);</span><br><span class="line">    <span class="comment">// 打印字符串,输出内容</span></span><br><span class="line">    System.out.println(s); <span class="comment">// [2, 34, 35, 4, 657, 8, 69, 9]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2</span>）<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> ：对<span class="keyword">int</span>类型数组升序排序</span></span><br><span class="line"><span class="function"><span class="comment">// 示例2</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义int 数组</span></span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">24</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">48</span>, <span class="number">4</span>, <span class="number">46</span>, <span class="number">35</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">2</span>&#125;;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 排序前:[24, 7, 5, 48, 4, 46, 35, 11, 6,2]</span></span><br><span class="line">    System.out.println(<span class="string">&quot;排序前:&quot;</span>+ Arrays.toString(arr)); </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 升序排序</span></span><br><span class="line">    Arrays.sort(arr);</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 排序后:[2, 4, 5, 6, 7, 11, 24, 35, 46,48]</span></span><br><span class="line">    System.out.println(<span class="string">&quot;排序后:&quot;</span>+ Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 练习：将一个随机字符串中的所有字符升序排列，并倒序打印。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArraysTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义随机的字符串</span></span><br><span class="line">        String line = <span class="string">&quot;ysKUreaytWTRHsgFdSAoidq&quot;</span>;</span><br><span class="line">        <span class="comment">// 转换为字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] chars = line.toCharArray();</span><br><span class="line">        <span class="comment">// 升序排序</span></span><br><span class="line">        Arrays.sort(chars);</span><br><span class="line">        <span class="comment">// 反向遍历打印</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = chars.length‐<span class="number">1</span>; i &gt;= <span class="number">0</span> ; i‐‐) &#123;</span><br><span class="line">        		System.out.print(chars[i]+<span class="string">&quot; &quot;</span>); <span class="comment">// y y t s s r q o i g e d d a W U T S R K H F A</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第七章、Math"><a href="#第七章、Math" class="headerlink" title="第七章、Math"></a>第七章、Math</h1><h2 id="8-1、基本数学运算"><a href="#8-1、基本数学运算" class="headerlink" title="8.1、基本数学运算"></a>8.1、基本数学运算</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.lang.Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具类，其所有方法均为静态方法，并且不会创建对象，调用起来非常简单</span></span><br><span class="line"><span class="number">1</span>）<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">abs</span><span class="params">(<span class="keyword">double</span> a)</span> ：返回 <span class="keyword">double</span> 值的绝对值</span></span><br><span class="line"><span class="function">    <span class="keyword">double</span> d1 </span>= Math.abs(‐<span class="number">5</span>); <span class="comment">//d1的值为5</span></span><br><span class="line">    <span class="keyword">double</span> d2 = Math.abs(<span class="number">5</span>); <span class="comment">//d2的值为5</span></span><br><span class="line"><span class="number">2</span>）<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">ceil</span><span class="params">(<span class="keyword">double</span> a)</span> ：返回大于等于参数的最小的整数</span></span><br><span class="line"><span class="function">  	<span class="keyword">double</span> d1 </span>= Math.ceil(<span class="number">3.3</span>); <span class="comment">//d1的值为 4.0</span></span><br><span class="line">    <span class="keyword">double</span> d2 = Math.ceil(‐<span class="number">3.3</span>); <span class="comment">//d2的值为 ‐3.0</span></span><br><span class="line">    <span class="keyword">double</span> d3 = Math.ceil(<span class="number">5.1</span>); <span class="comment">//d3的值为 6.0</span></span><br><span class="line"><span class="number">3</span>）<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">floor</span><span class="params">(<span class="keyword">double</span> a)</span> ：返回小于等于参数最大的整数</span></span><br><span class="line"><span class="function">  	<span class="keyword">double</span> d1 </span>= Math.floor(<span class="number">3.3</span>); <span class="comment">//d1的值为3.0</span></span><br><span class="line">    <span class="keyword">double</span> d2 = Math.floor(‐<span class="number">3.3</span>); <span class="comment">//d2的值为‐4.0</span></span><br><span class="line">    <span class="keyword">double</span> d3 = Math.floor(<span class="number">5.1</span>); <span class="comment">//d3的值为 5.0</span></span><br><span class="line"><span class="number">4</span>）<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span> a)</span> ：返回最接近参数的 <span class="keyword">long</span>。<span class="params">(相当于四舍五入）</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">long</span> d1 = Math.round(<span class="number">5.5</span>)</span></span>; <span class="comment">//d1的值为6.0</span></span><br><span class="line">		<span class="keyword">long</span> d2 = Math.round(<span class="number">5.4</span>); <span class="comment">//d2的值为5.0</span></span><br><span class="line"><span class="comment">// 练习：计算在 -10.8 到 5.9 之间，绝对值大于 6 或者小于 2.1 的整数有多少个？</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义最小值</span></span><br><span class="line">        <span class="keyword">double</span> min = ‐<span class="number">10.8</span>;</span><br><span class="line">        <span class="comment">// 定义最大值</span></span><br><span class="line">        <span class="keyword">double</span> max = <span class="number">5.9</span>;</span><br><span class="line">        <span class="comment">// 定义变量计数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 范围内循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> i = Math.ceil(min); i &lt;= max; i++) &#123;</span><br><span class="line">            <span class="comment">// 获取绝对值并判断</span></span><br><span class="line">            <span class="keyword">if</span> (Math.abs(i) &gt; <span class="number">6</span> || Math.abs(i) &lt; <span class="number">2.1</span>) &#123;</span><br><span class="line">                <span class="comment">// 计数</span></span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;个数为: &quot;</span> + count + <span class="string">&quot; 个&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;                                                    </span><br></pre></td></tr></table></figure>

<h4 id="今日作业"><a href="#今日作业" class="headerlink" title="今日作业"></a>今日作业</h4><blockquote>
<p>随机数</p>
</blockquote>
<p><img src="/2021/04/15/day06-%E5%85%B3%E9%94%AE%E5%AD%97-static-Math-ArrayList/%E9%9A%8F%E6%9C%BA.png" alt="随机"></p>
<blockquote>
<p>ArrayList</p>
</blockquote>
<p><img src="/2021/04/15/day06-%E5%85%B3%E9%94%AE%E5%AD%97-static-Math-ArrayList/%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84.png" alt="对象数组"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>培训学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>day05-封装-常用类</title>
    <url>/2021/04/13/day05-%E5%B0%81%E8%A3%85-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><strong><em>今日内容：对象内存图、封装等</em></strong></p>
<span id="more"></span>

<h2 id="1-6、对象内存图"><a href="#1-6、对象内存图" class="headerlink" title="1.6、对象内存图"></a>1.6、对象内存图</h2><img src="/2021/04/13/day05-%E5%B0%81%E8%A3%85-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/2019-12-14_18-36-39.jpg" alt="2019-12-14_18-36-39" style="zoom:50%;">

<p>通过上图，我们可以理解，在栈内存中运行的方法，遵循<font style="color:red">“先进后出，后进先出”</font>的原则。变量p指向堆内存中的空间，寻找方法信息，去执行该方法。但是，这里依然有问题存在。创建多个对象时，如果每个对象内部都保存一份方法信息，这就非常浪费内存了，因为所有对象的方法信息都是一样的。那么如何解决这个问题呢？请看如下图解</p>
<img src="/2021/04/13/day05-%E5%B0%81%E8%A3%85-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/2019-12-14_18-37-21.jpg" alt="2019-12-14_18-37-21" style="zoom:50%;">

<img src="/2021/04/13/day05-%E5%B0%81%E8%A3%85-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/2019-12-14_18-38-09.jpg" alt="2019-12-14_18-38-09" style="zoom:50%;">

<h2 id="1-7、成员变量和局部变量的区别"><a href="#1-7、成员变量和局部变量的区别" class="headerlink" title="1.7、成员变量和局部变量的区别"></a>1.7、成员变量和局部变量的区别</h2><p>// 变量根据定义位置的不同，我们给变量起了不同的名字<br><strong style="color:red">1）在类中的位置不同（重点）</strong><br>    <strong>成员变量：类中，方法外</strong><br>    <strong>局部变量：方法中或者方法声明上（形式参数）</strong><br><strong style="color:red">2）作用范围不一样（重点）</strong><br>    <strong>成员变量：类中</strong><br>    <strong>局部变量：方法中</strong><br><strong style="color:red">3）初始化值的不同（重点）</strong><br>    <strong>成员变量：有默认值</strong><br>    <strong>局部变量：没有默认值。必须先定义，赋值，最后使用</strong><br><strong style="color:red">4）在内存中的位置不同（了解）</strong><br>    <strong>成员变量：堆内存</strong><br>    <strong>局部变量：栈内存</strong><br><strong style="color:red">5）生命周期不同（了解）</strong><br>    <strong>成员变量：随着对象的创建而存在，随着对象的消失而消失</strong><br>    <strong>局部变量：随着方法的调用而存在，随着方法的调用完毕而消失</strong></p>
<img src="/2021/04/13/day05-%E5%B0%81%E8%A3%85-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/2019-12-14_18-39-30.jpg" alt="2019-12-14_18-39-30" style="zoom:50%;">

<blockquote>
<p><strong>简单涉及垃圾回收机制：</strong></p>
<p>在方法中将对象赋值 null : p = null; 当所占内存超过一定阈值，将作了标记的对象回收(主动释放内存空间)</p>
</blockquote>
<h1 id="第二章、封装"><a href="#第二章、封装" class="headerlink" title="第二章、封装"></a>第二章、封装</h1><h2 id="2-1、封装的概述"><a href="#2-1、封装的概述" class="headerlink" title="2.1、封装的概述"></a>2.1、封装的概述</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">面向对象编程语言是对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界无法直接操作和修改。封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 原则：将属性隐藏起来，若需要访问某个属性，提供公共方法对其访</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2、封装的步骤"><a href="#2-2、封装的步骤" class="headerlink" title="2.2、封装的步骤"></a>2.2、封装的步骤</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）使用 <span class="keyword">private</span> 关键字来修饰成员变量</span><br><span class="line"><span class="number">2</span>）对需要访问的成员变量，提供对应的一对 getXxx 方法 、 setXxx 方法</span><br></pre></td></tr></table></figure>

<h2 id="2-3、封装操作—private关键字"><a href="#2-3、封装操作—private关键字" class="headerlink" title="2.3、封装操作—private关键字"></a>2.3、封装操作—private关键字</h2><h3 id="2-3-1、private的含义"><a href="#2-3-1、private的含义" class="headerlink" title="2.3.1、private的含义"></a>2.3.1、private的含义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）<span class="keyword">private</span>是一个权限修饰符，代表最小权限</span><br><span class="line"><span class="number">2</span>）可以修饰成员变量和成员方法</span><br><span class="line"><span class="number">3</span>）被<span class="keyword">private</span>修饰后的成员变量和成员方法，只在本类中才能访问</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2、private的格式"><a href="#2-3-2、private的格式" class="headerlink" title="2.3.2、private的格式"></a>2.3.2、private的格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）<span class="keyword">private</span> 数据类型 变量名</span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2</span>）提供 getXxx 方法(取值) / setXxx(赋值) 方法，可以访问成员变量</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String n)</span> </span>&#123;</span><br><span class="line">    		name = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    		<span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    		age = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   		 <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4、封装优化1—this关键字"><a href="#2-4、封装优化1—this关键字" class="headerlink" title="2.4、封装优化1—this关键字"></a>2.4、封装优化1—this关键字</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我们发现 setXxx 方法中的形参名字并不符合见名知意的规定，那么如果修改与成员变量名一致，是否就见名知意</span><br><span class="line">了呢？代码如下：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    		name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    		age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 经过修改和测试，我们发现新的问题，成员变量赋值失败了。也就是说，在修改了 setXxx() 的形参变量名后，方法并没有给成员变量赋值！这是由于形参变量名与成员变量名重名，导致成员变量名被隐藏，方法中的变量名，无法访问到成员变量，从而赋值失败。所以，我们只能使用this关键字，来解决这个重名问题</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-1、this的含义"><a href="#2-4-1、this的含义" class="headerlink" title="2.4.1、this的含义"></a>2.4.1、this的含义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this代表所在类的当前对象的引用（地址值），即对象自己的引用</span></span><br><span class="line">⚠️记住：方法被哪个对象调用，方法中的<span class="keyword">this</span>就代表那个对象。即谁在调用，<span class="keyword">this</span>就代表谁</span><br></pre></td></tr></table></figure>

<h3 id="2-4-2、this的格式"><a href="#2-4-2、this的格式" class="headerlink" title="2.4.2、this的格式"></a>2.4.2、this的格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.成员变量名;</span><br><span class="line"><span class="comment">// 示例：使用 this 修饰方法中的变量，解决成员变量被隐藏的问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//name = name;</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    		<span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//age = age;</span></span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    		<span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">⚠️方法中只有一个变量名时，默认也是使用 <span class="keyword">this</span> 修饰，可以省略不写</span><br></pre></td></tr></table></figure>

<h2 id="2-5、封装优化2—构造方法"><a href="#2-5、封装优化2—构造方法" class="headerlink" title="2.5、封装优化2—构造方法"></a>2.5、封装优化2—构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）当一个对象被创建时候，构造方法用来初始化该对象，给对象的成员变量赋初始值。</span><br><span class="line"><span class="number">2</span>）无论你与否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个无参数构造方法，一旦自己定义了构造方法，	Java自动提供的默认无参数构造方法就会失效</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 格式：构造方法的写法上，方法名与它所在的类名相同。它没有返回值，所以不需要返回值类型，甚至不需要void</span></span><br><span class="line">  修饰符 构造方法名(参数列表)&#123;</span><br><span class="line">			<span class="comment">// 方法体</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 无参数构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 有参数构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong style="color:red">⚠️注意事项：</strong><br>        <strong>1. 如果你不提供构造方法，系统会给出无参数构造方法。</strong><br>        <strong>2. 如果你提供了构造方法，系统将不再提供无参数构造方法。</strong><br>        <strong>3. 构造方法是可以重载的，既可以定义参数，也可以不定义参数。</strong></p>
<h2 id="2-6、标准代码"><a href="#2-6、标准代码" class="headerlink" title="2.6、标准代码"></a>2.6、标准代码</h2><p><strong>JavaBean 是 Java语言编写类的一种标准规范</strong><br><strong>符合 JavaBean 的类要：</strong><br>    <strong>1.类必须是具体的和公共的</strong><br>    <strong>2.有构造方法</strong><br>    <strong>3.提供用来操作成员变量的 set 和 get 方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例一</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span>&#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="comment">//无参构造方法</span></span><br><span class="line">    <span class="comment">//有参构造方法</span></span><br><span class="line">    <span class="comment">//成员方法</span></span><br><span class="line">    <span class="comment">//getXxx()</span></span><br><span class="line">    <span class="comment">//setXxx()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 示例二</span></span><br><span class="line">	<span class="comment">// 创建学生类 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//成员方法</span></span><br><span class="line">    <span class="function">publicvoid <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    		<span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   		 <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">publicvoid <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    		<span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">publicint <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    		<span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">// 创建测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStudent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//无参构造使用</span></span><br><span class="line">        Student s= <span class="keyword">new</span> Student();</span><br><span class="line">        s.setName(<span class="string">&quot;柳岩&quot;</span>);</span><br><span class="line">        s.setAge(<span class="number">18</span>);</span><br><span class="line">        System.out.println(s.getName()+<span class="string">&quot;‐‐‐&quot;</span>+s.getAge());</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//带参构造使用</span></span><br><span class="line">        Student s2= <span class="keyword">new</span> Student(<span class="string">&quot;赵丽颖&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        System.out.println(s2.getName()+<span class="string">&quot;‐‐‐&quot;</span>+s2.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="今日作业："><a href="#今日作业：" class="headerlink" title="今日作业："></a>今日作业：</h3><h4 id="四位整数求各位数和："><a href="#四位整数求各位数和：" class="headerlink" title="四位整数求各位数和："></a>四位整数求各位数和：</h4><img src="/2021/04/13/day05-%E5%B0%81%E8%A3%85-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/和.png" width="65%">

<h4 id="各个数出现的次数："><a href="#各个数出现的次数：" class="headerlink" title="各个数出现的次数："></a>各个数出现的次数：</h4><img src="/2021/04/13/day05-%E5%B0%81%E8%A3%85-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/出现次数.png" width="65%">

<img src="/2021/04/13/day05-%E5%B0%81%E8%A3%85-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/出现次数结果.png" width="65%">]]></content>
      <categories>
        <category>Java</category>
        <category>培训学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>day04-面向对象-类-对象</title>
    <url>/2021/04/12/day04-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%B1%BB-%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p><strong><em>今日内容：面向对象、类、对象。</em></strong></p>
<span id="more"></span>

<h1 id="第一章、面向对象思想（OOP）"><a href="#第一章、面向对象思想（OOP）" class="headerlink" title="第一章、面向对象思想（OOP）"></a>第一章、面向对象思想（OOP）</h1><h2 id="1-1、面向对象思想概述"><a href="#1-1、面向对象思想概述" class="headerlink" title="1.1、面向对象思想概述"></a>1.1、面向对象思想概述</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 概述</span></span><br><span class="line">	Java语言是一种面向对象的程序设计语言，而面向对象思想是一种程序设计思想，我们在面向对象思想的指引下，使用Java语言去设计、开发计算机程序。 这里的对象泛指现实中一切事物，每种事物都具备自己的属性和行为。面向对象思想就是在计算机程序设计过程中，参照现实中事物，将事物的属性特征、行为特征抽象出来，描述成计算机事件的设计思想。 它区别于面向过程思想，强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去操作实现</span><br><span class="line"><span class="comment">// 举例</span></span><br><span class="line">洗衣服:</span><br><span class="line">	面向过程：把衣服脱下来--&gt;找个盆--&gt;放点洗衣粉--&gt;加点水--&gt;浸泡几分钟--&gt;揉揉--&gt;清洗衣服--&gt;拧干--&gt;晾起来</span><br><span class="line">	面向对象：把衣服脱下来--&gt;打开全自动洗衣机--&gt;扔衣服--&gt;按钮--&gt;晾起来</span><br><span class="line">区别：</span><br><span class="line">	面向过程：强调步骤</span><br><span class="line">	面向对象：强调对象，这里的对象就是洗衣机</span><br><span class="line"><span class="comment">// 特点</span></span><br><span class="line">  面向对象思想是一种更符合我们思考习惯的思想，它可以将复杂的事情简单化，并将我们从执行者变成了指挥者。面向对象的语言中，包含了三大基本特征：封装、继承、多态</span><br></pre></td></tr></table></figure>

<h2 id="1-2、类和对象"><a href="#1-2、类和对象" class="headerlink" title="1.2、类和对象"></a>1.2、类和对象</h2><h3 id="1-2-1、什么是类"><a href="#1-2-1、什么是类" class="headerlink" title="1.2.1、什么是类"></a>1.2.1、什么是类</h3><p><strong style="color:red">类：是一组相关属性和行为的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物</strong></p>
<p>现实中，描述一类事物：<br>    属性：就是该事物的状态信息<br>    行为：就是该事物能够做什么</p>
<p>举例：小猫<br>        属性：名字、体重、年龄、颜色…<br>          行为：跑、叫、睡、吃…</p>
<h3 id="1-2-2、什么是对象"><a href="#1-2-2、什么是对象" class="headerlink" title="1.2.2、什么是对象"></a>1.2.2、什么是对象</h3><p><strong style="color:red">对象：是一类事物的具体体现。对象是类的一个实例，必然具备该类事物的属性和行为</strong><br>现实中，一类事物的一个实例：一只小猫</p>
<p>举例：一只小猫。<br>属性：tom、5kg、2 years、yellow…<br>行为：慢悠悠的跑、温柔的叫、呼呼大睡…</p>
<h3 id="1-2-3、类与对象的关系"><a href="#1-2-3、类与对象的关系" class="headerlink" title="1.2.3、类与对象的关系"></a>1.2.3、类与对象的关系</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）类是对一类事物的描述，是抽象的</span><br><span class="line"><span class="number">2</span>）对象是一类事物的实例，是具体的</span><br><span class="line"><span class="number">3</span>）类是对象的模板，对象是类的实例</span><br></pre></td></tr></table></figure>

<h2 id="1-3、类的定义"><a href="#1-3、类的定义" class="headerlink" title="1.3、类的定义"></a>1.3、类的定义</h2><h3 id="1-3-1、事物与类的对比"><a href="#1-3-1、事物与类的对比" class="headerlink" title="1.3.1、事物与类的对比"></a>1.3.1、事物与类的对比</h3><p>现实世界的一类事物：<br>          属性：事物的状态信息<br>          行为：事物能够做什么</p>
<p>Java中用class描述事物也是如此：<br>          成员变量：对应事物的属性<br>          成员方法：对应事物的行为</p>
<h3 id="1-3-2、类的定义格式"><a href="#1-3-2、类的定义格式" class="headerlink" title="1.3.2、类的定义格式"></a>1.3.2、类的定义格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line">  <span class="comment">//成员变量</span></span><br><span class="line">  <span class="comment">//成员方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分析：</span></span><br><span class="line">	定义类：  就是定义类的成员，包括成员变量和成员方法。</span><br><span class="line">	成员变量：和以前定义变量几乎是一样的。只不过位置发生了改变。在类中，方法外</span><br><span class="line">	成员方法：和以前定义方法几乎是一样的。只不过把<span class="keyword">static</span>去掉，<span class="keyword">static</span>的作用在面向对象后面课程中再详细讲解</span><br><span class="line"><span class="comment">// 示例：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">        <span class="comment">//成员变量</span></span><br><span class="line">        String name；<span class="comment">//姓名</span></span><br><span class="line">        <span class="keyword">int</span> age；<span class="comment">//年龄</span></span><br><span class="line">          <span class="comment">//成员方法</span></span><br><span class="line">        <span class="comment">//学习的方法</span></span><br><span class="line">        <span class="function">publicvoid <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        		System.out.println(<span class="string">&quot;好好学习，天天向上&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//吃饭的方法</span></span><br><span class="line">        <span class="function">publicvoid <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        		System.out.println(<span class="string">&quot;学习饿了要吃饭&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4、对象的使用"><a href="#1-4、对象的使用" class="headerlink" title="1.4、对象的使用"></a>1.4、对象的使用</h2><h3 id="1-4-1、对象的使用格式"><a href="#1-4-1、对象的使用格式" class="headerlink" title="1.4.1、对象的使用格式"></a>1.4.1、对象的使用格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line">	类名 对象名 = <span class="keyword">new</span> 类名();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用对象访问类中的成员</span></span><br><span class="line">	对象名.成员变量；</span><br><span class="line">	对象名.成员方法()；</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="comment">// 定义学生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;好好学习，天天向上&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;学习饿了要吃饭&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01_Student</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//创建对象格式：类名 对象名 = new 类名();</span></span><br><span class="line">        Student s = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(<span class="string">&quot;s:&quot;</span>+s); <span class="comment">//cn.hjm.Student@100363</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">//直接输出成员变量值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+s.name); <span class="comment">//null</span></span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span>+s.age); <span class="comment">//0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;‐‐‐‐‐‐‐‐‐‐&quot;</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//给成员变量赋值</span></span><br><span class="line">        s.name = <span class="string">&quot;赵丽颖&quot;</span>;</span><br><span class="line">        s.age = <span class="number">18</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//再次输出成员变量的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+s.name); <span class="comment">//赵丽颖</span></span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span>+s.age); <span class="comment">//18</span></span><br><span class="line">        System.out.println(<span class="string">&quot;‐‐‐‐‐‐‐‐‐‐&quot;</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//调用成员方法</span></span><br><span class="line">        s.study(); <span class="comment">// &quot;好好学习，天天向上&quot;</span></span><br><span class="line">        s.eat(); <span class="comment">// &quot;学习饿了要吃饭&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-2、成员变量的默认值"><a href="#1-4-2、成员变量的默认值" class="headerlink" title="1.4.2、成员变量的默认值"></a>1.4.2、成员变量的默认值</h3><table>
<thead>
<tr>
<th></th>
<th>数据类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>基本类型</td>
<td>整数（byte，short，int，long)</td>
<td>0</td>
</tr>
<tr>
<td>…</td>
<td>浮点数（float，double)</td>
<td>0.0</td>
</tr>
<tr>
<td>…</td>
<td>字符（char)</td>
<td>‘\u0000’</td>
</tr>
<tr>
<td>…</td>
<td>布尔（boolean)</td>
<td>false</td>
</tr>
<tr>
<td>引用类型</td>
<td>数组，类，接口</td>
<td>null</td>
</tr>
</tbody></table>
<h2 id="1-5、类与对象的练习"><a href="#1-5、类与对象的练习" class="headerlink" title="1.5、类与对象的练习"></a>1.5、类与对象的练习</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义手机类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    String brand; <span class="comment">//品牌</span></span><br><span class="line">    <span class="keyword">int</span> price; <span class="comment">//价格</span></span><br><span class="line">    String color; <span class="comment">//颜色</span></span><br><span class="line">    <span class="comment">// 成员方法</span></span><br><span class="line">    <span class="comment">//打电话</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    		System.out.println(<span class="string">&quot;给&quot;</span>+name+<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发短信</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    		System.out.println(<span class="string">&quot;群发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        Phone p = <span class="keyword">new</span> Phone();</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//输出成员变量值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;品牌：&quot;</span>+p.brand);<span class="comment">//null</span></span><br><span class="line">        System.out.println(<span class="string">&quot;价格：&quot;</span>+p.price);<span class="comment">//0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;颜色：&quot;</span>+p.color);<span class="comment">//null</span></span><br><span class="line">        System.out.println(<span class="string">&quot;‐‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//给成员变量赋值</span></span><br><span class="line">        p.brand = <span class="string">&quot;锤子&quot;</span>;</span><br><span class="line">        p.price = <span class="number">2999</span>;</span><br><span class="line">        p.color = <span class="string">&quot;棕色&quot;</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//再次输出成员变量值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;品牌：&quot;</span>+p.brand);<span class="comment">//锤子</span></span><br><span class="line">        System.out.println(<span class="string">&quot;价格：&quot;</span>+p.price);<span class="comment">//2999</span></span><br><span class="line">        System.out.println(<span class="string">&quot;颜色：&quot;</span>+p.color);<span class="comment">//棕色</span></span><br><span class="line">        System.out.println(<span class="string">&quot;‐‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//调用成员方法</span></span><br><span class="line">        p.call(<span class="string">&quot;紫霞&quot;</span>);</span><br><span class="line">        p.sendMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="今日作业："><a href="#今日作业：" class="headerlink" title="今日作业："></a>今日作业：</h2><h6 id="Phone-类"><a href="#Phone-类" class="headerlink" title="Phone 类:"></a>Phone 类:</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id; <span class="comment">//编号</span></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">//手机名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price; <span class="comment">//价格</span></span><br><span class="line">    <span class="keyword">private</span> String color;   <span class="comment">//颜色</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">long</span> number)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;给&quot;</span>+ number + <span class="string">&quot;打电话！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">message</span><span class="params">(String messge)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消息为：&quot;</span> + messge);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>main 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Phone ph=<span class="keyword">new</span> Phone();</span><br><span class="line">    ph.setId(<span class="string">&quot;#123412&quot;</span>);</span><br><span class="line">    ph.setName(<span class="string">&quot;华为p20 pro&quot;</span>);</span><br><span class="line">    ph.setColor(<span class="string">&quot;火焰红&quot;</span>);</span><br><span class="line">    ph.setPrice(<span class="number">2800.00</span>);</span><br><span class="line">    ph.call(<span class="number">1234567890</span>);</span><br><span class="line">    ph.message(<span class="string">&quot;这是一条信息&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;手机类型为：&quot;</span> + ph.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;手机颜色为：&quot;</span> + ph.getColor());</span><br><span class="line">    System.out.println(<span class="string">&quot;手机价格为：&quot;</span> + ph.getPrice());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行截图：</p>
<p><img src="/2021/04/12/day04-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%B1%BB-%E5%AF%B9%E8%B1%A1/phone.png" width="65%"><img src="/2021/04/12/day04-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%B1%BB-%E5%AF%B9%E8%B1%A1/phoneMain.png" width="65%"></p>
<h6 id="Animal-类："><a href="#Animal-类：" class="headerlink" title="Animal 类："></a>Animal 类：</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String kind;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> weight;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> length;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getKind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kind;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKind</span><span class="params">(String kind)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.kind = kind;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">float</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLength</span><span class="params">(<span class="keyword">float</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String massge)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;说：&quot;</span> + massge);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Animal animal =<span class="keyword">new</span> Animal();</span><br><span class="line">    animal.setKind(<span class="string">&quot;哺乳动物&quot;</span>);</span><br><span class="line">    animal.setName(<span class="string">&quot;大熊猫&quot;</span>);</span><br><span class="line">    animal.setLength(<span class="number">1.65f</span>);</span><br><span class="line">    animal.setWeight(<span class="number">80.5f</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;我叫&quot;</span> + animal.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;我是&quot;</span> + animal.getKind());</span><br><span class="line">    System.out.println(<span class="string">&quot;我的体重是&quot;</span>+ animal.getWeight()+<span class="string">&quot;,我的体长是&quot;</span>+ animal.getLength());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行截图：</p>
<p><img src="/2021/04/12/day04-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%B1%BB-%E5%AF%B9%E8%B1%A1/animal.png" width="65%"><img src="/2021/04/12/day04-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%B1%BB-%E5%AF%B9%E8%B1%A1/animalMain.png" width="65%"></p>
<h6 id="Person-类"><a href="#Person-类" class="headerlink" title="Person 类"></a>Person 类</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> weight;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> lenght;</span><br><span class="line">    <span class="keyword">private</span> String hobby;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">float</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getLenght</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lenght;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLenght</span><span class="params">(<span class="keyword">float</span> lenght)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lenght = lenght;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHobby</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hobby;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHobby</span><span class="params">(String hobby)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hobby = hobby;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我要睡觉啦！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>main 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    person.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    person.setWeight(<span class="number">60.0f</span>);</span><br><span class="line">    person.setLenght(<span class="number">1.75f</span>);</span><br><span class="line">    person.setHobby(<span class="string">&quot;打篮球、打乒乓球、打游戏&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;我叫&quot;</span> + person.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;我的体重是&quot;</span> + person.getWeight() + <span class="string">&quot;公斤&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;我的身高是&quot;</span> + person.getLenght() + <span class="string">&quot;米&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;我的兴趣爱好有：&quot;</span>+ person.getHobby());</span><br><span class="line">    person.sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行截图：</p>
<p><img src="/2021/04/12/day04-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%B1%BB-%E5%AF%B9%E8%B1%A1/person.png" width="65%"><img src="/2021/04/12/day04-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%B1%BB-%E5%AF%B9%E8%B1%A1/personMain.png" width="65%"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>培训学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>day03-循环-方法进阶-数组</title>
    <url>/2021/04/11/day03-%E5%BE%AA%E7%8E%AF-%E6%96%B9%E6%B3%95%E8%BF%9B%E9%98%B6-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p><strong><em>今日学习内容：循环语句、方法进阶、数组</em></strong></p>
<span id="more"></span>

<h1 id="第一章、循环语句"><a href="#第一章、循环语句" class="headerlink" title="第一章、循环语句"></a>第一章、循环语句</h1><h2 id="1-1、循环语句概述"><a href="#1-1、循环语句概述" class="headerlink" title="1.1、循环语句概述"></a>1.1、循环语句概述</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句，当反复执行这个循环体时，需要在合适的时候把循环判断条件修改为<span class="keyword">false</span>，从而结束循环，否则循环将一直执行下去，形成死循环</span><br></pre></td></tr></table></figure>

<h2 id="1-2、循环语句1—for"><a href="#1-2、循环语句1—for" class="headerlink" title="1.2、循环语句1—for"></a>1.2、循环语句1—for</h2><h3 id="1-2-1、格式"><a href="#1-2-1、格式" class="headerlink" title="1.2.1、格式"></a>1.2.1、格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化语句; 判断条件语句; 条件控制语句)&#123;</span><br><span class="line">		循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-2、执行流程"><a href="#1-2-2、执行流程" class="headerlink" title="1.2.2、执行流程"></a>1.2.2、执行流程</h3><img src="/2021/04/11/day03-%E5%BE%AA%E7%8E%AF-%E6%96%B9%E6%B3%95%E8%BF%9B%E9%98%B6-%E6%95%B0%E7%BB%84/2019-12-14_14-56-11.jpg" alt="2019-12-14_14-56-11" style="zoom:33%;">

<h2 id="1-3、循环语句2—while"><a href="#1-3、循环语句2—while" class="headerlink" title="1.3、循环语句2—while"></a>1.3、循环语句2—while</h2><h3 id="1-3-1、格式"><a href="#1-3-1、格式" class="headerlink" title="1.3.1、格式"></a>1.3.1、格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">初始化表达式；</span><br><span class="line"><span class="keyword">while</span>(判断条件语句)&#123;</span><br><span class="line">	循环体</span><br><span class="line">	控制条件语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-2、执行流程"><a href="#1-3-2、执行流程" class="headerlink" title="1.3.2、执行流程"></a>1.3.2、执行流程</h3><img src="/2021/04/11/day03-%E5%BE%AA%E7%8E%AF-%E6%96%B9%E6%B3%95%E8%BF%9B%E9%98%B6-%E6%95%B0%E7%BB%84/2019-12-14_15-07-23.jpg" alt="2019-12-14_15-07-23" style="zoom:33%;">

<h2 id="1-4、循环语句3—do…while"><a href="#1-4、循环语句3—do…while" class="headerlink" title="1.4、循环语句3—do…while"></a>1.4、循环语句3—do…while</h2><h3 id="1-4-1、格式"><a href="#1-4-1、格式" class="headerlink" title="1.4.1、格式"></a>1.4.1、格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">初始化语句</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  循环体</span><br><span class="line">  条件控制语句</span><br><span class="line">&#125;<span class="keyword">while</span>(条件判断语句);</span><br><span class="line">⚠️注意：<span class="keyword">do</span>...<span class="keyword">while</span>循环的特点：无条件执行一次循环体，即使我们将循环条件直接写成<span class="keyword">false</span>，也依然会循环一次。这样的</span><br><span class="line">循环具有一定的风险性，因此初学者不建议使用<span class="keyword">do</span>...<span class="keyword">while</span>循环。</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;无条件执行一次&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-2、执行流程"><a href="#1-4-2、执行流程" class="headerlink" title="1.4.2、执行流程"></a>1.4.2、执行流程</h3><img src="/2021/04/11/day03-%E5%BE%AA%E7%8E%AF-%E6%96%B9%E6%B3%95%E8%BF%9B%E9%98%B6-%E6%95%B0%E7%BB%84/2019-12-14_15-15-01.jpg" alt="2019-12-14_15-15-01" style="zoom:33%;">

<h2 id="1-5、循环语句的区别"><a href="#1-5、循环语句的区别" class="headerlink" title="1.5、循环语句的区别"></a>1.5、循环语句的区别</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 和 <span class="keyword">while</span> 的小区别：</span><br><span class="line"><span class="number">1</span>）控制条件语句所控制的那个变量，在<span class="keyword">for</span>循环结束后，就不能再被访问到了，而<span class="keyword">while</span>循环结束还可以继续使用，如果你想继续		</span><br><span class="line">    使用，就用<span class="keyword">while</span>，否则推荐使用<span class="keyword">for</span>。原因是<span class="keyword">for</span>循环结束，该变量就从内存中消失，能够提高内存的使用效率。</span><br><span class="line"><span class="number">2</span>）在已知循环次数的时候使用推荐使用<span class="keyword">for</span>，循环次数未知的时推荐使用<span class="keyword">while</span>。</span><br></pre></td></tr></table></figure>

<h2 id="1-6、跳出语句"><a href="#1-6、跳出语句" class="headerlink" title="1.6、跳出语句"></a>1.6、跳出语句</h2><h3 id="1-6-1、break"><a href="#1-6-1、break" class="headerlink" title="1.6.1、break"></a>1.6.1、break</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">使用场景：终止<span class="keyword">switch</span>、循环</span><br><span class="line">	<span class="number">2</span>）在选择结构<span class="keyword">switch</span>语句中</span><br><span class="line">  	<span class="number">3</span>）在循环语句中</span><br><span class="line">	<span class="number">4</span>）离开使用场景的存在是没有意义的</span><br><span class="line"><span class="comment">// 示例：</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="comment">//需求:打印完两次HelloWorld之后结束循环</span></span><br><span class="line">      <span class="keyword">if</span>(i == <span class="number">3</span>)&#123;</span><br><span class="line">      	<span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    	System.out.println(<span class="string">&quot;HelloWorld&quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6-2、continue"><a href="#1-6-2、continue" class="headerlink" title="1.6.2、continue"></a>1.6.2、continue</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">使用场景：结束本次循环，继续下一次的循环</span><br><span class="line"><span class="comment">// 示例：</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="comment">//需求:不打印第三次HelloWorld</span></span><br><span class="line">      <span class="keyword">if</span>(i == <span class="number">3</span>)&#123;</span><br><span class="line">      	<span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    	System.out.println(<span class="string">&quot;HelloWorld&quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="第二章、扩展知识点"><a href="#第二章、扩展知识点" class="headerlink" title="第二章、扩展知识点"></a>第二章、扩展知识点</h1><h2 id="2-1、死循环"><a href="#2-1、死循环" class="headerlink" title="2.1、死循环"></a>2.1、死循环</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">定义：循环中的条件永远为<span class="keyword">true</span>，死循环的是永不结束的循环。例如：<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2、嵌套循环"><a href="#2-2、嵌套循环" class="headerlink" title="2.2、嵌套循环"></a>2.2、嵌套循环</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">所谓嵌套循环：是指一个循环的循环体是另一个循环。比如<span class="keyword">for</span>循环里面还有一个<span class="keyword">for</span>循环，就是嵌套循环。总共的循环次数=外循环次数*内循环次数。</span><br><span class="line">其中<span class="keyword">for</span>和<span class="keyword">while</span>、<span class="keyword">while</span>和<span class="keyword">while</span>、<span class="keyword">for</span>和<span class="keyword">for</span>等都可以相互嵌套。</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 格式：</span></span><br><span class="line">  <span class="keyword">for</span>(初始化语句<span class="number">1</span>; 判断条件语句<span class="number">1</span>; 控制条件语句<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(初始化语句<span class="number">2</span>; 判断条件语句<span class="number">2</span>; 控制条件语句<span class="number">2</span>) &#123;</span><br><span class="line">    		循环体 </span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 练习：使用嵌套循环，打印5*8的矩形</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//5*8的矩形，打印5行*号，每行8个</span></span><br><span class="line">  <span class="comment">//外循环5次，内循环8次</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)&#123;</span><br><span class="line">      <span class="comment">//不换行打印星号</span></span><br><span class="line">      System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//内循环打印8个星号后，需要一次换行</span></span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">｝</span><br><span class="line"><span class="comment">// 思考题：打印99乘法表</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/11/day03-%E5%BE%AA%E7%8E%AF-%E6%96%B9%E6%B3%95%E8%BF%9B%E9%98%B6-%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5.png" alt="矩阵"></p>
<p>九九乘法表：</p>
<p><img src="/2021/04/11/day03-%E5%BE%AA%E7%8E%AF-%E6%96%B9%E6%B3%95%E8%BF%9B%E9%98%B6-%E6%95%B0%E7%BB%84/%E4%B9%98%E6%B3%95%E8%A1%A8.png" alt="乘法表"></p>
<h1 id="第三章、方法进阶"><a href="#第三章、方法进阶" class="headerlink" title="第三章、方法进阶"></a>第三章、方法进阶</h1><h2 id="1、方法定义的格式详解"><a href="#1、方法定义的格式详解" class="headerlink" title="1、方法定义的格式详解"></a>1、方法定义的格式详解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数列表)&#123;</span><br><span class="line">  <span class="comment">//代码省略...</span></span><br><span class="line">  <span class="keyword">return</span> 结果;</span><br><span class="line">&#125;	</span><br><span class="line"><span class="number">1</span>）修饰符： <span class="keyword">public</span> <span class="keyword">static</span> 固定写法</span><br><span class="line"><span class="number">2</span>）返回值类型： 表示方法运行的结果的数据类型，方法执行后将结果返回到调用者</span><br><span class="line"><span class="number">3</span>）参数列表：方法在运算过程中的未知数据，调用者调用方法时传递</span><br><span class="line"><span class="number">4</span>）<span class="keyword">return</span>：将方法执行后的结果带给调用者，方法执行到 <span class="keyword">return</span> ，整个方法运行结束</span><br><span class="line"><span class="number">5</span>）<span class="keyword">return</span> 结果; 这里的<span class="string">&quot;结果&quot;</span>在开发中，我们正确的叫法成为方法的返回值</span><br></pre></td></tr></table></figure>

<h2 id="2、定义方法的两个明确"><a href="#2、定义方法的两个明确" class="headerlink" title="2、定义方法的两个明确"></a>2、定义方法的两个明确</h2><p>1）明确返回值类型：方法计算的是整数的求和，结果也必然是个整数，返回值类型定义为 int 类型。<br>2）明确参数列表：计算哪两个整数的和，并不清楚，但可以确定是整数，参数列表可以定义两个 int 类型的变量，由调用者调用方法时传递</p>
<h2 id="3、方法调用流程图解"><a href="#3、方法调用流程图解" class="headerlink" title="3、方法调用流程图解"></a>3、方法调用流程图解</h2><img src="/2021/04/11/day03-%E5%BE%AA%E7%8E%AF-%E6%96%B9%E6%B3%95%E8%BF%9B%E9%98%B6-%E6%95%B0%E7%BB%84/2019-12-14_15-58-45.jpg" alt="2019-12-14_15-58-45" style="zoom:33%;">

<h2 id="3、定义方法练习"><a href="#3、定义方法练习" class="headerlink" title="3、定义方法练习"></a>3、定义方法练习</h2><h3 id="3-1、练习一"><a href="#3-1、练习一" class="headerlink" title="3.1、练习一"></a>3.1、练习一</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比较两个整数是否相同</span></span><br><span class="line">分析：定义方法实现功能，需要有两个明确，即 返回值 和 参数列表 </span><br><span class="line">	<span class="number">1</span>）明确返回值：比较整数，比较的结果只有两种可能，相同或不同，因此结果是布尔类型，比较的结果相同为<span class="keyword">true</span></span><br><span class="line">	<span class="number">2</span>）明确参数列表：比较的两个整数不确定，所以默认定义两个<span class="keyword">int</span>类型的参数</span><br></pre></td></tr></table></figure>

<h3 id="3-2、练习二"><a href="#3-2、练习二" class="headerlink" title="3.2、练习二"></a>3.2、练习二</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算1+2+3...+100的和</span></span><br><span class="line">分析：定义方法实现功能，需要有两个明确，即 返回值 和 参数 </span><br><span class="line">	<span class="number">1</span>）明确返回值：<span class="number">1</span>~<span class="number">100</span>的求和，计算后必然还是整数，返回值类型是<span class="keyword">int</span></span><br><span class="line">	<span class="number">2</span>）明确参数：需求中已知到计算的数据，没有未知的数据，不定义参数</span><br></pre></td></tr></table></figure>

<h3 id="3-3、练习三"><a href="#3-3、练习三" class="headerlink" title="3.3、练习三"></a>3.3、练习三</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现不定次数打印</span></span><br><span class="line">分析：定义方法实现功能，需要有两个明确，即 返回值 和 参数 </span><br><span class="line">	<span class="number">1</span>）明确返回值：方法中打印出 HelloWorld 即可，没有计算结果，返回值类型 <span class="keyword">void</span> </span><br><span class="line">	<span class="number">2</span>）明确参数：打印几次不清楚，参数定义一个整型参数</span><br></pre></td></tr></table></figure>

<h2 id="4、定义方法的注意事项"><a href="#4、定义方法的注意事项" class="headerlink" title="4、定义方法的注意事项"></a>4、定义方法的注意事项</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）定义位置，类中方法外面。</span><br><span class="line"><span class="number">2</span>）返回值类型，必须要和 <span class="keyword">return</span> 语句返回的类型相同，否则编译失败 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5、方法调用的三种形式"><a href="#5、方法调用的三种形式" class="headerlink" title="5、方法调用的三种形式"></a>5、方法调用的三种形式</h2><h3 id="5-1、直接调用"><a href="#5-1、直接调用" class="headerlink" title="5.1、直接调用"></a>5.1、直接调用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接写方法名调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		print();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;方法被调用&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2、赋值调用"><a href="#5-2、赋值调用" class="headerlink" title="5.2、赋值调用"></a>5.2、赋值调用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用方法，在方法前面定义变量，接收方法返回值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = getSum(<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3、输出语句调用"><a href="#5-3、输出语句调用" class="headerlink" title="5.3、输出语句调用"></a>5.3、输出语句调用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在输出语句中调用方法， System.out.println(方法名());</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(getSum(<span class="number">5</span>,<span class="number">6</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不能用输出语句调用 void 类型的方法。因为方法执行后没有结果，也就打印不出任何内容</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(printHello());<span class="comment">// 错误，不能输出语句调用void类型方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6、方法重载（overload）"><a href="#6、方法重载（overload）" class="headerlink" title="6、方法重载（overload）"></a>6、方法重载（overload）</h2><h3 id="6-1、什么是方法重载"><a href="#6-1、什么是方法重载" class="headerlink" title="6.1、什么是方法重载"></a>6.1、什么是方法重载</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法重载：指在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可，与修饰符和返回值类型无关</span></span><br><span class="line"><span class="comment">// 特点：</span></span><br><span class="line">    <span class="number">1</span>）参数列表：个数不同 、数据类型不同 、顺序不同 </span><br><span class="line">    <span class="number">2</span>）重载方法调用：JVM通过方法的参数列表，调用不同的方法</span><br></pre></td></tr></table></figure>

<h1 id="第四章、数组的定义和访问"><a href="#第四章、数组的定义和访问" class="headerlink" title="第四章、数组的定义和访问"></a>第四章、数组的定义和访问</h1><h2 id="4-1、容器概述"><a href="#4-1、容器概述" class="headerlink" title="4.1、容器概述"></a>4.1、容器概述</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 案例分析：</span></span><br><span class="line">	现在需要统计某公司员工的工资情况，例如计算平均工资、找到最高工资等。假设该公司有<span class="number">50</span>名员工，用前面所学的知识，程序首先需要声明<span class="number">50</span>个变量来分别记住每位员工的工资，然后在进行操作，这样做会显得很麻烦，而且错误率也会很高。因此我们可以使用容器进行操作。将所有的数据全部存储到一个容器中，统一操作</span><br><span class="line"><span class="comment">// 容器概念</span></span><br><span class="line">	容器：是将多个数据存储到一起，每个数据称为该容器的元素</span><br><span class="line">  生活中的容器：水杯，衣柜，教室</span><br></pre></td></tr></table></figure>

<h2 id="4-2、数组的概念"><a href="#4-2、数组的概念" class="headerlink" title="4.2、数组的概念"></a>4.2、数组的概念</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组：就是存储固定长度数据的容器，保证多个数据的数据类型要一致</span></span><br></pre></td></tr></table></figure>

<h2 id="4-3、数组的定义"><a href="#4-3、数组的定义" class="headerlink" title="4.3、数组的定义"></a>4.3、数组的定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数组定义格式详解：</span><br><span class="line">  <span class="number">1</span>）数组存储的数据类型： 创建的数组容器可以存储什么数据类型。</span><br><span class="line">  <span class="number">2</span>）[] : 表示数组。</span><br><span class="line">  <span class="number">3</span>）数组名字：为定义的数组起个变量名，满足标识符规范，可以使用名字操作数组。</span><br><span class="line">  <span class="number">4</span>）<span class="keyword">new</span>：关键字，创建数组使用的关键字。</span><br><span class="line">  <span class="number">5</span>）数组存储的数据类型： 创建的数组容器可以存储什么数据类型。</span><br><span class="line">  <span class="number">6</span>）[长度]：数组的长度，表示数组容器中可以存储多少个元素。</span><br><span class="line">  <span class="number">7</span>）注意：</span><br><span class="line">  		数组有定长特性，长度一旦指定，不可更改，和水杯道理相同，买了一个<span class="number">2</span>升的水杯，总容量就是<span class="number">2</span>升，不能多也不能少</span><br></pre></td></tr></table></figure>

<h3 id="4-3-1、方式一"><a href="#4-3-1、方式一" class="headerlink" title="4.3.1、方式一"></a>4.3.1、方式一</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 格式：</span></span><br><span class="line">	数组存储的数据类型[] 数组名字 = <span class="keyword">new</span> 数组存储的数据类型[长度];</span><br><span class="line"><span class="comment">// 示例：定义一个可以存储3个整数的数组容器</span></span><br><span class="line">	<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<h3 id="4-3-2、方式二"><a href="#4-3-2、方式二" class="headerlink" title="4.3.2、方式二"></a>4.3.2、方式二</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 格式</span></span><br><span class="line">	数据类型[] 数组名 = <span class="keyword">new</span> 数据类型[]&#123;元素<span class="number">1</span>,元素<span class="number">2</span>,元素<span class="number">3.</span>..&#125;;</span><br><span class="line"><span class="comment">// 示例：定义一个存储1，2，3，4，5整数的数组容器</span></span><br><span class="line">	<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-3、方式三"><a href="#4-3-3、方式三" class="headerlink" title="4.3.3、方式三"></a>4.3.3、方式三</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 格式</span></span><br><span class="line">	数据类型[] 数组名 = &#123;元素<span class="number">1</span>,元素<span class="number">2</span>,元素<span class="number">3.</span>..&#125;;</span><br><span class="line"><span class="comment">// 示例：定义一个存储1，2，3，4，5整数的数组容器</span></span><br><span class="line">	<span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-4、数组的访问（重点）"><a href="#4-4、数组的访问（重点）" class="headerlink" title="4.4、数组的访问（重点）"></a>4.4、数组的访问（重点）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 索引： 每一个存储到数组的元素，都会自动的拥有一个编号，从0开始，这个自动编号称为数组索引 (index)，可以通过数组的索引访问到数组中的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式：数组名[索引]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引访问数组中的元素：</span></span><br><span class="line">	<span class="number">1</span>）数组名[索引]=数值		为数组中的元素赋值</span><br><span class="line">	<span class="number">2</span>）变量=数组名[索引]		获取出数组中的元素</span><br><span class="line"><span class="comment">// 示例：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义存储int类型数组，赋值元素1，2，3，4，5</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="comment">//为0索引元素赋值为6</span></span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">6</span>;</span><br><span class="line">        <span class="comment">//获取数组0索引上的元素</span></span><br><span class="line">        <span class="keyword">int</span> i = arr[<span class="number">0</span>];</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        <span class="comment">//直接输出数组0索引元素</span></span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="第五章、数组原理内存图"><a href="#第五章、数组原理内存图" class="headerlink" title="第五章、数组原理内存图"></a>第五章、数组原理内存图</h1><h2 id="5-1、内存概述"><a href="#5-1、内存概述" class="headerlink" title="5.1、内存概述"></a>5.1、内存概述</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）内存是计算机中的重要原件，临时存储区域，作用是运行程序。我们编写的程序是存放在硬盘中的，在硬盘中的程序是不会运行的，必须放进内存中才能运行，运行完毕后会清空内存。</span><br><span class="line"><span class="number">2</span>）Java虚拟机要运行程序，必须要对内存进行空间的分配和管理</span><br></pre></td></tr></table></figure>

<h2 id="5-2、Java虚拟机内存划分"><a href="#5-2、Java虚拟机内存划分" class="headerlink" title="5.2、Java虚拟机内存划分"></a>5.2、Java虚拟机内存划分</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式</span></span><br><span class="line">JVM内存划分：</span><br><span class="line">  	寄存器       给CPU使用，和我们开发无关。</span><br><span class="line">	本地方法栈   JVM在使用操作系统功能的时候使用，和我们开发无关。</span><br><span class="line">	方法区 	 存储可以运行的<span class="class"><span class="keyword">class</span>文件。</span></span><br><span class="line"><span class="class">	堆内存 	 存储对象或者数组，<span class="title">new</span>来创建的，都存储在堆内存。</span></span><br><span class="line"><span class="class">	方法栈      方法运行时使用的内存，比如<span class="title">main</span>方法运行，进入方法栈中执行</span></span><br></pre></td></tr></table></figure>

<img src="/2021/04/11/day03-%E5%BE%AA%E7%8E%AF-%E6%96%B9%E6%B3%95%E8%BF%9B%E9%98%B6-%E6%95%B0%E7%BB%84/2019-12-14_16-40-54.jpg" alt="2019-12-14_16-40-54" style="zoom: 50%;">

<h2 id="5-3、数组在内存中的存储"><a href="#5-3、数组在内存中的存储" class="headerlink" title="5.3、数组在内存中的存储"></a>5.3、数组在内存中的存储</h2><h3 id="5-3-1、一个数组内存图"><a href="#5-3-1、一个数组内存图" class="headerlink" title="5.3.1、一个数组内存图"></a>5.3.1、一个数组内存图</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">    System.out.println(arr);<span class="comment">//[I@5f150435</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span>）以上方法执行，输出的结果是[I@5f150435，这个是什么呢？是数组在内存中的地址。</span><br><span class="line"><span class="number">2</span>）<span class="keyword">new</span>出来的内容，都是在堆内存中存储的，而方法中的变量arr保存的是数组的地址</span><br><span class="line"><span class="number">3</span>）输出arr[<span class="number">0</span>]，就会输出arr保存的内存地址中数组中<span class="number">0</span>索引上的元素</span><br></pre></td></tr></table></figure>

<img src="/2021/04/11/day03-%E5%BE%AA%E7%8E%AF-%E6%96%B9%E6%B3%95%E8%BF%9B%E9%98%B6-%E6%95%B0%E7%BB%84/2019-12-14_16-44-38.jpg" alt="2019-12-14_16-44-38" style="zoom:50%;">

<h3 id="5-3-2、两个数组内存图"><a href="#5-3-2、两个数组内存图" class="headerlink" title="5.3.2、两个数组内存图"></a>5.3.2、两个数组内存图</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    System.out.println(arr);</span><br><span class="line">    System.out.println(arr2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2021/04/11/day03-%E5%BE%AA%E7%8E%AF-%E6%96%B9%E6%B3%95%E8%BF%9B%E9%98%B6-%E6%95%B0%E7%BB%84/2019-12-14_16-46-48.jpg" alt="2019-12-14_16-46-48" style="zoom:50%;">

<h3 id="5-3-3、两个变量指向一个数组"><a href="#5-3-3、两个变量指向一个数组" class="headerlink" title="5.3.3、两个变量指向一个数组"></a>5.3.3、两个变量指向一个数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义数组，存储3个元素</span></span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">    <span class="comment">//数组索引进行赋值</span></span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">6</span>;</span><br><span class="line">    arr[<span class="number">2</span>] = <span class="number">7</span>;</span><br><span class="line">    <span class="comment">//输出3个索引上的元素值</span></span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">//定义数组变量arr2，将arr的地址赋值给arr2</span></span><br><span class="line">    <span class="keyword">int</span>[] arr2 = arr;</span><br><span class="line">    arr2[<span class="number">1</span>] = <span class="number">9</span>; </span><br><span class="line">    System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2021/04/11/day03-%E5%BE%AA%E7%8E%AF-%E6%96%B9%E6%B3%95%E8%BF%9B%E9%98%B6-%E6%95%B0%E7%BB%84/2019-12-14_16-48-00.jpg" alt="2019-12-14_16-48-00" style="zoom:50%;">

<p><img src="/2021/04/11/day03-%E5%BE%AA%E7%8E%AF-%E6%96%B9%E6%B3%95%E8%BF%9B%E9%98%B6-%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84.png" alt="数组"></p>
<h1 id="第六章、数组的常见操作"><a href="#第六章、数组的常见操作" class="headerlink" title="第六章、数组的常见操作"></a>第六章、数组的常见操作</h1><h2 id="6-1、数组越界异常"><a href="#6-1、数组越界异常" class="headerlink" title="6.1、数组越界异常"></a>6.1、数组越界异常</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 观察代码：运行后会出现什么结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">// 0 1 2</span></span><br><span class="line">    System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分析：创建数组，赋值3个元素，数组的索引就是0，1，2，没有3索引，因此我们不能访问数组中不存在的索引，程序运行后，将会抛出 ArrayIndexOutOfBoundsException 数组越界异常。在开发中，数组的越界异常是不能出现的，一旦出现了，就必须要修改我们编写的代码</span></span><br></pre></td></tr></table></figure>

<h2 id="6-2、数组空指针异常"><a href="#6-2、数组空指针异常" class="headerlink" title="6.2、数组空指针异常"></a>6.2、数组空指针异常</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 观察代码：运行后会出现什么结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    arr = <span class="keyword">null</span>;</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">｝</span><br><span class="line"><span class="comment">// 分析：arr = null 这行代码，意味着变量arr将不会在保存数组的内存地址，也就不允许再操作数组了，因此运行的时候会抛出 NullPointerException 空指针异常。在开发中，数组的空指针异常是不能出现的，一旦出现了，就必须要修改我们编写的代码</span></span><br><span class="line"><span class="comment">// 分析内存图</span></span><br></pre></td></tr></table></figure>

<h2 id="6-3、数组的遍历（重点）"><a href="#6-3、数组的遍历（重点）" class="headerlink" title="6.3、数组的遍历（重点）"></a>6.3、数组的遍历（重点）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组遍历： 就是将数组中的每个元素分别获取出来，就是遍历。遍历也是数组操作中的基础</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">4</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化：以上代码是可以将数组中每个元素全部遍历出来，但是如果数组元素非常多，这种写法肯定不行，因此我们需要改造成循环的写法。数组的索引是 0 到 lenght-1 ，可以作为循环的条件出现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    		System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/11/day03-%E5%BE%AA%E7%8E%AF-%E6%96%B9%E6%B3%95%E8%BF%9B%E9%98%B6-%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86.png" alt="数组遍历"></p>
<h2 id="6-4、数组获取最大值元素"><a href="#6-4、数组获取最大值元素" class="headerlink" title="6.4、数组获取最大值元素"></a>6.4、数组获取最大值元素</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最大值获取：从数组的所有元素中找出最大值</span></span><br><span class="line"><span class="comment">// 实现思路：</span></span><br><span class="line">      <span class="number">1</span>）定义变量，保存数组<span class="number">0</span>索引上的元素</span><br><span class="line">      <span class="number">2</span>）遍历数组，获取出数组中的每个元素</span><br><span class="line">      <span class="number">3</span>）将遍历到的元素和保存数组<span class="number">0</span>索引上值的变量进行比较</span><br><span class="line">      <span class="number">4</span>）如果数组元素的值大于了变量的值，变量记录住新的值</span><br><span class="line">      <span class="number">5</span>）数组循环遍历结束，变量保存的就是数组中的最大值</span><br><span class="line"><span class="comment">// 示例：</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span>[] arr = &#123; <span class="number">5</span>, <span class="number">15</span>, <span class="number">2000</span>, <span class="number">10000</span>, <span class="number">100</span>, <span class="number">4000</span> &#125;;</span><br><span class="line">            <span class="comment">//定义变量，保存数组中0索引的元素</span></span><br><span class="line">            <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">//遍历数组，取出每个元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="comment">//遍历到的元素和变量max比较</span></span><br><span class="line">                <span class="comment">//如果数组元素大于max</span></span><br><span class="line">                <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">                    <span class="comment">//max记录住大值</span></span><br><span class="line">                    max = arr[i];</span><br><span class="line">            	&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;数组最大值是： &quot;</span> + max);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/11/day03-%E5%BE%AA%E7%8E%AF-%E6%96%B9%E6%B3%95%E8%BF%9B%E9%98%B6-%E6%95%B0%E7%BB%84/%E6%9C%80%E5%A4%A7%E5%80%BC.png" alt="最大值"></p>
<h2 id="6-5、数组反转"><a href="#6-5、数组反转" class="headerlink" title="6.5、数组反转"></a>6.5、数组反转</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组的反转： 数组中的元素颠倒顺序，例如原始数组为1,2,3,4,5，反转后的数组为5,4,3,2,1</span></span><br><span class="line"><span class="comment">// 实现思想：数组最远端的元素互换位置。实现反转，就需要将数组最远端元素位置交换</span></span><br><span class="line">      <span class="number">1</span>）定义两个变量，保存数组的最小索引和最大索引</span><br><span class="line">      <span class="number">2</span>）两个索引上的元素交换位置</span><br><span class="line">      <span class="number">3</span>）最小索引++，最大索引--，再次交换位置</span><br><span class="line">      <span class="number">4</span>）最小索引超过了最大索引，数组反转操作结束</span><br><span class="line"><span class="comment">// 示例：</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">            循环中定义变量min=0最小索引</span></span><br><span class="line"><span class="comment">            max=arr.length‐1最大索引</span></span><br><span class="line"><span class="comment">            min++,max‐‐</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> min = <span class="number">0</span>, max = arr.length ‐ <span class="number">1</span>; min &lt;= max; min++, max‐‐) &#123;</span><br><span class="line">              <span class="comment">//利用第三方变量完成数组中的元素交换</span></span><br><span class="line">              <span class="keyword">int</span> temp = arr[min];</span><br><span class="line">              arr[min] = arr[max];</span><br><span class="line">              arr[max] = temp;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 遍历输出反转后的数组</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">              System.out.println(arr[i]);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/11/day03-%E5%BE%AA%E7%8E%AF-%E6%96%B9%E6%B3%95%E8%BF%9B%E9%98%B6-%E6%95%B0%E7%BB%84/%E9%80%86%E5%BA%8F.png" alt="逆序"></p>
<h1 id="第七章、数组作为方法参数或返回值"><a href="#第七章、数组作为方法参数或返回值" class="headerlink" title="第七章、数组作为方法参数或返回值"></a>第七章、数组作为方法参数或返回值</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">以前的方法中我们学习了方法的参数和返回值，但是使用的都是基本数据类型。那么作为引用类型的数组能否作为</span><br><span class="line">方法的参数进行传递呢，当然是可以的</span><br><span class="line">⚠️注意：</span><br><span class="line">  <span class="number">1</span>）数组是引用数据类型，引用数据类型作为方法参数或返回值，传递的都是内存地址</span><br><span class="line">  <span class="number">2</span>）方法的参数为基本类型时,传递的是数据值. 方法的参数为引用类型时,传递的是地址值</span><br></pre></td></tr></table></figure>

<h2 id="7-1、数组作为方法参数"><a href="#7-1、数组作为方法参数" class="headerlink" title="7.1、数组作为方法参数"></a>7.1、数组作为方法参数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组作为方法参数传递，传递的参数是数组内存的地址</span></span><br><span class="line"><span class="comment">// 示例：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line">  <span class="comment">//调用方法，传递数组</span></span><br><span class="line">  printArray(arr);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建方法，方法接收数组类型的参数</span></span><br><span class="line"><span class="comment">进行数组的遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  		System.out.println(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2021/04/11/day03-%E5%BE%AA%E7%8E%AF-%E6%96%B9%E6%B3%95%E8%BF%9B%E9%98%B6-%E6%95%B0%E7%BB%84/2019-12-14_17-09-25.jpg" alt="2019-12-14_17-09-25" style="zoom: 50%;">

<h2 id="7-2、数组作为方法返回值"><a href="#7-2、数组作为方法返回值" class="headerlink" title="7.2、数组作为方法返回值"></a>7.2、数组作为方法返回值</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组作为方法的返回值，返回的是数组的内存地址</span></span><br><span class="line"><span class="comment">// 示例：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用方法，接收数组的返回值</span></span><br><span class="line">    <span class="comment">//接收到的是数组的内存地址</span></span><br><span class="line">    <span class="keyword">int</span>[] arr = getArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    		System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建方法，返回值是数组类型</span></span><br><span class="line"><span class="comment">return返回数组的地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getArray() &#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line">    <span class="comment">//返回数组的地址，返回到调用者</span></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2021/04/11/day03-%E5%BE%AA%E7%8E%AF-%E6%96%B9%E6%B3%95%E8%BF%9B%E9%98%B6-%E6%95%B0%E7%BB%84/2019-12-14_17-12-28.jpg" alt="2019-12-14_17-12-28" style="zoom:50%;">

<h2 id="7-3、方法的参数类型区别"><a href="#7-3、方法的参数类型区别" class="headerlink" title="7.3、方法的参数类型区别"></a>7.3、方法的参数类型区别</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码分析</span></span><br><span class="line"><span class="number">1</span>）分析下列程序代码，计算输出结果。</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">    change(a, b); <span class="comment">// 基本数据类型作为参数，是值传递</span></span><br><span class="line">    System.out.println(a); <span class="comment">// a = 1</span></span><br><span class="line">    System.out.println(b); <span class="comment">// b = 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    a = a + b; <span class="comment">// 3</span></span><br><span class="line">    b = b + a; <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）分析下列程序代码，计算输出结果。</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]); <span class="comment">// 1</span></span><br><span class="line">    change(arr); <span class="comment">// 引用类型作为参数，是引用传递</span></span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]); <span class="comment">// 200</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line">⚠️总结：方法的参数为基本类型时,传递的是数据值. 方法的参数为引用类型时,传递的是地址值</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/11/day03-%E5%BE%AA%E7%8E%AF-%E6%96%B9%E6%B3%95%E8%BF%9B%E9%98%B6-%E6%95%B0%E7%BB%84/%E6%8E%92%E5%BA%8F.png" alt="排序"></p>
<h3 id="局部数组变量回收"><a href="#局部数组变量回收" class="headerlink" title="局部数组变量回收"></a><font style="color:red">局部数组变量回收</font></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    fun(a);</span><br><span class="line">    System.out.print(<span class="string">&quot;倒序输出为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;  &quot;</span>+a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len= a.length;</span><br><span class="line">    <span class="keyword">int</span>[] b=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--,j++) &#123;</span><br><span class="line">        b[j]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;  &quot;</span>+b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    a=b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2021/04/11/day03-%E5%BE%AA%E7%8E%AF-%E6%96%B9%E6%B3%95%E8%BF%9B%E9%98%B6-%E6%95%B0%E7%BB%84/%E5%B1%80%E9%83%A8%E6%95%B0%E7%BB%84%E5%9B%9E%E6%94%B6.png" alt="局部数组回收"></p>
<p>由图可知，当一个新的数组在方法中被声明时，及时从主方法中传递过来了 a数组的值，但在fun 方法中并不能影响到主方法中的 a 数组。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>培训学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>day02-类型转换-运算符-码表-方法-流程结构</title>
    <url>/2021/04/08/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E8%BF%90%E7%AE%97%E7%AC%A6-%E7%A0%81%E8%A1%A8-%E6%96%B9%E6%B3%95-%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p><strong><em>今日学习内容：数据类型转换、算数运算符、比较运算符、逻辑运算符、三元运算符、码表、方法的定义及调用、流程控制结构。</em></strong></p>
<span id="more"></span>

<h1 id="第一章、数据类型转换"><a href="#第一章、数据类型转换" class="headerlink" title="第一章、数据类型转换"></a>第一章、数据类型转换</h1><h2 id="1-1什么是数据类型转换"><a href="#1-1什么是数据类型转换" class="headerlink" title="1.1什么是数据类型转换"></a>1.1什么是数据类型转换</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java程序中要求参与的计算的数据，必须要保证数据类型的一致性，如果数据类型不一致将发生类型的转换</span><br></pre></td></tr></table></figure>

<h2 id="1-2、自动转换"><a href="#1-2、自动转换" class="headerlink" title="1.2、自动转换"></a>1.2、自动转换</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">byte</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> j = b + i;</span><br><span class="line">  System.out.println(j);</span><br><span class="line">&#125;</span><br><span class="line">⚠️自动转换：将 取值范围小的类型 自动提升为 取值范围大的类型</span><br><span class="line">⚠️转换规则：</span><br><span class="line">  范围小的类型向范围大的类型提升， <span class="keyword">byte</span>、<span class="keyword">short</span>、<span class="keyword">char</span> 运算时直接提升为 <span class="keyword">int</span> </span><br><span class="line">	<span class="keyword">byte</span>、<span class="keyword">short</span>、<span class="keyword">char</span>‐‐&gt;<span class="keyword">int</span>‐‐&gt;<span class="keyword">long</span>‐‐&gt;<span class="keyword">float</span>‐‐&gt;<span class="keyword">double</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/08/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E8%BF%90%E7%AE%97%E7%AC%A6-%E7%A0%81%E8%A1%A8-%E6%96%B9%E6%B3%95-%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84/%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2.png" alt="自动转换"></p>
<h2 id="1-3、强制转换"><a href="#1-3、强制转换" class="headerlink" title="1.3、强制转换"></a>1.3、强制转换</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">⚠️强制类型转换：将 取值范围大的类型 强制转换成 取值范围小的类型</span><br><span class="line">    转换格式：数据类型 变量名 = （数据类型）被转数据</span><br><span class="line">  </span><br><span class="line">⚠️区别：自动转换是Java自动执行的，而强制转换需要我们自己手动执行</span><br><span class="line">  </span><br><span class="line">⚠️浮点转成整数，直接取消小数点，可能造成数据损失精度。</span><br><span class="line">⚠️<span class="keyword">int</span> 强制转成 <span class="keyword">short</span> 砍掉<span class="number">2</span>个字节，可能造成数据丢失</span><br></pre></td></tr></table></figure>

<h2 id="1-4、ASCII码表"><a href="#1-4、ASCII码表" class="headerlink" title="1.4、ASCII码表"></a>1.4、ASCII码表</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">⚠️在计算机的内部都是二进制的<span class="number">0</span>、<span class="number">1</span>数据，如何让计算机可以直接识别人类文字的问题呢？就产生出了编码表的概念</span><br><span class="line">⚠️编码表 ：就是将人类的文字和一个十进制数进行对应起来组成一张表格</span><br></pre></td></tr></table></figure>

<h1 id="第二章、运算符"><a href="#第二章、运算符" class="headerlink" title="第二章、运算符"></a>第二章、运算符</h1><h2 id="2-1、算术运算符"><a href="#2-1、算术运算符" class="headerlink" title="2.1、算术运算符"></a>2.1、算术运算符</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">+				加法、字符串拼接（数字就加法，字符串就是拼接）</span><br><span class="line">-				减法</span><br><span class="line">*				乘法</span><br><span class="line">/				除法</span><br><span class="line">%				取模（取余：两个数相除取余数）</span><br><span class="line">++			自增（基于自身加<span class="number">1</span>）</span><br><span class="line">--			自减（基于自身减<span class="number">1</span>）</span><br></pre></td></tr></table></figure>

<h2 id="2-2、赋值运算符"><a href="#2-2、赋值运算符" class="headerlink" title="2.2、赋值运算符"></a>2.2、赋值运算符</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">= 			赋值符号（将符号右边的值，赋给左边的变量）</span><br><span class="line">+= 			加等于 a += ;  a = a + </span><br><span class="line">-= 			减等于</span><br><span class="line">*= 			乘等于</span><br><span class="line">/= 			除等于</span><br><span class="line">%= 			模等于</span><br></pre></td></tr></table></figure>

<h2 id="2-2-1、-思考题"><a href="#2-2-1、-思考题" class="headerlink" title="2.2.1、+=思考题"></a>2.2.1、+=思考题</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）下面的程序有问题吗？</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> s = <span class="number">1</span>;</span><br><span class="line">    s += <span class="number">1</span>; </span><br><span class="line">    System.out.println(s);</span><br><span class="line">	&#125;</span><br><span class="line">⚠️分析： s += <span class="number">1</span> 逻辑上看作是 s = s + <span class="number">1</span> 计算结果被提升为<span class="keyword">int</span>类型，再向<span class="keyword">short</span>类型赋值时发生错误，因为不能将取值范围大的类型赋值到取值范围小的类型。</span><br><span class="line">    但是， s = s + <span class="number">1</span> 进行两次运算 ， += 是一个运算符，只运算一次，并带有强制转换的特点，也就是说 s += <span class="number">1</span> 就是 s = (<span class="keyword">short</span>)(s + <span class="number">1</span>) ，因此程序没有问题编译通过，运行结果是<span class="number">2.</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/08/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E8%BF%90%E7%AE%97%E7%AC%A6-%E7%A0%81%E8%A1%A8-%E6%96%B9%E6%B3%95-%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84/%E6%80%9D%E8%80%83%E9%A2%981.png" alt="思考题1"></p>
<p><strong style="color:red">+=  是一个整体的运算符，带有强制转换特点。</strong></p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>）下面的程序有问题吗？</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> b1=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">byte</span> b2=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">byte</span> b3=<span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">byte</span> b4=b1 + b2;</span><br><span class="line">    System.out.println(b3);</span><br><span class="line">    System.out.println(b4);</span><br><span class="line">	&#125;</span><br><span class="line">⚠️分析： b3 = <span class="number">1</span> + <span class="number">2</span> ， <span class="number">1</span> 和 <span class="number">2</span> 是常量，为固定不变的数据，在编译的时候（编译器javac），已经确定了 <span class="number">1</span>+<span class="number">2</span> 的结果并没有超过<span class="keyword">byte</span>类型的取值范围，可以赋值给变量 b3 ，因此 b3=<span class="number">1</span> + <span class="number">2</span> 是正确的。</span><br><span class="line">	反之， b4 = b2 + b3 ， b2 和 b3 是变量，变量的值是可能变化的，在编译的时候，编译器javac不确定b2+b3的结果是什么，因此会将结果以<span class="keyword">int</span>类型进行处理，所以<span class="keyword">int</span>类型不能赋值给<span class="keyword">byte</span>类型，因此编译失败</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/08/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E8%BF%90%E7%AE%97%E7%AC%A6-%E7%A0%81%E8%A1%A8-%E6%96%B9%E6%B3%95-%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84/%E6%80%9D%E8%80%83%E9%A2%982.png" alt="思考题2"></p>
<p><strong style="color:red">变量运算时，编译为 int 类型;</strong></p>
<p><strong style="color:red">常量运算时，编译为常量类型。</strong></p>
<h2 id="2-3、比较运算符"><a href="#2-3、比较运算符" class="headerlink" title="2.3、比较运算符"></a>2.3、比较运算符</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">⚠️比较运算符，是两个数据之间进行比较的运算，运算结果都是布尔值 <span class="keyword">true</span> 或者 <span class="keyword">false</span> </span><br><span class="line">  </span><br><span class="line">== 			比较符号两边数据是否相等，相等结果是<span class="keyword">true</span></span><br><span class="line">&lt; 			比较符号左边的数据是否小于右边的数据，如果小于结果是<span class="keyword">true</span></span><br><span class="line">&gt; 			比较符号左边的数据是否大于右边的数据，如果大于结果是<span class="keyword">true</span></span><br><span class="line">&lt;= 			比较符号左边的数据是否小于或者等于右边的数据，如果小于结果是<span class="keyword">true</span></span><br><span class="line">&gt;= 			比较符号左边的数据是否大于或者等于右边的数据，如果小于结果是<span class="keyword">true</span></span><br><span class="line">!=		  	不等于符号 ，如果符号两边的数据不相等，结果是<span class="keyword">true</span></span><br><span class="line">    </span><br><span class="line">   <span class="keyword">boolean</span> is =  <span class="number">1</span> != <span class="number">2</span>;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p><strong style="color:red">==  符号在处理基本数据类型时，比较的是两边的值；而在处理引用类型时，比较的是地址。</strong></p>
<h2 id="2-4、逻辑运算符"><a href="#2-4、逻辑运算符" class="headerlink" title="2.4、逻辑运算符"></a>2.4、逻辑运算符</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">⚠️逻辑运算符，是用来连接两个布尔类型结果的运算符，运算结果都是布尔值 <span class="keyword">true</span> 或者 <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">&amp;&amp; 短路与</span><br><span class="line">  <span class="number">1.</span> 两边都是<span class="keyword">true</span>，结果是<span class="keyword">true</span></span><br><span class="line">  <span class="number">2.</span> 一边是<span class="keyword">false</span>，结果是<span class="keyword">false</span></span><br><span class="line">  短路特点：符号左边是<span class="keyword">false</span>，右边不再运算</span><br><span class="line">|| 短路或</span><br><span class="line">  <span class="number">1.</span> 两边都是<span class="keyword">false</span>，结果是<span class="keyword">false</span></span><br><span class="line">  <span class="number">2.</span> 一边是<span class="keyword">true</span>，结果是<span class="keyword">true</span></span><br><span class="line">  短路特点： 符号左边是<span class="keyword">true</span>，右边不再运算</span><br><span class="line">！ 取反</span><br><span class="line">  <span class="number">1.</span> !<span class="keyword">true</span> 	结果是<span class="keyword">false</span></span><br><span class="line">  <span class="number">2.</span> !<span class="keyword">false</span>	结果是<span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h2 id="2-5、三元运算符（三目）"><a href="#2-5、三元运算符（三目）" class="headerlink" title="2.5、三元运算符（三目）"></a>2.5、三元运算符（三目）</h2><p>三元运算符格式：<br>  数据类型 变量名 = 布尔类型表达式 ？结果1：结果2;<br>三元运算符计算方式：<br>    布尔类型表达式结果是true，三元运算符整体结果为结果1，赋值给变量<br>    布尔类型表达式结果是false，三元运算符整体结果为结果2，赋值给变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = (<span class="number">1</span>==<span class="number">2</span> ? <span class="number">100</span> : <span class="number">200</span>);</span><br><span class="line">  System.out.println(i);<span class="comment">//200</span></span><br><span class="line">  <span class="keyword">int</span> j = (<span class="number">3</span>&lt;=<span class="number">4</span> ? <span class="number">500</span> : <span class="number">600</span>);</span><br><span class="line">  System.out.println(j);<span class="comment">//500</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/08/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E8%BF%90%E7%AE%97%E7%AC%A6-%E7%A0%81%E8%A1%A8-%E6%96%B9%E6%B3%95-%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84/%E4%B8%89%E7%9B%AE.png" alt="三目"></p>
<h1 id="第三章、方法入门"><a href="#第三章、方法入门" class="headerlink" title="第三章、方法入门"></a>第三章、方法入门</h1><h2 id="3-1、什么是方法"><a href="#3-1、什么是方法" class="headerlink" title="3.1、什么是方法"></a>3.1、什么是方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java语言中的“方法”（Method）在其他语言当中也可能被称为“函数”（Function）。对于一些复杂的代码逻辑，如果希望重复使用这些代码，并且做到“随时任意使用”，那么就可以将这些代码放在一个大括号“&#123;&#125;”当中，并且起一个名字。使用代码的时候，直接找到名字调用即可</span><br></pre></td></tr></table></figure>

<h2 id="3-2、方法的定义"><a href="#3-2、方法的定义" class="headerlink" title="3.2、方法的定义"></a>3.2、方法的定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">定义方法的格式：</span><br><span class="line">  修饰符 返回值类型 方法名 （参数列表）｛</span><br><span class="line">		代码...</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	｝</span><br><span class="line">解释：</span><br><span class="line">	修饰符：目前固定写法 <span class="keyword">public</span> <span class="keyword">static</span>   </span><br><span class="line">  返回值类型：目前固定写法 <span class="keyword">void</span> ，其他返回值类型在后面的课程讲解</span><br><span class="line">	方法名：为我们定义的方法起名，满足标识符的规范，用来调用方法</span><br><span class="line">	参数列表：目前无参数，带有参数的方法在后面的课程讲解</span><br><span class="line">	<span class="keyword">return</span>：方法结束，因为返回值类型是<span class="keyword">void</span>，方法大括号内的<span class="keyword">return</span>可以不写</span><br><span class="line">举例：</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;这是一个方法&quot;</span>);</span><br><span class="line">  	&#125;	</span><br></pre></td></tr></table></figure>

<h2 id="3-3、方法的调用"><a href="#3-3、方法的调用" class="headerlink" title="3.3、方法的调用"></a>3.3、方法的调用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">⚠️方法在定义完毕后，方法不会自己运行，必须被调用才能执行，我们可以在主方法main中来调用我们自己定义好的方法。在</span><br><span class="line">主方法中，直接写要调用的方法名字就可以调用了</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用定义的方法method</span></span><br><span class="line">    method();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//定义方法，被main方法调用</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	System.out.println(<span class="string">&quot;自己定义的方法，需要被main方法调用才能运行&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4、调用练习"><a href="#3-4、调用练习" class="headerlink" title="3.4、调用练习"></a>3.4、调用练习</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">将三元运算符代码抽取到自定义的方法中，并调用。</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//调用定义的方法operator</span></span><br><span class="line">  operator();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义方法，方法中定义三元运算符</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  i = (<span class="number">1</span>==<span class="number">2</span> ? <span class="number">100</span>:<span class="number">200</span>);</span><br><span class="line">  System.out.println(i);</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">0</span> ;	</span><br><span class="line">  j = (<span class="number">3</span>&lt;=<span class="number">4</span> ? <span class="number">500</span>:<span class="number">600</span>);</span><br><span class="line">  System.out.println(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/08/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E8%BF%90%E7%AE%97%E7%AC%A6-%E7%A0%81%E8%A1%A8-%E6%96%B9%E6%B3%95-%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84/%E8%B0%83%E7%94%A8%E7%BB%83%E4%B9%A0.png" alt="调用练习"></p>
<h2 id="3-5、注意事项"><a href="#3-5、注意事项" class="headerlink" title="3.5、注意事项"></a>3.5、注意事项</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法定义注意事项：</span><br><span class="line">  方法必须定义在类中方法外</span><br><span class="line">	方法不能定义在另一个方法的里面</span><br><span class="line">⚠️正确案例</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//正确写法，类中，main方法外面可以定义方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 省略代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">⚠️错误案例</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//错误写法，一个方法不能定义在另一方法内部</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第四章、流程控制"><a href="#第四章、流程控制" class="headerlink" title="第四章、流程控制"></a>第四章、流程控制</h1><h2 id="1-1、概述"><a href="#1-1、概述" class="headerlink" title="1.1、概述"></a>1.1、概述</h2><p>代码执行的顺序会影响程序的运行结果，所以我们可以通过流程控制语句来控制我们代码的执行顺序或条件执行，从而达到我们想要的效果。</p>
<h2 id="1-2、顺序结构"><a href="#1-2、顺序结构" class="headerlink" title="1.2、顺序结构"></a>1.2、顺序结构</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="comment">//顺序执行，根据编写的顺序，从上到下运行</span></span><br><span class="line">  System.out.println(<span class="number">1</span>);</span><br><span class="line">  System.out.println(<span class="number">2</span>);</span><br><span class="line">  System.out.println(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第五章、判断语句"><a href="#第五章、判断语句" class="headerlink" title="第五章、判断语句"></a>第五章、判断语句</h1><h2 id="2-1、if"><a href="#2-1、if" class="headerlink" title="2.1、if"></a>2.1、if</h2><h3 id="2-1-1、if格式"><a href="#2-1-1、if格式" class="headerlink" title="2.1.1、if格式"></a>2.1.1、if格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (关系表达式) &#123;</span><br><span class="line">   语句体；</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 示例：</span></span><br><span class="line">  <span class="comment">// 判断两个数大小</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  	<span class="comment">// 定义变量</span></span><br><span class="line">  	<span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">  	<span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">  	<span class="keyword">if</span>( a &gt; b )&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;a &gt; b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/08/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E8%BF%90%E7%AE%97%E7%AC%A6-%E7%A0%81%E8%A1%A8-%E6%96%B9%E6%B3%95-%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84/if%E8%B0%83%E7%94%A8.png" alt="if调用"></p>
<h3 id="2-1-2、执行流程"><a href="#2-1-2、执行流程" class="headerlink" title="2.1.2、执行流程"></a>2.1.2、执行流程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）首先判断关系表达式看其结果是<span class="keyword">true</span>还是<span class="keyword">false</span></span><br><span class="line"><span class="number">2</span>）如果是<span class="keyword">true</span>就执行语句体</span><br><span class="line"><span class="number">3</span>）如果是<span class="keyword">false</span>就不执行语句体,往下接着执行</span><br></pre></td></tr></table></figure>

<img src="/2021/04/08/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E8%BF%90%E7%AE%97%E7%AC%A6-%E7%A0%81%E8%A1%A8-%E6%96%B9%E6%B3%95-%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84/2019-12-14_11-26-06.jpg" alt="2019-12-14_11-26-06" style="zoom:33%;">

<h2 id="2-2、if…else"><a href="#2-2、if…else" class="headerlink" title="2.2、if…else"></a>2.2、if…else</h2><h3 id="2-2-1、格式"><a href="#2-2-1、格式" class="headerlink" title="2.2.1、格式"></a>2.2.1、格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( 关系表达式 ) &#123;</span><br><span class="line">   语句体<span class="number">1</span>；</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   语句体<span class="number">2</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 示例：</span></span><br><span class="line">  <span class="comment">// 判断奇偶数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  	<span class="comment">// 定义变量</span></span><br><span class="line">  	<span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">  	<span class="keyword">if</span>( num % <span class="number">2</span> == <span class="number">0</span> )&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;num 是偶数&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;num 是奇数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  	System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/08/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E8%BF%90%E7%AE%97%E7%AC%A6-%E7%A0%81%E8%A1%A8-%E6%96%B9%E6%B3%95-%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84/ifelse.png" alt="ifelse"></p>
<h3 id="2-2-2、执行流程"><a href="#2-2-2、执行流程" class="headerlink" title="2.2.2、执行流程"></a>2.2.2、执行流程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）首先判断关系表达式看其结果是<span class="keyword">true</span>还是<span class="keyword">false</span></span><br><span class="line"><span class="number">2</span>）如果是<span class="keyword">true</span>就执行语句体<span class="number">1</span></span><br><span class="line"><span class="number">3</span>）如果是<span class="keyword">false</span>就执行语句体<span class="number">2</span></span><br></pre></td></tr></table></figure>

<img src="/2021/04/08/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E8%BF%90%E7%AE%97%E7%AC%A6-%E7%A0%81%E8%A1%A8-%E6%96%B9%E6%B3%95-%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84/2019-12-14_11-34-15.jpg" alt="2019-12-14_11-34-15" style="zoom:33%;">

<h2 id="2-3、if…else-if…else"><a href="#2-3、if…else-if…else" class="headerlink" title="2.3、if…else if…else"></a>2.3、if…else if…else</h2><h3 id="2-3-1、格式"><a href="#2-3-1、格式" class="headerlink" title="2.3.1、格式"></a>2.3.1、格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (关系表达式<span class="number">1</span>) &#123;</span><br><span class="line">	语句体<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (关系表达式<span class="number">2</span>) &#123;</span><br><span class="line">	语句体<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (关系表达式n) &#123;</span><br><span class="line">	语句体n;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	语句体n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 示例：</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// x和y的关系满足如下：</span></span><br><span class="line">    <span class="comment">// x&gt;=3 y = 2x + 1;</span></span><br><span class="line">    <span class="comment">//‐1&lt;=x&lt;3 y = 2x;</span></span><br><span class="line">    <span class="comment">// x&lt;=‐1 y = 2x – 1;</span></span><br><span class="line">    <span class="comment">// 根据给定的x的值，计算出y的值并输出。</span></span><br><span class="line">    <span class="comment">// 定义变量</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x&gt;= <span class="number">3</span>) &#123;</span><br><span class="line">   		 y = <span class="number">2</span> * x + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt;= ‐<span class="number">1</span> &amp;&amp; x &lt; <span class="number">3</span>) &#123;</span><br><span class="line">   		 y = <span class="number">2</span> * x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   		 y = <span class="number">2</span> * x ‐ <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;y的值是：&quot;</span>+y);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/08/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E8%BF%90%E7%AE%97%E7%AC%A6-%E7%A0%81%E8%A1%A8-%E6%96%B9%E6%B3%95-%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84/elseif.png" alt="elseif"></p>
<h3 id="2-3-2、执行流程"><a href="#2-3-2、执行流程" class="headerlink" title="2.3.2、执行流程"></a>2.3.2、执行流程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）首先判断关系表达式<span class="number">1</span>看其结果是<span class="keyword">true</span>还是<span class="keyword">false</span></span><br><span class="line"><span class="number">2</span>）如果是<span class="keyword">true</span>就执行语句体<span class="number">1</span></span><br><span class="line"><span class="number">3</span>）如果是<span class="keyword">false</span>就继续判断关系表达式<span class="number">2</span>看其结果是<span class="keyword">true</span>还是<span class="keyword">false</span></span><br><span class="line"><span class="number">4</span>）如果是<span class="keyword">true</span>就执行语句体<span class="number">2</span></span><br><span class="line"><span class="number">5</span>）如果是<span class="keyword">false</span>就继续判断关系表达式…看其结果是<span class="keyword">true</span>还是<span class="keyword">false</span></span><br><span class="line">…</span><br><span class="line"><span class="number">6</span>）如果没有任何关系表达式为<span class="keyword">true</span>，就执行语句体n+<span class="number">1</span></span><br></pre></td></tr></table></figure>

<img src="/2021/04/08/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E8%BF%90%E7%AE%97%E7%AC%A6-%E7%A0%81%E8%A1%A8-%E6%96%B9%E6%B3%95-%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84/2019-12-14_11-42-58.jpg" alt="2019-12-14_11-42-58" style="zoom:33%;">

<h2 id="2-4、练习"><a href="#2-4、练习" class="headerlink" title="2.4、练习"></a>2.4、练习</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定考试成绩，判断学生等级</span></span><br><span class="line">  <span class="number">90</span>-<span class="number">100</span> 优秀</span><br><span class="line">  <span class="number">80</span>-<span class="number">89</span> 好</span><br><span class="line">  <span class="number">70</span>-<span class="number">79</span> 良</span><br><span class="line">  <span class="number">60</span>-<span class="number">69</span> 及格</span><br><span class="line">  <span class="number">60</span>以下 不及格</span><br><span class="line"><span class="comment">// 示例：</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> score = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span>(score&lt;<span class="number">0</span> || score&gt;<span class="number">100</span>)&#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;你的成绩是错误的&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(score&gt;=<span class="number">90</span> &amp;&amp; score&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;你的成绩属于优秀&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(score&gt;=<span class="number">80</span> &amp;&amp; score&lt;<span class="number">90</span>)&#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;你的成绩属于好&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(score&gt;=<span class="number">70</span> &amp;&amp; score&lt;<span class="number">80</span>)&#123;</span><br><span class="line">   	 	System.out.println(<span class="string">&quot;你的成绩属于良&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(score&gt;=<span class="number">60</span> &amp;&amp; score&lt;<span class="number">70</span>)&#123;</span><br><span class="line">   	 	System.out.println(<span class="string">&quot;你的成绩属于及格&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;你的成绩属于不及格&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/08/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E8%BF%90%E7%AE%97%E7%AC%A6-%E7%A0%81%E8%A1%A8-%E6%96%B9%E6%B3%95-%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84/score.png" alt="score"></p>
<h2 id="2-5、if语句与三元运算的互换"><a href="#2-5、if语句与三元运算的互换" class="headerlink" title="2.5、if语句与三元运算的互换"></a>2.5、if语句与三元运算的互换</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在某些简单的应用中，if语句是可以和三元运算符互换使用的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">  <span class="comment">//定义变量，保存a和b的较大值</span></span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(a &gt; b) &#123;</span><br><span class="line">  	c = a;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  	c = b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//上述功能可以改写为三元运算符形式：c = a &gt; b ? a:b;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// d = a &gt; b ? (a &gt; c ? a : c) : (b &gt; c ? b : c);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第六章、选择语句"><a href="#第六章、选择语句" class="headerlink" title="第六章、选择语句"></a>第六章、选择语句</h1><h2 id="3-1、switch语句格式"><a href="#3-1、switch语句格式" class="headerlink" title="3.1、switch语句格式"></a>3.1、switch语句格式</h2><p>switch语句中，表达式的数据类型，不可以是 boolean , long , float , double .</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// switch语句中，表达式的数据类型，可以是byte，short，int，char，enum（枚举），JDK7后可以接收字符串</span></span><br><span class="line"><span class="keyword">switch</span>(表达式) &#123;</span><br><span class="line">  <span class="keyword">case</span> 常量值<span class="number">1</span>:</span><br><span class="line">  	语句体<span class="number">1</span>;</span><br><span class="line">  	<span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 常量值<span class="number">2</span>:</span><br><span class="line">    语句体<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    语句体n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 示例：</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义变量，判断是星期几</span></span><br><span class="line">    <span class="keyword">int</span> weekday = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">//switch语句实现选择</span></span><br><span class="line">    <span class="keyword">switch</span>(weekday) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;星期一&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;星期二&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;星期三&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;星期四&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;星期五&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;星期六&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;星期日&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;你输入的数字有误&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/08/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E8%BF%90%E7%AE%97%E7%AC%A6-%E7%A0%81%E8%A1%A8-%E6%96%B9%E6%B3%95-%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84/switch.png" alt="switch"></p>
<h2 id="3-2、switch执行流程"><a href="#3-2、switch执行流程" class="headerlink" title="3.2、switch执行流程"></a>3.2、switch执行流程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）首先计算出表达式的值</span><br><span class="line"><span class="number">2</span>）其次，和<span class="keyword">case</span>依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到<span class="keyword">break</span>就会结束。</span><br><span class="line"><span class="number">3</span>）最后，如果所有的<span class="keyword">case</span>都和表达式的值不匹配，就会执行<span class="keyword">default</span>语句体部分，然后程序结束掉</span><br></pre></td></tr></table></figure>

<img src="/2021/04/08/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E8%BF%90%E7%AE%97%E7%AC%A6-%E7%A0%81%E8%A1%A8-%E6%96%B9%E6%B3%95-%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84/2019-12-14_11-54-25.jpg" alt="2019-12-14_11-54-25" style="zoom:33%;">

<h2 id="3-3、case的穿透"><a href="#3-3、case的穿透" class="headerlink" title="3.3、case的穿透"></a>3.3、case的穿透</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">⚠️在<span class="keyword">switch</span>语句中，如果<span class="keyword">case</span>的后面不写<span class="keyword">break</span>，将出现穿透现象，也就是不会在判断下一个<span class="keyword">case</span>的值，直接向后运</span><br><span class="line">行，直到遇到<span class="keyword">break</span>，或者整体<span class="keyword">switch</span>结束</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">switch</span> (i)&#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;执行case0&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;执行case5&quot;</span>);</span><br><span class="line">      <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;执行case10&quot;</span>);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">      	System.out.println(<span class="string">&quot;执行default&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">⚠️分析：上述程序中，执行case5后，由于没有<span class="keyword">break</span>语句，程序会一直向后走，不会在判断<span class="keyword">case</span>，也不会理会<span class="keyword">break</span>，直接</span><br><span class="line">运行完整体<span class="keyword">switch</span>。</span><br><span class="line">由于<span class="keyword">case</span>存在穿透性，因此初学者在编写<span class="keyword">switch</span>语句时，必须要写上<span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/08/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E8%BF%90%E7%AE%97%E7%AC%A6-%E7%A0%81%E8%A1%A8-%E6%96%B9%E6%B3%95-%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84/case%E7%A9%BF%E9%80%8F.png" alt="case穿透"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>培训学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>day01-关键字-标识符-数据类型</title>
    <url>/2021/04/07/day01-%E5%85%B3%E9%94%AE%E5%AD%97-%E6%A0%87%E8%AF%86%E7%AC%A6-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>今日内容：关键字、标识符、数据类型、常亮、变量</p>
<span id="more"></span>

<h1 id="第一章、关键字"><a href="#第一章、关键字" class="headerlink" title="第一章、关键字"></a>第一章、关键字</h1><h2 id="1-1、什么是关键字"><a href="#1-1、什么是关键字" class="headerlink" title="1.1、什么是关键字"></a>1.1、什么是关键字</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">关键字：被Java语言赋予了特殊含义的单词称为关键字</span><br><span class="line">保留字：暂时还没有赋予特殊含义对的单词，goto、<span class="keyword">const</span>等</span><br></pre></td></tr></table></figure>

<h2 id="1-2、常见的关键字"><a href="#1-2、常见的关键字" class="headerlink" title="1.2、常见的关键字"></a>1.2、常见的关键字</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HelloWorld 案例中，出现的关键字有 <span class="keyword">public</span> 、<span class="class"><span class="keyword">class</span> 、 <span class="title">static</span> 、 <span class="title">void</span> 等，这些单词已经被 <span class="title">Java</span> 赋予了特殊含义，全都是小写字母，<span class="title">notepad</span>++ 中颜色特殊高亮。</span></span><br></pre></td></tr></table></figure>

<h1 id="第二章、标识符"><a href="#第二章、标识符" class="headerlink" title="第二章、标识符"></a>第二章、标识符</h1><h2 id="2-1、什么是标识符"><a href="#2-1、什么是标识符" class="headerlink" title="2.1、什么是标识符"></a>2.1、什么是标识符</h2><p>标识符：是指在程序中，我们自己定义内容。比如类的名字、方法的名字和变量的名字等等，都是标识符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HelloWorld案例中，出现的标识符有类名：HelloWorld </span></span><br></pre></td></tr></table></figure>

<h2 id="2-2、标识符的命名规则"><a href="#2-2、标识符的命名规则" class="headerlink" title="2.2、标识符的命名规则"></a>2.2、标识符的命名规则</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）标识符由大小写字母、阿拉伯数字、下划线“_”、美元符号“$”组成，不能以数字开头</span><br><span class="line"><span class="number">2</span>）不能把java关键字和保留字作为标识符</span><br><span class="line"><span class="number">3</span>）标识符对大小写敏感（大小写意义不一样）</span><br><span class="line"><span class="number">4</span>）标识符没有长度限制（不能瞎定义）   见名知义</span><br><span class="line">⚠️注意：坚决不能用拼音或汉字或者中英结合的命名方法</span><br></pre></td></tr></table></figure>

<h2 id="2-3、命名规范"><a href="#2-3、命名规范" class="headerlink" title="2.3、命名规范"></a>2.3、命名规范</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）类名、接口名：单词首字母大写（如果多个单词组合，每个单词首字母大写，其余小写）</span><br><span class="line">  Demo 、HelloWorld</span><br><span class="line"><span class="number">2</span>）方法名、变量名：单词全部小写（如果多个单词组合，从第二个单词开始，首字母全部大写，其余小写）</span><br><span class="line">  add、findAllUser name、myName</span><br><span class="line"><span class="number">3</span>）常量名：全部大写（如果多个单词组合，每个单词用下划线_隔开）</span><br><span class="line">  MAX TOTAL_COUNT</span><br></pre></td></tr></table></figure>

<h1 id="第三章、数据类型"><a href="#第三章、数据类型" class="headerlink" title="第三章、数据类型"></a>第三章、数据类型</h1><h2 id="3-1、什么是数据类型"><a href="#3-1、什么是数据类型" class="headerlink" title="3.1、什么是数据类型"></a>3.1、什么是数据类型</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我们人类可以很容易的分清数字与字符的区别，但是计算机并不能呀，计算机虽然很强大，但从某种角度上看又很傻，除非你明确的告诉它，<span class="number">1</span>是数字，“汉”是文字，否则它是分不清<span class="number">1</span>和‘汉’的区别的，因此，在每个编程语言里都会有一个叫数据类型的东西，其实就是对常用的各种数据类型进行了明确的划分，你想让计算机进行数值运算，你就传数字给它，你想让他处理文字，就传字符串类型给它</span><br></pre></td></tr></table></figure>

<h2 id="3-2、数据类型分类"><a href="#3-2、数据类型分类" class="headerlink" title="3.2、数据类型分类"></a>3.2、数据类型分类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型分为两大类：</span><br><span class="line">  基本类型：<span class="keyword">byte</span>、<span class="keyword">short</span>、<span class="keyword">int</span>、<span class="keyword">long</span>、<span class="keyword">float</span>、<span class="keyword">double</span>、<span class="keyword">char</span>、<span class="keyword">boolean</span></span><br><span class="line">  引用类型：数组、字符串、类、接口</span><br><span class="line">基本数据类型又分为四大类：</span><br><span class="line">	整数、浮点型、字符、布尔</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">关键字</th>
<th align="center">内存大小</th>
<th align="center">取值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字节型</td>
<td align="center">byte</td>
<td align="center">1个字节（8位）</td>
<td align="center">-2^7～2^7-1</td>
</tr>
<tr>
<td align="center">短整型</td>
<td align="center">short</td>
<td align="center">2个字节（16位）</td>
<td align="center">-2^15～2^15-1</td>
</tr>
<tr>
<td align="center">整型</td>
<td align="center">int（默认）</td>
<td align="center">4个字节（32位）</td>
<td align="center">-2^31～2^31-1</td>
</tr>
<tr>
<td align="center">长整型</td>
<td align="center">long</td>
<td align="center">8个字节（64位）</td>
<td align="center">-2^63～2^63-1</td>
</tr>
<tr>
<td align="center">单精度浮点</td>
<td align="center">float</td>
<td align="center">4个字节（32位）</td>
<td align="center">默认值：0.0f</td>
</tr>
<tr>
<td align="center">双精度浮点</td>
<td align="center">double（默认）</td>
<td align="center">8个字节（64位）</td>
<td align="center">默认值：0.0d</td>
</tr>
<tr>
<td align="center">字符</td>
<td align="center">char</td>
<td align="center">2个字节（16位）</td>
<td align="center">0～65535</td>
</tr>
<tr>
<td align="center">布尔类</td>
<td align="center">boolean</td>
<td align="center">1个字节（8位）</td>
<td align="center">true、false</td>
</tr>
</tbody></table>
<h1 id="第四章、常量"><a href="#第四章、常量" class="headerlink" title="第四章、常量"></a>第四章、常量</h1><h2 id="4-1、什么是常量"><a href="#4-1、什么是常量" class="headerlink" title="4.1、什么是常量"></a>4.1、什么是常量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">常量；指在Java程序中不变的量</span><br><span class="line">当使用常量的时候，前缀 <span class="number">0</span> 表示 <span class="number">8</span>进制，而前缀 0x 代表<span class="number">16</span>进制</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">01</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0x12</span>;</span><br></pre></td></tr></table></figure>

<h2 id="4-2、常量的分类"><a href="#4-2、常量的分类" class="headerlink" title="4.2、常量的分类"></a>4.2、常量的分类</h2><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">含义</th>
<th align="center">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">整数常量</td>
<td align="center">所有的整数</td>
<td align="center">-20、-1、0、24、101</td>
</tr>
<tr>
<td align="center">小数常量</td>
<td align="center">所有的小数</td>
<td align="center">0.1、-2.7、6.66</td>
</tr>
<tr>
<td align="center">字符常量</td>
<td align="center">单引号引起来,只能写一个字符，也可以不写</td>
<td align="center">‘a’、’’、’牛’</td>
</tr>
<tr>
<td align="center">字符串常量</td>
<td align="center">双引号引起来,可以写多个字符,也可以不写</td>
<td align="center">“a”、”666”、”你好吗？”、””</td>
</tr>
<tr>
<td align="center">布尔常量</td>
<td align="center">只有两个值：true、false（流程控制中讲解）</td>
<td align="center">true、false</td>
</tr>
<tr>
<td align="center">空常量</td>
<td align="center">只有一个值（引用数据类型中讲解）</td>
<td align="center">null</td>
</tr>
</tbody></table>
<h2 id="4-3、练习"><a href="#4-3、练习" class="headerlink" title="4.3、练习"></a>4.3、练习</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需求：输出各种类型的常量	</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstantDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//输出整数常量</span></span><br><span class="line">    System.out.println(<span class="number">123</span>);</span><br><span class="line">    <span class="comment">//输出小数常量</span></span><br><span class="line">    System.out.println(<span class="number">0.125</span>);</span><br><span class="line">    <span class="comment">//输出字符常量</span></span><br><span class="line">    System.out.println(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    <span class="comment">//输出布尔常量</span></span><br><span class="line">    System.out.println(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//输出字符串常量</span></span><br><span class="line">    System.out.println(<span class="string">&quot;你好Java&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第五章、变量"><a href="#第五章、变量" class="headerlink" title="第五章、变量"></a>第五章、变量</h1><h2 id="5-1、什么是变量"><a href="#5-1、什么是变量" class="headerlink" title="5.1、什么是变量"></a>5.1、什么是变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在程序运行过程中会发生改变的量被称为变量</span><br><span class="line">一个变量每次只能保存一个数据，必须要明确保存的数据类型</span><br></pre></td></tr></table></figure>

<h2 id="5-2、变量的定义"><a href="#5-2、变量的定义" class="headerlink" title="5.2、变量的定义"></a>5.2、变量的定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）定义变量的格式：</span><br><span class="line">  数据类型 变量名 = 变量值;</span><br><span class="line"><span class="number">2</span>）注意	</span><br><span class="line">  <span class="keyword">long</span>类型：建议数据后加L表示。</span><br><span class="line">  <span class="keyword">float</span>类型：建议数据后加F表示。</span><br><span class="line"><span class="number">3</span>）注意⚠️</span><br><span class="line">  变量名称：在同一个大括号范围内，变量的名字不可以相同。</span><br><span class="line">  变量赋值：定义的变量，不赋值不能使用</span><br></pre></td></tr></table></figure>

<h2 id="5-3、练习"><a href="#5-3、练习" class="headerlink" title="5.3、练习"></a>5.3、练习</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Variable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义字节型变量</span></span><br><span class="line">    <span class="keyword">byte</span> b = <span class="number">100</span>;</span><br><span class="line">    System.out.println(b);</span><br><span class="line">    <span class="comment">//定义短整型变量</span></span><br><span class="line">    <span class="keyword">short</span> s = <span class="number">1000</span>;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">    <span class="comment">//定义整型变量</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">123456</span>;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    <span class="comment">//定义长整型变量</span></span><br><span class="line">    <span class="keyword">long</span> l = <span class="number">12345678900L</span>;</span><br><span class="line">    System.out.println(l);</span><br><span class="line">    <span class="comment">//定义单精度浮点型变量</span></span><br><span class="line">    <span class="keyword">float</span> f = <span class="number">5.5F</span>;</span><br><span class="line">    System.out.println(f);</span><br><span class="line">    <span class="comment">//定义双精度浮点型变量</span></span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">8.5</span>;</span><br><span class="line">    System.out.println(d);</span><br><span class="line">    <span class="comment">//定义布尔型变量</span></span><br><span class="line">    <span class="keyword">boolean</span> bool = <span class="keyword">false</span>;</span><br><span class="line">    System.out.println(bool);</span><br><span class="line">    <span class="comment">//定义字符型变量</span></span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>培训学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Phone Store 移动端手机商城</title>
    <url>/2021/04/06/Phone-Store-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%89%8B%E6%9C%BA%E5%95%86%E5%9F%8E/</url>
    <content><![CDATA[<p><strong><em>一个基于 SpringBoot+Vue 开发的移动端手机商城</em></strong></p>
<span id="more"></span>

<h2 id="Phone-Store"><a href="#Phone-Store" class="headerlink" title="Phone Store"></a>Phone Store</h2><p>基于移动端的手机商城</p>
<p>基于 Spring Boot + Vue 的前后端分离开发架构</p>
<h4 id="前端技术栈"><a href="#前端技术栈" class="headerlink" title="前端技术栈"></a>前端技术栈</h4><p>Vue + Vant UI + less</p>
<h4 id="后端技术栈"><a href="#后端技术栈" class="headerlink" title="后端技术栈"></a>后端技术栈</h4><p>Spring Boot + Spring Data JPA</p>
<h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>MySQL</p>
<h3 id="1-创建-Vue-项目"><a href="#1-创建-Vue-项目" class="headerlink" title="1. 创建 Vue 项目"></a>1. 创建 Vue 项目</h3><p>首先创建一个基础的vue项目，创建过程不做过多赘述。创建好了之后直接打开，进行插件安装。</p>
<h4 id="1-1插件安装"><a href="#1-1插件安装" class="headerlink" title="1.1插件安装"></a>1.1插件安装</h4><blockquote>
<p>Vant UI 安装命令</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm i vant -S</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/06/Phone-Store-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%89%8B%E6%9C%BA%E5%95%86%E5%9F%8E/VantUI%E5%AE%89%E8%A3%85.png" alt="VantUI安装"></p>
<blockquote>
<p>less 安装命令</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install less less-loader --save</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/06/Phone-Store-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%89%8B%E6%9C%BA%E5%95%86%E5%9F%8E/less%E5%AE%89%E8%A3%85.png" alt="less安装"></p>
<h4 id="1-2-导入并启用插件"><a href="#1-2-导入并启用插件" class="headerlink" title="1.2 导入并启用插件"></a>1.2 导入并启用插件</h4><p>进入 src 目录下的 main.js 文件中。</p>
<blockquote>
<p>导入 vant 插件</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vant <span class="keyword">from</span> <span class="string">&#x27;vant&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>导入 css 插件</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;vant/lib/index.css&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>启用 Vant UI 插件</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.use(Vant);</span><br></pre></td></tr></table></figure>

<h3 id="2-界面实现"><a href="#2-界面实现" class="headerlink" title="2. 界面实现"></a>2. 界面实现</h3><h4 id="2-1-首页界面实现"><a href="#2-1-首页界面实现" class="headerlink" title="2.1 首页界面实现"></a>2.1 首页界面实现</h4><blockquote>
<p>导航代码:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;van-tab v-for&#x3D;&quot;index in categories.length&quot; :title&#x3D;&quot;categories[index-1].name&quot; class&#x3D;&quot;tab&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>利用 <code> v-for</code> 从<code> categories</code> 中遍历元素。</p>
<p><strong>categories:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        categories: [</span><br><span class="line">            &#123;</span><br><span class="line">                name: <span class="string">&#x27;魅焰红&#x27;</span>,</span><br><span class="line">                type: <span class="number">1</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                name: <span class="string">&#x27;极光蓝&#x27;</span>,</span><br><span class="line">                type: <span class="number">2</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                name: <span class="string">&#x27;铂光金&#x27;</span>,</span><br><span class="line">                type: <span class="number">3</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                name: <span class="string">&#x27;幻夜黑&#x27;</span>,</span><br><span class="line">                type: <span class="number">4</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>遍历商品</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;van-tab v-for&#x3D;&quot;index in categories.length&quot; :title&#x3D;&quot;categories[index-1].name&quot; class&#x3D;&quot;tab&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;van-card v-for&#x3D;&quot;(item,index) in phones&quot;</span><br><span class="line">              :price&#x3D;&quot;item.price&quot;</span><br><span class="line">              :desc&#x3D;&quot;item.desc&quot;</span><br><span class="line">              :title&#x3D;&quot;item.title&quot;</span><br><span class="line">              :thumb&#x3D;&quot;item.thumb&quot;</span><br><span class="line">              &gt;</span><br><span class="line">        &lt;template #tags&gt;</span><br><span class="line">&lt;van-tag v-for&#x3D;&quot;tag in item.tag&quot; color&#x3D;&quot;#f2826a&quot; style&#x3D;&quot;margin-left: 5px;&quot;&gt;&#123;&#123;tag.name&#125;&#125;&lt;&#x2F;van-tag&gt;</span><br><span class="line">        &lt;&#x2F;template&gt;</span><br><span class="line">        &lt;template #footer&gt;</span><br><span class="line">&lt;van-button round type&#x3D;&quot;info&quot; size&#x3D;&quot;mini&quot; @click&#x3D;&quot;buy(index)&quot;&gt;购买&lt;&#x2F;van-button&gt;</span><br><span class="line">        &lt;&#x2F;template&gt;</span><br><span class="line">    &lt;&#x2F;van-card&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;van-tab&gt;</span><br></pre></td></tr></table></figure>

<p><strong>phones:</strong></p>
<p>​    静态测试数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">phones: [</span><br><span class="line">    &#123;</span><br><span class="line">        id:<span class="number">1</span>,</span><br><span class="line">        title: <span class="string">&quot;Honor 8A&quot;</span>,</span><br><span class="line">        price: <span class="string">&quot;2800.00&quot;</span>,</span><br><span class="line">        desc: <span class="string">&quot;魅焰红&quot;</span>,</span><br><span class="line">        tag: [</span><br><span class="line">            &#123;</span><br><span class="line">                name: <span class="string">&quot;720P珍珠屏&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                name: <span class="string">&quot;Micro USB接口&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">        thumb: <span class="string">&quot;../static/e84a2e03-7f19-41d2-98a5-a5c16b7e252d.jpg&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        id:<span class="number">2</span>,</span><br><span class="line">        title: <span class="string">&quot;Honor 10 青春版&quot;</span>,</span><br><span class="line">        price: <span class="string">&quot;2800.00&quot;</span>,</span><br><span class="line">        desc: <span class="string">&quot;极光蓝&quot;</span>,</span><br><span class="line">        tag: [</span><br><span class="line">            &#123;</span><br><span class="line">                name: <span class="string">&quot;720P珍珠屏&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                name: <span class="string">&quot;EMUI9 Lite&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">        thumb: <span class="string">&quot;../static/8f0bd0d0-a11e-4185-927e-04b54ff4a1bd.jpg&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        id:<span class="number">3</span>,</span><br><span class="line">        title: <span class="string">&quot;Honor V20&quot;</span>,</span><br><span class="line">        price: <span class="string">&quot;3450.00&quot;</span>,</span><br><span class="line">        desc: <span class="string">&quot;铂光金&quot;</span>,</span><br><span class="line">        tag: [</span><br><span class="line">            &#123;</span><br><span class="line">                name: <span class="string">&quot;2+1独立三卡槽&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        thumb: <span class="string">&quot;../static/fd7fee3c-a35c-477b-b007-9fda6e9c589a.jpg&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        id:<span class="number">4</span>,</span><br><span class="line">        title: <span class="string">&quot;HUAWEI Mate 20 Pro&quot;</span>,</span><br><span class="line">        price: <span class="string">&quot;4550.00&quot;</span>,</span><br><span class="line">        desc: <span class="string">&quot;幻夜黑&quot;</span>,</span><br><span class="line">        tag: [</span><br><span class="line">            &#123;</span><br><span class="line">                name: <span class="string">&quot;内存3GB&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                name: <span class="string">&quot;EMUI9 Lite&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">        thumb: <span class="string">&quot;../static/cb819ad9-ec6f-4123-a4e9-aa629e2f8224.jpg&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        id:<span class="number">5</span>,</span><br><span class="line">        title: <span class="string">&quot;HUAWEI nova 5 Pro&quot;</span>,</span><br><span class="line">        price: <span class="string">&quot;5450.00&quot;</span>,</span><br><span class="line">        desc: <span class="string">&quot;5450.00&quot;</span>,</span><br><span class="line">        tag: [</span><br><span class="line">            &#123;</span><br><span class="line">                name: <span class="string">&quot;内存3GB&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                name: <span class="string">&quot;Micro USB接口&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">        thumb: <span class="string">&quot;../static/8a0f5be0-3c78-4f23-b58b-dc2a92f1f95a.jpg&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        id:<span class="number">1</span>,</span><br><span class="line">        title: <span class="string">&quot;HUAWEI P30&quot;</span>,</span><br><span class="line">        price: <span class="string">&quot;8700.00&quot;</span>,</span><br><span class="line">        desc: <span class="string">&quot;极光蓝&quot;</span>,</span><br><span class="line">        tag: [</span><br><span class="line">            &#123;</span><br><span class="line">                name: <span class="string">&quot;720P珍珠屏&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                name: <span class="string">&quot;内存3GB&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">        thumb: <span class="string">&quot;../static/6dcad185-315f-40f0-87f2-52910f49c8b7.jpg&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>静态数据测试预览图：</strong></p>
<img src="/2021/04/06/Phone-Store-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%89%8B%E6%9C%BA%E5%95%86%E5%9F%8E/演示1.png" width="50%">

<h5 id="2-1-1-导航切换（点击事件绑定）"><a href="#2-1-1-导航切换（点击事件绑定）" class="headerlink" title="2.1.1 导航切换（点击事件绑定）"></a>2.1.1 导航切换（点击事件绑定）</h5><p>当点击导航栏时，触发点击事件。后面将通过点击事件来进行页面的切换操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">   <span class="function"><span class="title">onClick</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-1-2-Sku-商品规格"><a href="#2-1-2-Sku-商品规格" class="headerlink" title="2.1.2 Sku 商品规格"></a>2.1.2 Sku 商品规格</h5><h6 id="Sku-对象结构"><a href="#Sku-对象结构" class="headerlink" title="Sku 对象结构"></a>Sku 对象结构</h6><p>使用 Vant UI 提供的 Sku 商品规格组价模块来制作商品规格界面。</p>
<p>详细文档连接：<a href="https://vant-contrib.gitee.io/vant/#/zh-CN/sku#dai-ma-yan-shi">https://vant-contrib.gitee.io/vant/#/zh-CN/sku#dai-ma-yan-shi</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sku: &#123;</span><br><span class="line">  <span class="comment">// 所有sku规格类目与其值的从属关系，比如商品有颜色和尺码两大类规格，颜色下面又有红色和蓝色两个规格值。</span></span><br><span class="line">  <span class="comment">// 可以理解为一个商品可以有多个规格类目，一个规格类目下可以有多个规格值。</span></span><br><span class="line">  tree: [</span><br><span class="line">    &#123;</span><br><span class="line">      k: <span class="string">&#x27;颜色&#x27;</span>, <span class="comment">// skuKeyName：规格类目名称</span></span><br><span class="line">      k_s: <span class="string">&#x27;s1&#x27;</span>, <span class="comment">// skuKeyStr：sku 组合列表（下方 list）中当前类目对应的 key 值，value 值会是从属于当前类目的一个规格值 id</span></span><br><span class="line">      v: [</span><br><span class="line">        &#123;</span><br><span class="line">          id: <span class="string">&#x27;1&#x27;</span>, <span class="comment">// skuValueId：规格值 id</span></span><br><span class="line">          name: <span class="string">&#x27;红色&#x27;</span>, <span class="comment">// skuValueName：规格值名称</span></span><br><span class="line">          imgUrl: <span class="string">&#x27;https://img01.yzcdn.cn/1.jpg&#x27;</span>, <span class="comment">// 规格类目图片，只有第一个规格类目可以定义图片</span></span><br><span class="line">          previewImgUrl: <span class="string">&#x27;https://img01.yzcdn.cn/1p.jpg&#x27;</span>, <span class="comment">// 用于预览显示的规格类目图片</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          id: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">          name: <span class="string">&#x27;蓝色&#x27;</span>,</span><br><span class="line">          imgUrl: <span class="string">&#x27;https://img01.yzcdn.cn/2.jpg&#x27;</span>,</span><br><span class="line">          previewImgUrl: <span class="string">&#x27;https://img01.yzcdn.cn/2p.jpg&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      largeImageMode: <span class="literal">true</span>, <span class="comment">//  是否展示大图模式</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 所有 sku 的组合列表，比如红色、M 码为一个 sku 组合，红色、S 码为另一个组合</span></span><br><span class="line">  list: [</span><br><span class="line">    &#123;</span><br><span class="line">      id: <span class="number">2259</span>, <span class="comment">// skuId</span></span><br><span class="line">      s1: <span class="string">&#x27;1&#x27;</span>, <span class="comment">// 规格类目 k_s 为 s1 的对应规格值 id</span></span><br><span class="line">      s2: <span class="string">&#x27;1&#x27;</span>, <span class="comment">// 规格类目 k_s 为 s2 的对应规格值 id</span></span><br><span class="line">      price: <span class="number">100</span>, <span class="comment">// 价格（单位分）</span></span><br><span class="line">      stock_num: <span class="number">110</span> <span class="comment">// 当前 sku 组合对应的库存</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  price: <span class="string">&#x27;1.00&#x27;</span>, <span class="comment">// 默认价格（单位元）</span></span><br><span class="line">  stock_num: <span class="number">227</span>, <span class="comment">// 商品总库存</span></span><br><span class="line">  collection_id: <span class="number">2261</span>, <span class="comment">// 无规格商品 skuId 取 collection_id，否则取所选 sku 组合对应的 id</span></span><br><span class="line">  none_sku: <span class="literal">false</span>, <span class="comment">// 是否无规格商品</span></span><br><span class="line">  messages: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 商品留言</span></span><br><span class="line">      datetime: <span class="string">&#x27;0&#x27;</span>, <span class="comment">// 留言类型为 time 时，是否含日期。&#x27;1&#x27; 表示包含</span></span><br><span class="line">      multiple: <span class="string">&#x27;0&#x27;</span>, <span class="comment">// 留言类型为 text 时，是否多行文本。&#x27;1&#x27; 表示多行</span></span><br><span class="line">      name: <span class="string">&#x27;留言&#x27;</span>, <span class="comment">// 留言名称</span></span><br><span class="line">      type: <span class="string">&#x27;text&#x27;</span>, <span class="comment">// 留言类型，可选: id_no（身份证）, text, tel, date, time, email</span></span><br><span class="line">      required: <span class="string">&#x27;1&#x27;</span>, <span class="comment">// 是否必填 &#x27;1&#x27; 表示必填</span></span><br><span class="line">      placeholder: <span class="string">&#x27;&#x27;</span> <span class="comment">// 可选值，占位文本</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  hide_stock: <span class="literal">false</span> <span class="comment">// 是否隐藏剩余库存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态界面图如下：</p>
<img src="/2021/04/06/Phone-Store-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%89%8B%E6%9C%BA%E5%95%86%E5%9F%8E/演示2.png" width="50%">

<h5 id="2-1-3-购买提交"><a href="#2-1-3-购买提交" class="headerlink" title="2.1.3 购买提交"></a>2.1.3 购买提交</h5><p>选后规格后，我们会进行提交操作，当点击“购买”按钮时需要获取数据。</p>
<p>所以我们可 以先想一想，需要提交的数据其实只要有 <strong style="color:green">商品的规格id和商品的数量</strong> 就可以了。</p>
<p>于是有点击事件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">onBuyClicked</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line"><span class="comment">//  console.log(item)</span></span><br><span class="line">    <span class="built_in">this</span>.$store.state.specsId = item.selectedSkuComb.s1</span><br><span class="line">    <span class="built_in">this</span>.$store.state.quantity = item.selectedNum</span><br><span class="line">    <span class="built_in">this</span>.$router.push(<span class="string">&#x27;/addressList&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们把item的值打印出来时可以在控制台看到如下图：</p>
<img src="/2021/04/06/Phone-Store-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%89%8B%E6%9C%BA%E5%95%86%E5%9F%8E/演示3.png" width="50%">

<p>从图中可以看出，虽然我们从前端代码获取提交的只有商品规格id和商品数量，但是后台会从数据库中对数据进行整理，返回给前端的数据依旧是完整的。</p>
<h4 id="2-2-AddressList界面实现"><a href="#2-2-AddressList界面实现" class="headerlink" title="2.2 AddressList界面实现"></a>2.2 AddressList界面实现</h4><p>AddressList 界面的实现使用 Vant UI 的业务组件中的 <font style="color:green">AddressList 地址列表组件</font>，以下是它的基本用法。</p>
<p>当然，你也可以访问官网：<a href="https://vant-contrib.gitee.io/vant/#/zh-CN/address-list#dai-ma-yan-shi">https://vant-contrib.gitee.io/vant/#/zh-CN/address-list#dai-ma-yan-shi</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;van-address-list</span><br><span class="line">  v-model&#x3D;&quot;chosenAddressId&quot;</span><br><span class="line">  :list&#x3D;&quot;list&quot;</span><br><span class="line">  :disabled-list&#x3D;&quot;disabledList&quot;</span><br><span class="line">  disabled-text&#x3D;&quot;以下地址超出配送范围&quot;</span><br><span class="line">  default-tag-text&#x3D;&quot;默认&quot;</span><br><span class="line">  @add&#x3D;&quot;onAdd&quot;</span><br><span class="line">  @edit&#x3D;&quot;onEdit&quot;</span><br><span class="line">&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Toast &#125; <span class="keyword">from</span> <span class="string">&#x27;vant&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      chosenAddressId: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">      list: [</span><br><span class="line">        &#123;</span><br><span class="line">          id: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">          name: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">          tel: <span class="string">&#x27;13000000000&#x27;</span>,</span><br><span class="line">          address: <span class="string">&#x27;浙江省杭州市西湖区文三路 138 号东方通信大厦 7 楼 501 室&#x27;</span>,</span><br><span class="line">          isDefault: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          id: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">          name: <span class="string">&#x27;李四&#x27;</span>,</span><br><span class="line">          tel: <span class="string">&#x27;1310000000&#x27;</span>,</span><br><span class="line">          address: <span class="string">&#x27;浙江省杭州市拱墅区莫干山路 50 号&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">      disabledList: [</span><br><span class="line">        &#123;</span><br><span class="line">          id: <span class="string">&#x27;3&#x27;</span>,</span><br><span class="line">          name: <span class="string">&#x27;王五&#x27;</span>,</span><br><span class="line">          tel: <span class="string">&#x27;1320000000&#x27;</span>,</span><br><span class="line">          address: <span class="string">&#x27;浙江省杭州市滨江区江南大道 15 号&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">onAdd</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      Toast(<span class="string">&#x27;新增地址&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">onEdit</span>(<span class="params">item, index</span>)</span> &#123;</span><br><span class="line">      Toast(<span class="string">&#x27;编辑地址:&#x27;</span> + index);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>预览图：</p>
<img src="/2021/04/06/Phone-Store-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%89%8B%E6%9C%BA%E5%95%86%E5%9F%8E/演示4.png" width="50%">

<h4 id="2-3-AddressNew界面实现"><a href="#2-3-AddressNew界面实现" class="headerlink" title="2.3 AddressNew界面实现"></a>2.3 AddressNew界面实现</h4><p>这个界面主要用来新增地址，当点击新增地址后会跳转到该界面。</p>
<p>在实现该界面之前，必须导入一个名为 <strong style="color:red"> area.js </strong> 的文件，该文件主要用来存储各个省市的地址信息，用来提供选项调用。</p>
<img src="/2021/04/06/Phone-Store-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%89%8B%E6%9C%BA%E5%95%86%E5%9F%8E/address.png" width="50%">

<p>AddressNew 界面可以使用 Vant UI 中的AddressEdit 组件进行实现。<br>文档链接：<a href="https://vant-contrib.gitee.io/vant/#/zh-CN/address-edit">https://vant-contrib.gitee.io/vant/#/zh-CN/address-edit</a></p>
<p><strong>基础用法：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;van-address-edit</span><br><span class="line">  :area-list&#x3D;&quot;areaList&quot;</span><br><span class="line">  show-postal</span><br><span class="line">  show-delete</span><br><span class="line">  show-set-default</span><br><span class="line">  show-search-result</span><br><span class="line">  :search-result&#x3D;&quot;searchResult&quot;</span><br><span class="line">  :area-columns-placeholder&#x3D;&quot;[&#39;请选择&#39;, &#39;请选择&#39;, &#39;请选择&#39;]&quot;</span><br><span class="line">  @save&#x3D;&quot;onSave&quot;</span><br><span class="line">  @delete&#x3D;&quot;onDelete&quot;</span><br><span class="line">  @change-detail&#x3D;&quot;onChangeDetail&quot;</span><br><span class="line">&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Toast &#125; <span class="keyword">from</span> <span class="string">&#x27;vant&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      areaList,</span><br><span class="line">      searchResult: [],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">onSave</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      Toast(<span class="string">&#x27;save&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">onDelete</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      Toast(<span class="string">&#x27;delete&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">onChangeDetail</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.searchResult = [</span><br><span class="line">          &#123;</span><br><span class="line">            name: <span class="string">&#x27;黄龙万科中心&#x27;</span>,</span><br><span class="line">            address: <span class="string">&#x27;杭州市西湖区&#x27;</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        ];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.searchResult = [];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>预览图：</p>
<img src="/2021/04/06/Phone-Store-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%89%8B%E6%9C%BA%E5%95%86%E5%9F%8E/演示5.png" width="50%">

<h4 id="2-4-AddressEdit界面实现"><a href="#2-4-AddressEdit界面实现" class="headerlink" title="2.4 AddressEdit界面实现"></a>2.4 AddressEdit界面实现</h4><p>AddressEdit 界面的实现和前面的 AddressNew 的界面相差无几，只需用同样的组件稍作修改就可以了。</p>
<p><strong>需要注意的是，</strong>在之前的 AddressList 页面中，需要对修改按钮绑定一个名为<code> onEdit()</code>的点击事件，方法为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">onEdit</span>(<span class="params">item</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="built_in">JSON</span>.stringify(item)</span><br><span class="line">    <span class="built_in">this</span>.$router.push(&#123;<span class="attr">path</span>:<span class="string">&#x27;/addressEdit&#x27;</span>,<span class="attr">query</span>:&#123;<span class="attr">item</span>:data&#125;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的作用就是将地址列表里的地址对象传递给 AddressEdit 界面，从而实现对地址的编辑。</p>
<p>于是，对应的，在 AddressEdit 中的<code> created()</code>中需要取出数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//取出item对象</span></span><br><span class="line">    <span class="keyword">let</span> data = <span class="built_in">JSON</span>.parse(<span class="built_in">this</span>.$route.query.item)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-Detail-界面实现"><a href="#2-5-Detail-界面实现" class="headerlink" title="2.5 Detail 界面实现"></a>2.5 Detail 界面实现</h4><p>该界面是订单详情界面，布局比较简单，我们采用 Vant UI 中的 Cell 单元格 的布局。</p>
<p>文档链接：<a href="https://vant-contrib.gitee.io/vant/#/zh-CN/cell">https://vant-contrib.gitee.io/vant/#/zh-CN/cell</a></p>
<p>适当使用 <code> span</code>来调整单元格大小使布局看起来更合理。</p>
<p><strong>另外，值得注意的是，在 Vant UI 中，对于金额的计数单位是 ‘分’ 而不是 ‘元’，所以在处理付款金额时，需要再乘以100：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;van-submit-bar</span><br><span class="line">    :price=<span class="string">&quot;data.amount*100&quot;</span></span><br><span class="line">    button-text=<span class="string">&quot;确认付款&quot;</span></span><br><span class="line">    @submit=<span class="string">&quot;onSubmit&quot;</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<p>界面预览：</p>
<img src="/2021/04/06/Phone-Store-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%89%8B%E6%9C%BA%E5%95%86%E5%9F%8E/演示6.png" width="50%">

<h5 id="2-5-1-Success-界面实现"><a href="#2-5-1-Success-界面实现" class="headerlink" title="2.5.1 Success 界面实现"></a>2.5.1 Success 界面实现</h5><p>该界面最为简单，所以不做过多说明，所需数据仅仅只有付款金额。</p>
<p>界面预览：</p>
<img src="/2021/04/06/Phone-Store-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%89%8B%E6%9C%BA%E5%95%86%E5%9F%8E/演示7.png" width="50%">

<h5 id="2-5-2-Info-界面实现"><a href="#2-5-2-Info-界面实现" class="headerlink" title="2.5.2 Info 界面实现"></a>2.5.2 Info 界面实现</h5><p>Info 界面即订单详情界面，该界面与 Detail 界面十分雷同，所以可以直接在 Detail 界面拷贝的基础上进行修改。</p>
<p>界面预览：</p>
<img src="/2021/04/06/Phone-Store-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%89%8B%E6%9C%BA%E5%95%86%E5%9F%8E/演示8.png" width="50%">

<h3 id="3-接口文档规范"><a href="#3-接口文档规范" class="headerlink" title="3. 接口文档规范"></a>3. 接口文档规范</h3><h4 id="3-1-首页数据"><a href="#3-1-首页数据" class="headerlink" title="3.1 首页数据"></a>3.1 首页数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GET  /phone/index</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">无</span><br></pre></td></tr></table></figure>

<p>返回：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    code: 0,</span><br><span class="line">        msg: &quot;成功&quot;,</span><br><span class="line">            data:&#123;</span><br><span class="line">                categories:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        name: &quot;魅焰红&quot;,</span><br><span class="line">                        type: 1</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                    phones:[</span><br><span class="line">                        &#123;</span><br><span class="line">                            id: 1,</span><br><span class="line">                            title: &quot;Honor 8A&quot;,</span><br><span class="line">                            price: &quot;2800.00&quot;,</span><br><span class="line">                            desc: &quot;魅焰红&quot;,</span><br><span class="line">                            tag: [</span><br><span class="line">                                &#123;</span><br><span class="line">                                    name: &quot;720p珍珠屏&quot;</span><br><span class="line">                                &#125;,</span><br><span class="line">                                &#123;</span><br><span class="line">                                    name: &quot;Micro USB接口&quot;</span><br><span class="line">                                &#125;</span><br><span class="line">                            ],</span><br><span class="line">                            thumb: &quot;../static/e84a2e03-7f19-41d2-98a5-a5c16b7e252d.jpg&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                    ]</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-根据类型查询手机"><a href="#3-2-根据类型查询手机" class="headerlink" title="3.2 根据类型查询手机"></a>3.2 根据类型查询手机</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GET  /phone/findByCategoryType</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">categoryType: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>返回：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    code: 0,</span><br><span class="line">    msg: &quot;成功&quot;,</span><br><span class="line">    data: [</span><br><span class="line">        &#123;</span><br><span class="line">            id: 1,</span><br><span class="line">            title: &quot;Honor 8A&quot;,</span><br><span class="line">            price: &quot;2800.00.00&quot;,</span><br><span class="line">            desc: &quot;魅焰红&quot;,</span><br><span class="line">            tag: [</span><br><span class="line">                &#123;</span><br><span class="line">                    name: &quot;720p珍珠屏&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    name: &quot;Micro USB接口&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            thumb: &quot;../static/e84a2e03-7f19-41d2-98a5-a5c16b7e252d.jpg&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-查询手机规格"><a href="#3-3-查询手机规格" class="headerlink" title="3.3 查询手机规格"></a>3.3 查询手机规格</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GET  /phone/findSpecsByPhoneId</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">phoneID: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>返回：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    code: 0,</span><br><span class="line">    msg: &quot;成功&quot;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        goods: &#123;</span><br><span class="line">            picture: &quot;../static/e84a2e03-7f19-41d2-98a5-a5c16b7e252d.jpg&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        sku: &#123;</span><br><span class="line">            tree: [</span><br><span class="line">                &#123;</span><br><span class="line">                    k: &quot;规格&quot;,</span><br><span class="line">                    v: [</span><br><span class="line">                        &#123;</span><br><span class="line">                            id: 1,</span><br><span class="line">                            name: &quot;32GB&quot;,</span><br><span class="line">                            imgUrl: &quot;../static/e84a2e03-7f19-41d2-98a5-a5c16b7e252d.jpg&quot;,</span><br><span class="line">                            previewImgUrl: &quot;../static/e84a2e03-7f19-41d2-98a5-a5c16b7e252d.jpg&quot;</span><br><span class="line">                        &#125; ,</span><br><span class="line">                        &#123;</span><br><span class="line">                            id: 2,</span><br><span class="line">                            name: &quot;64GB&quot;,</span><br><span class="line">                            imgUrl: &quot;../static/e84a2e03-7f19-41d2-98a5-a5c16b7e252d.jpg&quot;,</span><br><span class="line">                            previewImgUrl: &quot;../static/e84a2e03-7f19-41d2-98a5-a5c16b7e252d.jpg&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                    ],</span><br><span class="line">                    k_s: &quot;s1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            list: [</span><br><span class="line">                &#123;</span><br><span class="line">                    s1: 1,</span><br><span class="line">                    price: 280000,</span><br><span class="line">                    stock_num: 1</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    s1: 2,</span><br><span class="line">                    price: 320000,</span><br><span class="line">                    stock_num: 1</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            price: &quot;2800.00&quot;,</span><br><span class="line">            stock_num: 2,</span><br><span class="line">            none_sku: false,</span><br><span class="line">            hide_stock: false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-查询地址"><a href="#3-4-查询地址" class="headerlink" title="3.4 查询地址"></a>3.4 查询地址</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GET  /address/list</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">无</span><br></pre></td></tr></table></figure>

<p>返回：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    code: 0,</span><br><span class="line">    msg: &quot;成功&quot;,</span><br><span class="line">    data: [</span><br><span class="line">        &#123;</span><br><span class="line">            areaCode: &quot;440303&quot;,</span><br><span class="line">            id: 21,</span><br><span class="line">            name: &quot;张三&quot;,</span><br><span class="line">            tel: &quot;13678787878&quot;,</span><br><span class="line">            address: &quot;广东省深圳市罗湖区科技路123号456室&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-新增地址"><a href="#3-5-新增地址" class="headerlink" title="3.5 新增地址"></a>3.5 新增地址</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">POST  /address/create</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: &quot;张三&quot;,</span><br><span class="line">    tel: &quot;13678900987&quot;,</span><br><span class="line">    country: &quot;&quot;,</span><br><span class="line">    province: &quot;北京市&quot;,</span><br><span class="line">    city: &quot;北京市&quot;,</span><br><span class="line">    county: &quot;东城区&quot;,</span><br><span class="line">    areaCode: &quot;110101&quot;,</span><br><span class="line">    postalCode: &quot;&quot;,</span><br><span class="line">    addressDetail: &quot;168号306室&quot;,</span><br><span class="line">    isDefault: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    code: 0,</span><br><span class="line">    msg: &quot;成功&quot;,</span><br><span class="line">    data: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-6-修改地址"><a href="#3-6-修改地址" class="headerlink" title="3.6 修改地址"></a>3.6 修改地址</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PUT  /address/update</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    id: 27,</span><br><span class="line">    name: &quot;张三&quot;,</span><br><span class="line">    tel: &quot;13678900987&quot;,</span><br><span class="line">    addressDetail: &quot;168号306室&quot;,</span><br><span class="line">    areaCode: &quot;110101&quot;,</span><br><span class="line">    province: &quot;北京市&quot;,</span><br><span class="line">    city: &quot;北京市&quot;,</span><br><span class="line">    county: &quot;东城区&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    code: 0,</span><br><span class="line">    msg: &quot;成功&quot;,</span><br><span class="line">    data: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-7-创建订单"><a href="#3-7-创建订单" class="headerlink" title="3.7 创建订单"></a>3.7 创建订单</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">POST  /order/create</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: &quot;张三&quot;,</span><br><span class="line">    tel: &quot;13678787878&quot;,</span><br><span class="line">    address: &quot;广东省深圳市罗湖区科技路123号456室&quot;,</span><br><span class="line">    specsId: 1,</span><br><span class="line">    quantity: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    code: 0,</span><br><span class="line">    msg: &quot;成功&quot;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        orderId: &quot;1586254006069813075&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-8-订单详情"><a href="#3-8-订单详情" class="headerlink" title="3.8 订单详情"></a>3.8 订单详情</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    code: 0,</span><br><span class="line">    msg: &quot;成功&quot;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        orderId: &quot;1586253884545138376&quot;,</span><br><span class="line">        buyerName: &quot;张三&quot;,</span><br><span class="line">        phoneName: &quot;Honor 8A&quot;,</span><br><span class="line">        payStatus: 0,</span><br><span class="line">        freight: 10,</span><br><span class="line">        tel: &quot;13678787878&quot;,</span><br><span class="line">        address: &quot;广东省深圳市罗湖区科技路123号456室&quot;,</span><br><span class="line">        num: 1,</span><br><span class="line">        specs: &quot;32GB&quot;,</span><br><span class="line">        price: &quot;2800.00.00&quot;,</span><br><span class="line">        icon: &quot;../static/e84a2e03-7f19-41d2-98a5-a5c16b7e252d.jpg&quot;,</span><br><span class="line">        amount: 2800</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-9-支付订单"><a href="#3-9-支付订单" class="headerlink" title="3.9 支付订单"></a>3.9 支付订单</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PUT  /order/pay</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">orderId: &quot;1586253884545138376&quot;</span><br></pre></td></tr></table></figure>

<p>返回：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   	code: 0,</span><br><span class="line">    msg: &quot;成功&quot;,</span><br><span class="line">    data: &quot;1586253884545138376&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-数据表持久化"><a href="#4-数据表持久化" class="headerlink" title="4.数据表持久化"></a>4.数据表持久化</h3><p>在进行此操作时，由于我们有使用 Spring Data JPA ，所以我们只需要构建实体类和工厂接口，但是无需对接口进行实现，JPA 会自动帮我们完成常用方法的实现。</p>
<h4 id="4-1-PhoneCategory-持久化"><a href="#4-1-PhoneCategory-持久化" class="headerlink" title="4.1 PhoneCategory 持久化"></a>4.1 PhoneCategory 持久化</h4><p>数据库表 phone_category 有如下数据：</p>
<p><img src="/2021/04/06/Phone-Store-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%89%8B%E6%9C%BA%E5%95%86%E5%9F%8E/phoneCategory.png" alt="phoneCategory"></p>
<blockquote>
<p>构建实体类 PhoneCategory :</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneCategory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span>   <span class="comment">//设置主键</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span> <span class="comment">//设置自增方式</span></span><br><span class="line">    <span class="keyword">private</span> Integer categoryId;</span><br><span class="line">    <span class="keyword">private</span> String categoryName;</span><br><span class="line">    <span class="keyword">private</span> Integer categoryType;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建 Repository 接口：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PhoneCategoryRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">PhoneCategory</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> PhoneCategory <span class="title">findByCategoryType</span><span class="params">(Integer categoryType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneCategoryRepositoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PhoneCategoryRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;PhoneCategory&gt; list=repository.findAll();</span><br><span class="line">        <span class="keyword">for</span> (PhoneCategory phoneCategory : list) &#123;</span><br><span class="line">            System.out.println(phoneCategory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findByCategoryType</span><span class="params">()</span></span>&#123;</span><br><span class="line">        PhoneCategory phoneCategory = repository.findByCategoryType(<span class="number">1</span>);</span><br><span class="line">        System.out.println(phoneCategory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-PhoneInfo-持久化"><a href="#4-2-PhoneInfo-持久化" class="headerlink" title="4.2 PhoneInfo 持久化"></a>4.2 PhoneInfo 持久化</h4><p>数据库表有如下数据：</p>
<p><img src="/2021/04/06/Phone-Store-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%89%8B%E6%9C%BA%E5%95%86%E5%9F%8E/phoneInfo.png" alt="phoneInfo"></p>
<blockquote>
<p>构建实体类 PhoneInfo ：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneInfo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Integer phoneId;</span><br><span class="line">    <span class="keyword">private</span> String phoneName;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal phonePrice;</span><br><span class="line">    <span class="keyword">private</span> String phoneDescription;</span><br><span class="line">    <span class="keyword">private</span> Integer phoneStock;</span><br><span class="line">    <span class="keyword">private</span> String phoneIcon;</span><br><span class="line">    <span class="keyword">private</span> Integer categoryType;</span><br><span class="line">    <span class="keyword">private</span> String phoneTag;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建 PhoneInfoRepository ：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PhoneInfoRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">PhoneInfo</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;PhoneInfo&gt; <span class="title">findAllByCategoryType</span><span class="params">(Integer categoryType)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试 ：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneInfoRepositoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PhoneInfoRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;PhoneInfo&gt; list= repository.findAll();</span><br><span class="line">        <span class="keyword">for</span> (PhoneInfo phoneInfo : list) &#123;</span><br><span class="line">            System.out.println(phoneInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findAllByCategoryType</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;PhoneInfo&gt; list = repository.findAllByCategoryType(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (PhoneInfo phoneInfo : list) &#123;</span><br><span class="line">            System.out.println(phoneInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-PhoneSpecs-持久化"><a href="#4-3-PhoneSpecs-持久化" class="headerlink" title="4.3 PhoneSpecs 持久化"></a>4.3 PhoneSpecs 持久化</h4><p>数据库有如下数据：</p>
<p><img src="/2021/04/06/Phone-Store-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%89%8B%E6%9C%BA%E5%95%86%E5%9F%8E/phoneSpecs.png" alt="phoneSpecs"></p>
<blockquote>
<p>构建实体类 PhoneSpecs:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneSpecs</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Integer specsId;</span><br><span class="line">    <span class="keyword">private</span> Integer phoneId;</span><br><span class="line">    <span class="keyword">private</span> String specsName;</span><br><span class="line">    <span class="keyword">private</span> Integer specsStock;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal specsPrice;</span><br><span class="line">    <span class="keyword">private</span> String specsIcon;</span><br><span class="line">    <span class="keyword">private</span> String specsPreview;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建 PhoneSpecsRepository ：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PhoneSpecsRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">PhoneSpecs</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;PhoneSpecs&gt; <span class="title">findAllByPhoneId</span><span class="params">(Integer phoneId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneSpecsRepositoryTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PhoneSpecsRepository repository;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;PhoneSpecs&gt; list = repository.findAll();</span><br><span class="line">        <span class="keyword">for</span> (PhoneSpecs phoneSpecs : list) &#123;</span><br><span class="line">            System.out.println(phoneSpecs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-BuyerAddress-持久化"><a href="#4-4-BuyerAddress-持久化" class="headerlink" title="4.4 BuyerAddress 持久化"></a>4.4 BuyerAddress 持久化</h4><p>数据库有如下数据：</p>
<p><img src="/2021/04/06/Phone-Store-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%89%8B%E6%9C%BA%E5%95%86%E5%9F%8E/buyerAddress.png" alt="buyerAddress"></p>
<blockquote>
<p>构建实体类 BuyerAddress ：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@DynamicInsert</span></span><br><span class="line"><span class="meta">@DynamicUpdate</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyerAddress</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Integer addressId;</span><br><span class="line">    <span class="keyword">private</span> String buyerName;</span><br><span class="line">    <span class="keyword">private</span> String buyerPhone;</span><br><span class="line">    <span class="keyword">private</span> String buyerAddress;</span><br><span class="line">    <span class="keyword">private</span> String areaCode;</span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建 BuyerAddressRepository ：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BuyerAddressRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">BuyerAddress</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyerAddressRepositoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BuyerAddressRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;BuyerAddress&gt; list = repository.findAll();</span><br><span class="line">        <span class="keyword">for</span> (BuyerAddress buyerAddress : list) &#123;</span><br><span class="line">            System.out.println(buyerAddress);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>&#123;</span><br><span class="line">        BuyerAddress buyerAddress = <span class="keyword">new</span> BuyerAddress();</span><br><span class="line">        buyerAddress.setAreaCode(<span class="string">&quot;330104&quot;</span>);</span><br><span class="line">        buyerAddress.setBuyerAddress(<span class="string">&quot;广东省深圳市罗湖区科技路123号456室&quot;</span>);</span><br><span class="line">        buyerAddress.setBuyerName(<span class="string">&quot;小红&quot;</span>);</span><br><span class="line">        buyerAddress.setBuyerPhone(<span class="string">&quot;13967856432&quot;</span>);</span><br><span class="line">        repository.save(buyerAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">        BuyerAddress buyerAddress = repository.findById(<span class="number">36</span>).get();</span><br><span class="line">        buyerAddress.setBuyerName(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">        repository.save(buyerAddress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-5-OrderMaster-持久化"><a href="#4-5-OrderMaster-持久化" class="headerlink" title="4.5 OrderMaster 持久化"></a>4.5 OrderMaster 持久化</h4><p>数据库有如下数据</p>
]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Spring Boot+Vue</tag>
        <tag>前后端分离</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Hexo初次搭建个人博客</title>
    <url>/2021/04/04/%E5%9F%BA%E4%BA%8EHexo%E5%88%9D%E6%AC%A1%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h6 id="初次搭建博客，基于-hexo-搭建的静态博客。"><a href="#初次搭建博客，基于-hexo-搭建的静态博客。" class="headerlink" title="初次搭建博客，基于 hexo 搭建的静态博客。"></a>初次搭建博客，基于 hexo 搭建的静态博客。</h6><span id="more"></span>

<blockquote>
<p>简介：GitHub Pages 和 Hexo &amp; 原理</p>
<ul>
<li><h4 id="Hexo-是什么？"><a href="#Hexo-是什么？" class="headerlink" title="Hexo 是什么？"></a>Hexo 是什么？</h4><ul>
<li>官网：<a href="https://hexo.io/">hexo.io</a></li>
<li>Hexo 是一个快速、简洁且高效的静态博客框架，它基于 Node.js 运行，可以将我们撰写的 Markdown 文档解析渲染成静态的 HTML 网页。</li>
</ul>
</li>
<li><h4 id="Hexo-GitHub-文章发布原理"><a href="#Hexo-GitHub-文章发布原理" class="headerlink" title="Hexo + GitHub 文章发布原理"></a>Hexo + GitHub 文章发布原理</h4><ul>
<li><p>在本地撰写 Markdown 格式文章后，通过 Hexo 解析文档，渲染生成具有主题样式的 HTML 静态网页，再推送到 GitHub 上完成博文的发布。</p>
<p><img src="/2021/04/04/%E5%9F%BA%E4%BA%8EHexo%E5%88%9D%E6%AC%A1%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%8F%91%E6%96%87%E6%B5%81%E7%A8%8B.jpg" alt="发文流程"></p>
</li>
</ul>
</li>
<li><h4 id="优点和不足"><a href="#优点和不足" class="headerlink" title="优点和不足"></a>优点和不足</h4><ul>
<li><strong>优点：</strong>完全免费；静态站点，轻量快速；可按需求自由定制改造；托管在 GitHub，安全省心；迁移方便……</li>
<li><strong>缺点：</strong>发文不便，依赖于本地环境；更适合个人博客使用；GitHub 在国内访问速度有点不快。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="1-准备"><a href="#1-准备" class="headerlink" title="1 准备"></a>1 准备</h2><h3 id="1-1-注意事项"><a href="#1-1-注意事项" class="headerlink" title="1.1 注意事项"></a>1.1 注意事项</h3><ul>
<li><p>该博文使用 Windows 10 搭建；</p>
</li>
<li><p>将文中的 “用户名” 和 “邮箱” 替换为自己的 GitHub 账户名和绑定的邮箱；</p>
</li>
<li><p>统一使用 Git Bash 进行操作（支持 Win、Mac）；</p>
</li>
</ul>
<h3 id="1-2-环境搭建"><a href="#1-2-环境搭建" class="headerlink" title="1.2 环境搭建"></a>1.2 环境搭建</h3><p>Hexo 基于 Node.js，搭建过程中还需要使用 npm（Node.js 已带） 和 git，因此先搭建本地操作环境，安装 Node.js 和 Git。</p>
<ul>
<li>Node.js：<a href="https://link.zhihu.com/?target=https://nodejs.org/zh-cn">https://nodejs.org/zh-cn</a></li>
<li>Git：<a href="https://link.zhihu.com/?target=https://git-scm.com/downloads">https://git-scm.com/downloads</a></li>
</ul>
<h2 id="2-本地安装-Hexo-博客程序"><a href="#2-本地安装-Hexo-博客程序" class="headerlink" title="2 本地安装 Hexo 博客程序"></a>2 本地安装 Hexo 博客程序</h2><p>新建一个文件夹用来存放 Hexo 的程序文件，如 MyBlog。打开该文件夹，右键 -&gt; Git Bash Here。</p>
<h3 id="2-1-安装-Hexo"><a href="#2-1-安装-Hexo" class="headerlink" title="2.1 安装 Hexo"></a>2.1 安装 Hexo</h3><p>在 <code>bash</code> 中进入 MyBlog 目录中，使用npm安装 Hexo ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>若安装较慢可以使用淘宝镜像安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/04/%E5%9F%BA%E4%BA%8EHexo%E5%88%9D%E6%AC%A1%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png" alt="hexo安装成功"></p>
<h3 id="2-2-Hexo-初始化和本地预览"><a href="#2-2-Hexo-初始化和本地预览" class="headerlink" title="2.2 Hexo 初始化和本地预览"></a>2.2 Hexo 初始化和本地预览</h3><h4 id="初始化并安装所需组件"><a href="#初始化并安装所需组件" class="headerlink" title="初始化并安装所需组件"></a>初始化并安装所需组件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init         <span class="comment">#初始化</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>安装组件</p>
</blockquote>
<p>​        安装 hexo-asset-image 组件，用来在博客中显示图片。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<p>​        或者用淘宝镜像安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<p> <img src="/2021/04/04/%E5%9F%BA%E4%BA%8EHexo%E5%88%9D%E6%AC%A1%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%AE%89%E8%A3%85%E5%9B%BE%E7%89%87%E6%8F%92%E4%BB%B6.png" alt="安装图片插件"></p>
<p>完成后依次输入以下命令，<strong>启动本地服务器进行预览:<br></strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g     <span class="comment">#生成页面</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s	   <span class="comment">#启动预览</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/04/%E5%9F%BA%E4%BA%8EHexo%E5%88%9D%E6%AC%A1%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%90%AF%E5%8A%A8%E9%A2%84%E8%A7%88.png" alt="启动预览"></p>
<p><strong>访问<code> http://localhost:4000</code>,出现 Hexo 默认页面，即本地博客安装成功！</strong></p>
<p><img src="/2021/04/04/%E5%9F%BA%E4%BA%8EHexo%E5%88%9D%E6%AC%A1%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png" alt="本地安装成功"></p>
<h2 id="3-部署-Hexo-到-GitHub-Pages"><a href="#3-部署-Hexo-到-GitHub-Pages" class="headerlink" title="3 部署 Hexo 到 GitHub Pages"></a>3 部署 Hexo 到 GitHub Pages</h2><h3 id="3-1-创建GitHub-Pages-仓库"><a href="#3-1-创建GitHub-Pages-仓库" class="headerlink" title="3.1 创建GitHub Pages 仓库"></a>3.1 创建GitHub Pages 仓库</h3><p>登录到GitHub个人主页，选择 New repository:</p>
<p><img src="/2021/04/04/%E5%9F%BA%E4%BA%8EHexo%E5%88%9D%E6%AC%A1%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93.png" alt="创建仓库"></p>
<p><img src="/2021/04/04/%E5%9F%BA%E4%BA%8EHexo%E5%88%9D%E6%AC%A1%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%9302.jpg" alt="创建仓库02"></p>
<p>创建后默认自动启用 HTTPS，博客地址为：<code>https://用户名.github.io</code></p>
<h3 id="3-2-部署到仓库"><a href="#3-2-部署到仓库" class="headerlink" title="3.2 部署到仓库"></a>3.2 部署到仓库</h3><blockquote>
<p>设置用户名和邮箱</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;GitHub用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;GitHub邮箱&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建 SSH 密匙：</p>
</blockquote>
<p>输入 <code> ssh-keygen -t rsa -C &quot;GitHub邮箱&quot;</code>，然后一路回车。</p>
<p><strong>添加密匙：</strong></p>
<p>进入 [C:\Users\用户名.ssh] 目录（要勾选显示“隐藏的项目”），用记事本打开公钥 id_rsa.pub 文件并复制里面的内容。</p>
<p>登陆 GitHub ，进入 Settings 页面，选择左边栏的 SSH and GPG keys，点击 New SSH key。</p>
<p>Title 随便取个名字，粘贴复制的 id_rsa.pub 内容到 Key 中，点击 Add SSH key 完成添加。</p>
<blockquote>
<p>安装 hexo-deployer-git ：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改配置文件 _config.yml :</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">	<span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">	<span class="attr">repository:</span> <span class="string">https://github.com/用户名/用户名.github.io</span></span><br><span class="line">	<span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>开始生成和部署发布</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g   <span class="comment">#生成页面</span></span><br><span class="line">hexo d   <span class="comment">#部署发布</span></span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>必备技能</tag>
      </tags>
  </entry>
</search>
